"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunksound_particle_visualization"] = self["webpackChunksound_particle_visualization"] || []).push([["components"],{

/***/ "./src/components/Button.js":
/*!**********************************!*\
  !*** ./src/components/Button.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Button: () => (/* binding */ Button)\n/* harmony export */ });\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar Button = /*#__PURE__*/function () {\n  function Button(text, position, onClick) {\n    _classCallCheck(this, Button);\n    this.text = text;\n    this.position = position;\n    this.onClick = onClick;\n    this.button = null;\n    this.isSelected = false;\n    this.createButton();\n  }\n  return _createClass(Button, [{\n    key: \"createButton\",\n    value: function createButton() {\n      var existingBtn = document.getElementById(\"\".concat(this.text.toLowerCase(), \"-btn\"));\n      if (existingBtn) {\n        this.button = existingBtn;\n        this.button.onclick = this.handleClick.bind(this);\n        return;\n      }\n      this.button = document.createElement('button');\n      this.button.id = \"\".concat(this.text.toLowerCase(), \"-btn\");\n      this.button.className = 'main-screen-btn';\n\n      // Wrap text in a span for the animation\n      var textSpan = document.createElement('span');\n      textSpan.className = 'button-text';\n      textSpan.innerText = this.text.toUpperCase();\n      this.button.appendChild(textSpan);\n      this.button.onclick = this.handleClick.bind(this);\n      this.addToContainer();\n    }\n\n    // Handle click to toggle selection and call original onClick\n  }, {\n    key: \"handleClick\",\n    value: function handleClick() {\n      var _this = this;\n      // DON'T call this.onClick() here anymore - let main.js handle it\n      // this.onClick();  // <-- REMOVE THIS LINE\n\n      // Just manage menu closing\n      setTimeout(function () {\n        var _document$querySelect;\n        var isSaveModeActive = ((_document$querySelect = document.querySelector('#save-btn .button-text')) === null || _document$querySelect === void 0 ? void 0 : _document$querySelect.innerText) === 'EXIT SAVE';\n        if (!isSaveModeActive) {\n          _this.closeHamburgerMenu();\n        }\n      }, 100);\n    }\n  }, {\n    key: \"closeHamburgerMenu\",\n    value: function closeHamburgerMenu() {\n      var hamburgerButton = document.querySelector('.hamburger-button');\n      var optionsContainer = document.querySelector('.hamburger-options');\n      if (hamburgerButton && optionsContainer) {\n        hamburgerButton.classList.remove('open');\n        optionsContainer.classList.remove('open');\n      }\n    }\n  }, {\n    key: \"addToContainer\",\n    value: function addToContainer() {\n      if (!window.navigationContainers) return;\n\n      // All buttons now go to the hamburger menu instead of corners\n      var container = window.navigationContainers.hamburgerMenu || document.body;\n      container.appendChild(this.button);\n    }\n\n    // Set selected state \n  }, {\n    key: \"setSelected\",\n    value: function setSelected() {\n      var selected = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      this.isSelected = selected;\n      if (selected) {\n        this.button.classList.add('selected');\n      } else {\n        this.button.classList.remove('selected', 'show-underline-delayed');\n      }\n    }\n\n    // Smooth text change with animation\n  }, {\n    key: \"changeText\",\n    value: function changeText(newText) {\n      var _this2 = this;\n      var textSpan = this.button.querySelector('.button-text');\n      if (textSpan.innerText === newText.toUpperCase()) return;\n\n      // Convert old span to .old\n      textSpan.className = 'button-text old';\n\n      // Create new span as .new\n      var newSpan = document.createElement('span');\n      newSpan.className = 'button-text new';\n      newSpan.innerText = newText.toUpperCase();\n      this.button.appendChild(newSpan);\n\n      // Force reflow for transition\n      this.button.offsetHeight;\n\n      // Trigger transition\n      this.button.classList.add('text-changing');\n\n      // Clean up after transition\n      setTimeout(function () {\n        _this2.button.classList.remove('text-changing');\n        textSpan.remove();\n        newSpan.className = 'button-text';\n      }, 1400);\n    }\n  }, {\n    key: \"hide\",\n    value: function hide() {\n      if (this.button) {\n        this.button.classList.add('hidden');\n      }\n    }\n  }, {\n    key: \"show\",\n    value: function show() {\n      if (this.button) {\n        this.button.classList.remove('hidden');\n      }\n    }\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      if (this.button) {\n        this.button.remove();\n      }\n    }\n  }]);\n}();\n\n//# sourceURL=webpack://sound-particle-visualization/./src/components/Button.js?");

/***/ }),

/***/ "./src/components/EvolvingUI.js":
/*!**************************************!*\
  !*** ./src/components/EvolvingUI.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EvolvingUI: () => (/* binding */ EvolvingUI)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n/* harmony import */ var _Button_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Button.js */ \"./src/components/Button.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _createForOfIteratorHelper(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\nvar EvolvingUI = /*#__PURE__*/function () {\n  function EvolvingUI(mainRenderer, mainCamera, controls, particleSystem, pythonCommunication, library) {\n    var _this = this;\n    _classCallCheck(this, EvolvingUI);\n    this.mainRenderer = mainRenderer;\n    this.mainCamera = mainCamera;\n    this.controls = controls;\n    this.particleSystem = particleSystem;\n    this.pythonCommunication = pythonCommunication;\n    this.library = library;\n\n    // **NEW: Scene transition mode storage**\n    this.allSolutions = [];\n    this.categoryMeshes = {\n      'low': [],\n      'mid': [],\n      'high': [],\n      'rhythmic': []\n    };\n\n    // **NEW: Scoring storage**\n    this.allTabScores = new Map();\n    this.submitButton = null;\n\n    // **Scoring system bounds**\n\n    this.scoreArea = {\n      minY: -12,\n      maxY: 30,\n      minScore: 0.0,\n      maxScore: 1.0\n    };\n    this.solidMeshes = this.particleSystem.getSolids ? this.particleSystem.getSolids() : [];\n    this.numSolids = this.solidMeshes.length;\n    this.activeTab = 'low';\n\n    // Store original camera and solid positions**\n    this.originalCameraPosition = this.mainCamera.position.clone();\n    this.originalCameraTarget = this.controls && this.controls.target ? this.controls.target.clone() : new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();\n    this.originalSolidPositions = new Map();\n    this.isEvolvingMode = false;\n\n    // Interaction state**\n    this.drag = {\n      active: false,\n      mesh: null,\n      playingId: null\n    };\n    this.dragYScale = 0.04;\n\n    // Persist Y per-tab until submit\n    this.savedYByTab = new Map();\n    this.idToGlobalIndex = new Map();\n    this.globalBaselineCenterY = null;\n\n    // NEW: track which tabs were actually opened/aligned this session\n    this.visitedTabs = new Set();\n\n    // ADDED: Submission flag\n    this._isSubmitting = false;\n\n    // 'auto-average' = average center-Y of all solids at enterEvolvingMode (default)\n\n    this.baselineMode = 'auto-average';\n    //this.fixedBaselineCenterY = 10;  \n\n    this.fixedCameraTargetPos = null; // THREE.Vector3\n    this.fixedCameraTargetLook = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, 0, 0);\n\n    // Look for existing button\n    var existingEvolveBtn = document.getElementById('evolve-btn');\n    if (existingEvolveBtn) {\n      this.evolveBtn = existingEvolveBtn;\n    } else {\n      this.evolveBtn = new _Button_js__WEBPACK_IMPORTED_MODULE_0__.Button('EVOLVE', 'hamburger', function () {});\n    }\n\n    // Remove any old toggle handlers so modeManager has full control\n    var detachClick = function detachClick(btnRef) {\n      if (!btnRef) return;\n      if (btnRef.button instanceof HTMLElement) {\n        btnRef.button.onclick = null;\n      } else if (btnRef.element instanceof HTMLElement) {\n        btnRef.element.onclick = null;\n      } else if (btnRef instanceof HTMLElement) {\n        btnRef.onclick = null;\n      }\n    };\n    detachClick(this.evolveBtn);\n    this.evolveBtn.onclick = function () {\n      return _this.toggleEvolvingMode();\n    };\n    this.createTabsUI();\n    this.createReferenceScale();\n    this.createCloseButton(); // NEW: Add close button\n    this.setupInteraction();\n  }\n  return _createClass(EvolvingUI, [{\n    key: \"createTabsUI\",\n    value: function createTabsUI() {\n      var _this2 = this;\n      // Create floating tabs interface\n      this.tabsContainer = document.createElement('div');\n      this.tabsContainer.className = 'evolve-tabs-floating';\n      this.tabsContainer.style.display = 'none';\n      var tabs = [{\n        id: 'low',\n        label: 'Low'\n      }, {\n        id: 'mid',\n        label: 'Mid'\n      }, {\n        id: 'high',\n        label: 'High'\n      }, {\n        id: 'rhythmic',\n        label: 'Rhythmic'\n      }];\n      tabs.forEach(function (tab) {\n        var tabButton = document.createElement('button');\n        tabButton.className = 'evolve-tab-button';\n        tabButton.textContent = tab.label;\n        tabButton.dataset.value = tab.id;\n        if (tab.id === _this2.activeTab) tabButton.classList.add('active');\n        tabButton.addEventListener('click', function (e) {\n          e.preventDefault();\n          _this2.switchTab(tab.id);\n        });\n        _this2.tabsContainer.appendChild(tabButton);\n      });\n      document.body.appendChild(this.tabsContainer);\n    }\n\n    // NEW: Create visual reference scale\n  }, {\n    key: \"createReferenceScale\",\n    value: function createReferenceScale() {\n      // Create scale container\n      this.scaleContainer = document.createElement('div');\n      this.scaleContainer.className = 'evolve-reference-scale';\n      this.scaleContainer.style.display = 'none';\n\n      // Create vertical line\n      var line = document.createElement('div');\n      line.className = 'scale-line';\n\n      // Create top label\n      var topLabel = document.createElement('div');\n      topLabel.className = 'scale-label scale-label-top';\n      topLabel.textContent = 'Best Sound';\n\n      // Create bottom label\n      var bottomLabel = document.createElement('div');\n      bottomLabel.className = 'scale-label scale-label-bottom';\n      bottomLabel.textContent = 'Worse Sound';\n      this.scaleContainer.appendChild(topLabel);\n      this.scaleContainer.appendChild(line);\n      this.scaleContainer.appendChild(bottomLabel);\n      document.body.appendChild(this.scaleContainer);\n    }\n\n    // NEW: Update reference scale visual position\n  }, {\n    key: \"updateReferenceScalePosition\",\n    value: function updateReferenceScalePosition() {\n      var _this$fixedCameraTarg, _this$fixedCameraTarg2, _this$fixedCameraTarg3, _this$fixedCameraTarg4;\n      if (!this.scaleContainer) return;\n\n      // Get the current solids for active tab to find their baseline position\n      var filtered = this.getSolidsByTab(this.activeTab);\n      if (filtered.length === 0) {\n        // Hide scale if no solids\n        this.scaleContainer.style.display = 'none';\n        return;\n      }\n      this.scaleContainer.style.display = 'flex';\n\n      // Project score area min/max to screen space\n      var baselineY = typeof this.globalBaselineCenterY === 'number' ? this.globalBaselineCenterY : this.scoreArea.minY;\n      var bottomWorld = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, baselineY, (_this$fixedCameraTarg = (_this$fixedCameraTarg2 = this.fixedCameraTargetLook) === null || _this$fixedCameraTarg2 === void 0 ? void 0 : _this$fixedCameraTarg2.z) !== null && _this$fixedCameraTarg !== void 0 ? _this$fixedCameraTarg : 0);\n      var topWorld = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, this.scoreArea.maxY, (_this$fixedCameraTarg3 = (_this$fixedCameraTarg4 = this.fixedCameraTargetLook) === null || _this$fixedCameraTarg4 === void 0 ? void 0 : _this$fixedCameraTarg4.z) !== null && _this$fixedCameraTarg3 !== void 0 ? _this$fixedCameraTarg3 : 0);\n      var bottomScreen = this.worldToScreen(bottomWorld);\n      var topScreen = this.worldToScreen(topWorld);\n\n      // Calculate scale dimensions\n      var scaleHeight = bottomScreen.y - topScreen.y;\n      var scaleTop = topScreen.y;\n\n      // Position scale on LEFT side (changed from 88% to 12%)\n      var leftOffset = window.innerWidth * 0.12; // 12% from left\n\n      // Update scale container\n      this.scaleContainer.style.top = \"\".concat(scaleTop, \"px\");\n      this.scaleContainer.style.left = \"\".concat(leftOffset, \"px\");\n      this.scaleContainer.style.height = \"\".concat(scaleHeight, \"px\");\n\n      // Update line height\n      var line = this.scaleContainer.querySelector('.scale-line');\n      if (line) {\n        line.style.height = \"\".concat(scaleHeight, \"px\");\n      }\n    }\n\n    // Add this helper method to convert world position to screen coordinates\n  }, {\n    key: \"worldToScreen\",\n    value: function worldToScreen(worldPos) {\n      var vector = worldPos.clone();\n      vector.project(this.mainCamera);\n      return {\n        x: (vector.x * 0.5 + 0.5) * window.innerWidth,\n        y: (vector.y * -0.5 + 0.5) * window.innerHeight\n      };\n    }\n  }, {\n    key: \"toggleEvolvingMode\",\n    value: function toggleEvolvingMode() {\n      if (this.isEvolvingMode) {\n        this.exitEvolvingMode();\n      } else {\n        this.enterEvolvingMode();\n      }\n    }\n\n    // Helper: get solids for a specific tab\n  }, {\n    key: \"getSolidsByTab\",\n    value: function getSolidsByTab(tabId) {\n      return this.solidMeshes.filter(function (m) {\n        var _m$userData;\n        var cat = (_m$userData = m.userData) === null || _m$userData === void 0 || (_m$userData = _m$userData.solution) === null || _m$userData === void 0 ? void 0 : _m$userData.actual_category;\n        return typeof cat === 'string' && cat.toLowerCase() === tabId;\n      });\n    }\n\n    // Compute spacing/total depth/camera for a given solids array\n  }, {\n    key: \"computeLayoutMetricsForSolids\",\n    value: function computeLayoutMetricsForSolids(solids) {\n      if (!solids || solids.length === 0) {\n        return {\n          count: 0,\n          spacing: 0,\n          totalDepth: 0,\n          camDist: 70,\n          targetPos: new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(70, 10, 0),\n          targetLook: new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, 0, 0)\n        };\n      }\n      var maxDepth = 1;\n      var box = new three__WEBPACK_IMPORTED_MODULE_1__.Box3();\n      var _iterator = _createForOfIteratorHelper(solids),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var m = _step.value;\n          box.setFromObject(m);\n          var dz = box.getSize(new three__WEBPACK_IMPORTED_MODULE_1__.Vector3()).z;\n          if (dz > maxDepth) maxDepth = dz;\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      var spacing = maxDepth * 1.35;\n      var totalDepth = (solids.length - 1) * spacing;\n      var camDist = Math.max(25, totalDepth * 0.9 + 70);\n      var targetPos = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(camDist, 10, 0);\n      var targetLook = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, 0, 0);\n      return {\n        count: solids.length,\n        spacing: spacing,\n        totalDepth: totalDepth,\n        camDist: camDist,\n        targetPos: targetPos,\n        targetLook: targetLook\n      };\n    }\n\n    // Compute fixed camera based on the tab that has the most solutions\n  }, {\n    key: \"computeFixedCameraFromMaxTab\",\n    value: function computeFixedCameraFromMaxTab() {\n      var tabs = ['low', 'mid', 'high', 'rhythmic'];\n      var best = {\n        tab: null,\n        metrics: null\n      };\n      for (var _i = 0, _tabs = tabs; _i < _tabs.length; _i++) {\n        var tab = _tabs[_i];\n        var solids = this.getSolidsByTab(tab);\n        var metrics = this.computeLayoutMetricsForSolids(solids);\n        if (!best.metrics) {\n          best = {\n            tab: tab,\n            metrics: metrics\n          };\n        } else {\n          // Prefer higher count; tiebreaker by larger totalDepth\n          if (metrics.count > best.metrics.count || metrics.count === best.metrics.count && metrics.totalDepth > best.metrics.totalDepth) {\n            best = {\n              tab: tab,\n              metrics: metrics\n            };\n          }\n        }\n      }\n\n      // Fallback if no tab has solids\n      if (!best.metrics) {\n        best.metrics = this.computeLayoutMetricsForSolids([]);\n        best.tab = 'low';\n      }\n      this.fixedCameraTargetPos = best.metrics.targetPos.clone();\n      this.fixedCameraTargetLook = best.metrics.targetLook.clone();\n      console.log('[Evolve] Fixed camera chosen from tab:', best.tab, 'metrics:', {\n        count: best.metrics.count,\n        spacing: best.metrics.spacing,\n        totalDepth: best.metrics.totalDepth,\n        targetPos: {\n          x: this.fixedCameraTargetPos.x,\n          y: this.fixedCameraTargetPos.y,\n          z: this.fixedCameraTargetPos.z\n        },\n        targetLook: {\n          x: this.fixedCameraTargetLook.x,\n          y: this.fixedCameraTargetLook.y,\n          z: this.fixedCameraTargetLook.z\n        }\n      });\n    }\n\n    // Compute a single baseline center-Y from all solids (average of their centers)\n  }, {\n    key: \"computeGlobalBaselineCenterY\",\n    value: function computeGlobalBaselineCenterY() {\n      if (!this.solidMeshes || this.solidMeshes.length === 0) return 0;\n      var box = new three__WEBPACK_IMPORTED_MODULE_1__.Box3();\n      var sum = 0,\n        n = 0;\n      var _iterator2 = _createForOfIteratorHelper(this.solidMeshes),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var m = _step2.value;\n          box.setFromObject(m);\n          var c = box.getCenter(new three__WEBPACK_IMPORTED_MODULE_1__.Vector3());\n          if (Number.isFinite(c.y)) {\n            sum += c.y;\n            n++;\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      return n ? sum / n : 0;\n    }\n\n    // Optional helper to set a fixed baseline at runtime\n  }, {\n    key: \"setInitialBaselineY\",\n    value: function setInitialBaselineY(y) {\n      this.baselineMode = 'fixed';\n      this.fixedBaselineCenterY = y;\n      if (this.isEvolvingMode) {\n        this.globalBaselineCenterY = y;\n        console.log('[Evolve] Baseline switched to fixed:', y);\n        this.transitionToEvolvingLayout(); // re-align current tab\n      }\n    }\n  }, {\n    key: \"enterEvolvingMode\",\n    value: function enterEvolvingMode() {\n      var _this3 = this;\n      // Guard clause\n      if (!this.particleSystem.peaks || this.particleSystem.peaks.length === 0) {\n        console.warn('‚ö†Ô∏è Cannot enter evolving mode - no peaks initialized');\n        return;\n      }\n      console.log('üéÆ Entering evolving mode');\n      this.isEvolvingMode = true;\n      this.storeOriginalPositions();\n\n      // NEW: Change button text and set selected state\n\n      setTimeout(function () {\n        _this3.evolveBtn.setSelected(true);\n      }, 500);\n\n      // Stop main soundscape and fade out\n      try {\n        var _this$particleSystem;\n        (_this$particleSystem = this.particleSystem) === null || _this$particleSystem === void 0 || (_this$particleSystem = _this$particleSystem.surroundController) === null || _this$particleSystem === void 0 || _this$particleSystem.startMode(500);\n      } catch (_unused) {}\n      if (this.controls) this.controls.enabled = false;\n      if (this.tabsContainer) this.tabsContainer.style.display = 'flex';\n      this.solidMeshes = this.particleSystem.getSolids ? this.particleSystem.getSolids() : this.solidMeshes;\n      this.savedYByTab.clear();\n      this.visitedTabs.clear();\n      this.solidMeshes.forEach(function (m) {\n        delete m.userData.hasUserDragged;\n      });\n      if (this.baselineMode === 'fixed') {\n        this.globalBaselineCenterY = this.fixedBaselineCenterY;\n        console.log('[Evolve] Global baseline center-Y set (fixed) to', this.globalBaselineCenterY);\n      } else {\n        this.globalBaselineCenterY = this.computeGlobalBaselineCenterY();\n        console.log('[Evolve] Global baseline center-Y set (auto-average) to', this.globalBaselineCenterY);\n      }\n      this.computeFixedCameraFromMaxTab();\n      this.loadSolutionsFromParticleSystem();\n      this.alignAllSolidsToBaselineOrSaved();\n      this.transitionToEvolvingLayout();\n      this.solidMeshes.forEach(function (m) {\n        if (m.visible) m.userData.evolvingManualY = true;\n      });\n\n      // REMOVED: Don't show scale immediately\n      // if (this.scaleContainer) {\n      //     this.scaleContainer.style.display = 'flex';\n      //     setTimeout(() => {\n      //         this.updateReferenceScalePosition();\n      //     }, 100);\n      // }\n\n      // NEW: Show close button\n      if (this.closeBtn) {\n        this.closeBtn.style.display = 'block';\n      }\n      this.createSubmitButton();\n    }\n\n    // NEW: Align the vertical center of ALL solids to saved Y (per-tab) or baseline\n  }, {\n    key: \"alignAllSolidsToBaselineOrSaved\",\n    value: function alignAllSolidsToBaselineOrSaved() {\n      var _this$solidMeshes,\n        _this4 = this;\n      if (!((_this$solidMeshes = this.solidMeshes) !== null && _this$solidMeshes !== void 0 && _this$solidMeshes.length)) return;\n      var baselineY = typeof this.globalBaselineCenterY === 'number' ? this.globalBaselineCenterY : 0;\n      var getTabId = function getTabId(mesh) {\n        var _mesh$userData;\n        var cat = (_mesh$userData = mesh.userData) === null || _mesh$userData === void 0 || (_mesh$userData = _mesh$userData.solution) === null || _mesh$userData === void 0 ? void 0 : _mesh$userData.actual_category;\n        return typeof cat === 'string' ? cat.toLowerCase() : null;\n      };\n      var getSavedYForTab = function getSavedYForTab(tabId, mesh) {\n        return _this4.savedYByTab.get(\"\".concat(tabId, \"_\").concat(mesh.uuid));\n      };\n      var _iterator3 = _createForOfIteratorHelper(this.solidMeshes),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var m = _step3.value;\n          var tabId = getTabId(m);\n          if (!tabId || !['low', 'mid', 'high', 'rhythmic'].includes(tabId)) continue;\n          var savedCenterY = getSavedYForTab(tabId, m);\n          var finalCenterY = typeof savedCenterY === 'number' ? savedCenterY : baselineY;\n          m.updateMatrixWorld(true);\n          var b0 = new three__WEBPACK_IMPORTED_MODULE_1__.Box3().setFromObject(m);\n          var c0 = b0.getCenter(new three__WEBPACK_IMPORTED_MODULE_1__.Vector3());\n\n          // Move so center == finalCenterY\n          var dy = finalCenterY - c0.y;\n          if (Math.abs(dy) > 0) {\n            m.position.y += dy;\n            m.updateMatrixWorld(true);\n\n            // snap-correct residue\n            var b1 = new three__WEBPACK_IMPORTED_MODULE_1__.Box3().setFromObject(m);\n            var c1 = b1.getCenter(new three__WEBPACK_IMPORTED_MODULE_1__.Vector3());\n            var err = finalCenterY - c1.y;\n            if (Math.abs(err) > 1e-3) {\n              m.position.y += err;\n              m.updateMatrixWorld(true);\n            }\n\n            // Cache offsets for grain ‚Äútop‚Äù and clamp baseline\n            var sizeAfter = b1.getSize(new three__WEBPACK_IMPORTED_MODULE_1__.Vector3());\n            m.userData.centerOffsetY = c1.y - m.position.y;\n            m.userData.grainClearance = sizeAfter.y * 0.5 + 4.0;\n            m.userData.evolvingBaseY = baselineY;\n\n            // Keep peak Y unchanged; just update manualHeight mapping\n            var peakIndex = this.particleSystem.peakSolids.indexOf(m);\n            if (peakIndex !== -1) {\n              var peak = this.particleSystem.peaks[peakIndex];\n              if (peak) {\n                // DON'T unlock - keep evolvingLock = true\n                // peak.evolvingLock = false;  // <-- REMOVE THIS LINE\n                peak.manualHeight = this.calculateSmoothedHeightFromY(finalCenterY);\n              }\n            }\n          } else {\n            // Even if already aligned, ensure clamp is set\n            m.userData.evolvingBaseY = baselineY;\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    }\n  }, {\n    key: \"exitEvolvingMode\",\n    value: function exitEvolvingMode() {\n      var _this$particleSystem3, _this$particleSystem4;\n      if (!this.isEvolvingMode) return;\n      console.log('üö™ Exiting evolving mode');\n      this.isEvolvingMode = false;\n\n      // CRITICAL: Stop ALL audio FIRST\n      try {\n        var _this$particleSystem2;\n        (_this$particleSystem2 = this.particleSystem) === null || _this$particleSystem2 === void 0 || (_this$particleSystem2 = _this$particleSystem2.surroundController) === null || _this$particleSystem2 === void 0 || _this$particleSystem2.stopAllManualPlayback();\n      } catch (e) {\n        console.error('Failed to stop audio on evolve exit:', e);\n      }\n\n      // NEW: Change button text back and remove selected state\n      this.evolveBtn.setSelected(false);\n      if (this.controls) this.controls.enabled = true;\n      if (this.tabsContainer) this.tabsContainer.style.display = 'none';\n      if ((_this$particleSystem3 = this.particleSystem) !== null && _this$particleSystem3 !== void 0 && _this$particleSystem3.stopEvolvingAlignment) this.particleSystem.stopEvolvingAlignment();\n      if ((_this$particleSystem4 = this.particleSystem) !== null && _this$particleSystem4 !== void 0 && _this$particleSystem4.clearCategoryVisibility) this.particleSystem.clearCategoryVisibility();\n      this.restoreOriginalLayout();\n      this.solidMeshes.forEach(function (m) {\n        delete m.userData.evolvingManualY;\n      });\n      if (this.submitButton) {\n        this.submitButton.remove();\n        this.submitButton = null;\n      }\n\n      // NEW: Hide reference scale\n      if (this.scaleContainer) {\n        this.scaleContainer.style.display = 'none';\n      }\n\n      // NEW: Hide close button\n      if (this.closeBtn) {\n        this.closeBtn.style.display = 'none';\n      }\n      this.hideNoSolutionsMessage();\n    }\n  }, {\n    key: \"storeOriginalPositions\",\n    value: function storeOriginalPositions() {\n      var _this5 = this;\n      // Store original camera position\n      this.originalCameraPosition.copy(this.mainCamera.position);\n      if (this.controls && this.controls.target) {\n        this.originalCameraTarget.copy(this.controls.target);\n      }\n\n      // Store original solid positions\n      this.originalSolidPositions.clear();\n      this.solidMeshes.forEach(function (m) {\n        _this5.originalSolidPositions.set(m.uuid, {\n          position: m.position.clone(),\n          rotation: m.rotation.clone(),\n          scale: m.scale.clone()\n        });\n      });\n    }\n\n    // Robust center getter\n  }, {\n    key: \"getMeshCenterY\",\n    value: function getMeshCenterY(mesh) {\n      mesh.updateMatrixWorld(true);\n      var b = new three__WEBPACK_IMPORTED_MODULE_1__.Box3().setFromObject(mesh);\n      var c = b.getCenter(new three__WEBPACK_IMPORTED_MODULE_1__.Vector3());\n      return c.y;\n    }\n\n    // Align along Z and vertically align to baseline or saved per-tab Y\n  }, {\n    key: \"transitionToEvolvingLayout\",\n    value: function transitionToEvolvingLayout() {\n      var _this6 = this,\n        _this$fixedCameraTarg7,\n        _this$fixedCameraTarg8,\n        _this$particleSystem5;\n      var filtered = this.getSolidsByTab(this.activeTab);\n\n      // Only show solids in the active tab\n      this.solidMeshes.forEach(function (m) {\n        m.visible = filtered.includes(m);\n      });\n      if (this.particleSystem && typeof this.particleSystem.applyCategoryVisibilityBySolids === 'function') {\n        this.particleSystem.applyCategoryVisibilityBySolids(filtered, 300);\n      }\n\n      // NEW: Handle empty tabs\n      if (filtered.length === 0) {\n        var _this$fixedCameraTarg5, _this$fixedCameraTarg6;\n        // Still animate camera to the fixed position\n        var _targetPos = (_this$fixedCameraTarg5 = this.fixedCameraTargetPos) !== null && _this$fixedCameraTarg5 !== void 0 ? _this$fixedCameraTarg5 : new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(70, 10, 0);\n        var _targetLook = (_this$fixedCameraTarg6 = this.fixedCameraTargetLook) !== null && _this$fixedCameraTarg6 !== void 0 ? _this$fixedCameraTarg6 : new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, 0, 0);\n        console.log(\"[Evolve] Tab=\".concat(this.activeTab, \" is empty, moving camera to fixed position\"));\n        this.animateCamera(_targetPos, _targetLook, 800, function () {\n          // CHANGED: Hide scale when empty\n          if (_this6.scaleContainer) {\n            _this6.scaleContainer.style.display = 'none';\n          }\n        });\n\n        // Show \"no solutions\" message\n        this.showNoSolutionsMessage(this.activeTab);\n        return;\n      }\n\n      // Hide message if there are solutions\n      this.hideNoSolutionsMessage();\n\n      // Camera: fixed for this session\n      var layout = this.computeLayoutMetricsForSolids(filtered);\n      var targetPos = (_this$fixedCameraTarg7 = this.fixedCameraTargetPos) !== null && _this$fixedCameraTarg7 !== void 0 ? _this$fixedCameraTarg7 : layout.targetPos;\n      var targetLook = (_this$fixedCameraTarg8 = this.fixedCameraTargetLook) !== null && _this$fixedCameraTarg8 !== void 0 ? _this$fixedCameraTarg8 : layout.targetLook;\n      console.log(\"[Evolve] Tab=\".concat(this.activeTab, \" camera targetPos=\"), {\n        x: targetPos.x,\n        y: targetPos.y,\n        z: targetPos.z\n      }, 'targetLook=', {\n        x: targetLook.x,\n        y: targetLook.y,\n        z: targetLook.z\n      });\n      this.animateCamera(targetPos, targetLook, 800, function () {\n        // NEW: Update scale area and show scale AFTER camera finishes\n\n        // CHANGED: Show scale only after camera animation completes\n        if (_this6.scaleContainer) {\n          _this6.scaleContainer.style.display = 'flex';\n          _this6.updateReferenceScalePosition();\n        }\n        console.log(\"[Evolve] Tab=\".concat(_this6.activeTab, \" camera final=\"), {\n          pos: {\n            x: _this6.mainCamera.position.x,\n            y: _this6.mainCamera.position.y,\n            z: _this6.mainCamera.position.z\n          },\n          look: _this6.controls && _this6.controls.target ? {\n            x: _this6.controls.target.x,\n            y: _this6.controls.target.y,\n            z: _this6.controls.target.z\n          } : null\n        });\n      });\n      var baselineY = typeof this.globalBaselineCenterY === 'number' ? this.globalBaselineCenterY : 0;\n      var keyFor = function keyFor(mesh) {\n        return \"\".concat(_this6.activeTab, \"_\").concat(mesh.uuid);\n      };\n      var getSavedY = function getSavedY(mesh) {\n        return _this6.savedYByTab.get(keyFor(mesh));\n      };\n\n      // Vertical align pass with snap-correction\n      filtered.forEach(function (m) {\n        // desired center-Y: saved (if dragged in this tab), else baseline\n        var savedCenterY = getSavedY(m);\n        var finalCenterY = typeof savedCenterY === 'number' ? savedCenterY : baselineY;\n\n        // compute current center\n        m.updateMatrixWorld(true);\n        var b0 = new three__WEBPACK_IMPORTED_MODULE_1__.Box3().setFromObject(m);\n        var c0 = b0.getCenter(new three__WEBPACK_IMPORTED_MODULE_1__.Vector3());\n\n        // move so center == finalCenterY\n        var dy = finalCenterY - c0.y;\n        m.position.y += dy;\n        m.updateMatrixWorld(true);\n\n        // snap-correct any tiny residue due to parenting/rounding\n        var b1 = new three__WEBPACK_IMPORTED_MODULE_1__.Box3().setFromObject(m);\n        var c1 = b1.getCenter(new three__WEBPACK_IMPORTED_MODULE_1__.Vector3());\n        var err = finalCenterY - c1.y;\n        if (Math.abs(err) > 1e-3) {\n          m.position.y += err;\n          m.updateMatrixWorld(true);\n        }\n\n        // Clamp baseline for dragging\n        m.userData.evolvingBaseY = baselineY;\n\n        // Cache offsets so ParticleSystem can compute \"topY\" under the solid (no overlap)\n        var sizeAfter = b1.getSize(new three__WEBPACK_IMPORTED_MODULE_1__.Vector3());\n        m.userData.centerOffsetY = c1.y - m.position.y; // centerY = pos.y + centerOffsetY\n        m.userData.grainClearance = sizeAfter.y * 0.5 + 4.0; // half-height + margin\n\n        // Peak: keep Y unchanged; grains use manualHeight mapping only\n        var peakIndex = _this6.particleSystem.peakSolids.indexOf(m);\n        if (peakIndex !== -1) {\n          var peak = _this6.particleSystem.peaks[peakIndex];\n          if (peak) {\n            peak.evolvingLock = false;\n            peak.manualHeight = _this6.calculateSmoothedHeightFromY(finalCenterY);\n          }\n        }\n      });\n\n      // Arrange peaks along Z only (keep existing Y)\n      var targets = [];\n      filtered.forEach(function (mesh, i) {\n        var targetZ = filtered.length === 1 ? 0 : -layout.totalDepth / 2 + i * layout.spacing;\n        mesh.userData.evolvingIndex = i;\n        var peakIndex = _this6.particleSystem.peakSolids.indexOf(mesh);\n        if (peakIndex !== -1) {\n          var _this6$particleSystem, _this6$particleSystem2;\n          var keepY = (_this6$particleSystem = (_this6$particleSystem2 = _this6.particleSystem.peaks[peakIndex]) === null || _this6$particleSystem2 === void 0 ? void 0 : _this6$particleSystem2.currentPyramidCenter.y) !== null && _this6$particleSystem !== void 0 ? _this6$particleSystem : 0;\n          var targetCenter = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, keepY, targetZ);\n          targets.push({\n            solid: mesh,\n            target: targetCenter\n          });\n          var peak = _this6.particleSystem.peaks[peakIndex];\n          if (peak) delete peak.evolvingLock;\n        }\n      });\n      if (targets.length && (_this$particleSystem5 = this.particleSystem) !== null && _this$particleSystem5 !== void 0 && _this$particleSystem5.startEvolvingAlignmentInstant) {\n        this.particleSystem.startEvolvingAlignmentInstant(targets);\n      }\n\n      // mark this tab as aligned/visited\n      this.visitedTabs.add(this.activeTab);\n    }\n\n    // Animate camera \n  }, {\n    key: \"animateCamera\",\n    value: function animateCamera(targetPos, targetLook) {\n      var _this7 = this;\n      var duration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 800;\n      var onComplete = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n      var startPos = this.mainCamera.position.clone();\n      var startLook = this.controls && this.controls.target ? this.controls.target.clone() : new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();\n      var start = performance.now();\n      var _step4 = function step(now) {\n        var t = Math.min(1, (now - start) / duration);\n        var e = t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;\n        _this7.mainCamera.position.lerpVectors(startPos, targetPos, e);\n        if (_this7.controls && _this7.controls.target) {\n          _this7.controls.target.lerpVectors(startLook, targetLook, e);\n          _this7.controls.update();\n        } else {\n          _this7.mainCamera.lookAt(targetLook);\n        }\n        if (t < 1) {\n          requestAnimationFrame(_step4);\n        } else if (typeof onComplete === 'function') {\n          onComplete();\n        }\n      };\n      requestAnimationFrame(_step4);\n    }\n  }, {\n    key: \"setupInteraction\",\n    value: function setupInteraction() {\n      var _this8 = this;\n      if (this._interactionSetupDone) return;\n      this._interactionSetupDone = true;\n      var canvas = this.mainRenderer.domElement;\n      var raycaster = new three__WEBPACK_IMPORTED_MODULE_1__.Raycaster();\n      var pointer = new three__WEBPACK_IMPORTED_MODULE_1__.Vector2();\n      var pickTopLevelMesh = function pickTopLevelMesh(event) {\n        var rect = canvas.getBoundingClientRect();\n        pointer.x = (event.clientX - rect.left) / rect.width * 2 - 1;\n        pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;\n        raycaster.setFromCamera(pointer, _this8.mainCamera);\n        var visible = _this8.solidMeshes.filter(function (m) {\n          return m.visible;\n        });\n        var hits = raycaster.intersectObjects(visible, true);\n        if (!hits.length) return null;\n        var obj = hits[0].object;\n        while (obj && !_this8.solidMeshes.includes(obj) && obj.parent) obj = obj.parent;\n        return _this8.solidMeshes.includes(obj) ? obj : null;\n      };\n      var onPointerDown = function onPointerDown(e) {\n        var _mesh$userData$soluti, _mesh$userData2;\n        if (!_this8.isEvolvingMode) return;\n        e.preventDefault();\n        e.stopPropagation();\n\n        // Stop anything that might still be playing (mirrors SaveMode)\n        try {\n          var _this8$particleSystem;\n          (_this8$particleSystem = _this8.particleSystem) === null || _this8$particleSystem === void 0 || (_this8$particleSystem = _this8$particleSystem.surroundController) === null || _this8$particleSystem === void 0 || _this8$particleSystem.stopAllManualPlayback();\n        } catch (err) {\n          console.error('Failed to stop audio before drag start:', err);\n        }\n        var mesh = pickTopLevelMesh(e);\n        if (!mesh || mesh.userData.evolvingIndex === undefined) return;\n        _this8.drag.active = true;\n        _this8.drag.mesh = mesh;\n        _this8.drag.startPointerY = e.clientY;\n        _this8.drag.startY = mesh.position.y;\n        var box = new three__WEBPACK_IMPORTED_MODULE_1__.Box3().setFromObject(mesh);\n        mesh.userData.dragStartCenterY = box.getCenter(new three__WEBPACK_IMPORTED_MODULE_1__.Vector3()).y;\n        if (mesh.userData.evolvingBaseY === undefined) {\n          mesh.userData.evolvingBaseY = _this8.globalBaselineCenterY;\n        }\n        _this8.drag.peakIndex = _this8.particleSystem.peakSolids.indexOf(mesh);\n        var id = (_mesh$userData$soluti = mesh === null || mesh === void 0 || (_mesh$userData2 = mesh.userData) === null || _mesh$userData2 === void 0 || (_mesh$userData2 = _mesh$userData2.solution) === null || _mesh$userData2 === void 0 ? void 0 : _mesh$userData2.id) !== null && _mesh$userData$soluti !== void 0 ? _mesh$userData$soluti : null;\n        _this8.drag.playingId = id;\n        if (id != null) {\n          try {\n            var _this8$particleSystem2;\n            (_this8$particleSystem2 = _this8.particleSystem) === null || _this8$particleSystem2 === void 0 || (_this8$particleSystem2 = _this8$particleSystem2.surroundController) === null || _this8$particleSystem2 === void 0 || _this8$particleSystem2.playLoopForMesh(id, mesh);\n          } catch (err) {\n            console.error('Failed to start loop during drag:', err);\n          }\n        }\n        canvas.style.cursor = 'grabbing';\n      };\n      var onPointerMove = function onPointerMove(e) {\n        var _this8$drag$mesh$user;\n        if (!_this8.drag.active || !_this8.drag.mesh) return;\n        var deltaPixels = _this8.drag.startPointerY - e.clientY;\n        var newY = _this8.drag.startY + deltaPixels * _this8.dragYScale;\n\n        // Clamp: cannot go below global baseline (only upwards)\n        var b = new three__WEBPACK_IMPORTED_MODULE_1__.Box3().setFromObject(_this8.drag.mesh);\n        var currentCenter = b.getCenter(new three__WEBPACK_IMPORTED_MODULE_1__.Vector3());\n        var centerOffset = currentCenter.y - _this8.drag.mesh.position.y;\n        var minCenterY = _this8.drag.mesh.userData.evolvingBaseY;\n        var maxCenterY = _this8.scoreArea.maxY;\n        var minPosY = minCenterY - centerOffset;\n        var maxPosY = maxCenterY - centerOffset;\n        newY = Math.max(minPosY, Math.min(maxPosY, newY));\n\n        // Move solid\n        _this8.drag.mesh.position.y = newY;\n        _this8.drag.mesh.userData.evolvingManualY = true;\n\n        // New center after move\n        var b2 = new three__WEBPACK_IMPORTED_MODULE_1__.Box3().setFromObject(_this8.drag.mesh);\n        var newCenter = b2.getCenter(new three__WEBPACK_IMPORTED_MODULE_1__.Vector3());\n        _this8.setSavedYForActiveTab(_this8.drag.mesh, newCenter.y);\n        var moved = Math.abs(((_this8$drag$mesh$user = _this8.drag.mesh.userData.dragStartCenterY) !== null && _this8$drag$mesh$user !== void 0 ? _this8$drag$mesh$user : newCenter.y) - newCenter.y) > 0.05;\n        if (moved) _this8.drag.mesh.userData.hasUserDragged = true;\n\n        // Update grains distribution mapping only (keep peak XZ locked)\n        if (Number.isInteger(_this8.drag.peakIndex) && _this8.drag.peakIndex >= 0) {\n          var peak = _this8.particleSystem.peaks[_this8.drag.peakIndex];\n          if (peak) {\n            // DON'T unlock the peak - keep evolvingLock = true\n            // peak.evolvingLock = false;  // <-- REMOVE THIS LINE\n            peak.manualHeight = _this8.smoothedHeightFromY(newCenter.y);\n          }\n        }\n        var idx = _this8.drag.mesh.userData.evolvingIndex;\n        var scoreKey = \"\".concat(_this8.activeTab, \"_\").concat(idx);\n        var score = _this8.calculateScoreFromY(newCenter.y);\n        _this8.allTabScores.set(scoreKey, score);\n        _this8.updateSubmitButton();\n        e.preventDefault();\n      };\n      var endDrag = function endDrag(e) {\n        if (!_this8.drag.active) return;\n        e && e.preventDefault();\n        if (_this8.drag.mesh) {\n          var _this8$drag$mesh$user2;\n          var box = new three__WEBPACK_IMPORTED_MODULE_1__.Box3().setFromObject(_this8.drag.mesh);\n          var currentCenterY = box.getCenter(new three__WEBPACK_IMPORTED_MODULE_1__.Vector3()).y;\n          var moved = Math.abs(((_this8$drag$mesh$user2 = _this8.drag.mesh.userData.dragStartCenterY) !== null && _this8$drag$mesh$user2 !== void 0 ? _this8$drag$mesh$user2 : currentCenterY) - currentCenterY) > 0.05;\n          if (moved) _this8.drag.mesh.userData.hasUserDragged = true;\n          delete _this8.drag.mesh.userData.dragStartCenterY;\n\n          // REMOVED: Stop audio on drag end - let it continue playing\n          // try {\n          //     this.particleSystem?.surroundController?.stopAllManualPlayback();\n          // } catch (err) {\n          //     console.error('Failed to stop audio after drag:', err);\n          // }\n        }\n        _this8.drag.active = false;\n        // Keep reference to playing mesh so we can highlight it\n        // this.drag.mesh = null;  // DON'T clear the mesh yet\n        _this8.drag.peakIndex = undefined;\n        canvas.style.cursor = '';\n      };\n      canvas.addEventListener('pointerdown', onPointerDown);\n      window.addEventListener('pointermove', onPointerMove);\n      window.addEventListener('pointerup', endDrag);\n      window.addEventListener('pointerleave', endDrag);\n\n      // Handle window resize\n      window.addEventListener('resize', function () {\n        if (_this8.isEvolvingMode) {\n          _this8.updateReferenceScalePosition();\n        }\n      });\n    }\n\n    // Persist per-tab center Y for a mesh\n  }, {\n    key: \"setSavedYForActiveTab\",\n    value: function setSavedYForActiveTab(mesh, centerY) {\n      var key = \"\".concat(this.activeTab, \"_\").concat(mesh.uuid);\n      this.savedYByTab.set(key, centerY);\n    }\n  }, {\n    key: \"getSavedYForActiveTab\",\n    value: function getSavedYForActiveTab(mesh) {\n      return this.savedYByTab.get(\"\".concat(this.activeTab, \"_\").concat(mesh.uuid));\n    }\n  }, {\n    key: \"updateSubmitButton\",\n    value: function updateSubmitButton() {\n      if (!this.submitButton) return;\n      var total = this.allTabScores.size;\n      if (total > 0) {\n        this.submitButton.classList.add('enabled');\n        this.submitButton.textContent = 'Generate new sounds'; // REMOVED: (${total})\n      } else {\n        this.submitButton.classList.remove('enabled');\n        this.submitButton.textContent = 'Generate New Sounds';\n      }\n    }\n  }, {\n    key: \"createSubmitButton\",\n    value: function createSubmitButton() {\n      var _this9 = this;\n      if (this.submitButton) return; // Prevent duplicates\n      var submitButton = document.createElement('button');\n      submitButton.textContent = 'Submit Scores'; // REMOVED: solution count\n      submitButton.className = 'evolving-submit-button';\n      submitButton.addEventListener('click', function () {\n        _this9.submitScores();\n      });\n      document.body.appendChild(submitButton);\n      this.submitButton = submitButton;\n      this.updateSubmitButton();\n    }\n    // Low-sensitivity score from Y:\n    // - baseline (globalBaselineCenterY) maps to 0\n    // - scoreArea.maxY maps to 1\n    // - uses sine easing for gentler mid-range slope\n    // - quantized to 0.05 steps to avoid jitter\n  }, {\n    key: \"calculateScoreFromY\",\n    value: function calculateScoreFromY(y) {\n      var minY = typeof this.globalBaselineCenterY === 'number' ? this.globalBaselineCenterY : this.scoreArea.minY;\n      var maxY = this.scoreArea.maxY;\n      var range = Math.max(1e-6, maxY - minY);\n      var n = Math.max(0, Math.min(1, (y - minY) / range));\n      var eased = 0.5 - 0.5 * Math.cos(Math.PI * n);\n\n      // Quantize to reduce sensitivity\n      var step = 0.05;\n      var quantized = Math.round(eased / step) * step;\n\n      // Final clamp \n      var score = Math.max(0, Math.min(1, this.scoreArea.minScore + quantized * (this.scoreArea.maxScore - this.scoreArea.minScore)));\n      return score;\n    }\n\n    // Build scores for a specific tab using current mesh center Y\n  }, {\n    key: \"collectScoresForTab\",\n    value: function collectScoresForTab(tabId) {\n      var _this10 = this;\n      var solids = this.getSolidsByTab(tabId);\n      return solids.map(function (m) {\n        var _m$userData$solution$, _m$userData2;\n        var y = _this10.getMeshCenterY(m);\n        var score = _this10.calculateScoreFromY(y);\n        var id = (_m$userData$solution$ = (_m$userData2 = m.userData) === null || _m$userData2 === void 0 || (_m$userData2 = _m$userData2.solution) === null || _m$userData2 === void 0 ? void 0 : _m$userData2.id) !== null && _m$userData$solution$ !== void 0 ? _m$userData$solution$ : m.uuid;\n        return {\n          id: id,\n          category: tabId,\n          score: score\n        };\n      });\n    }\n\n    // Gather scores for all tabs\n  }, {\n    key: \"collectAllTabScores\",\n    value: function collectAllTabScores() {\n      var _this11 = this;\n      var tabs = ['low', 'mid', 'high', 'rhythmic'];\n      var all = [];\n      tabs.forEach(function (tab) {\n        all = all.concat(_this11.collectScoresForTab(tab));\n      });\n      return all;\n    }\n\n    // Replace getGlobalIndexForMesh with a string-id version\n  }, {\n    key: \"getGlobalIndexForMesh\",\n    value: function getGlobalIndexForMesh(mesh) {\n      var _mesh$userData3;\n      var rawId = mesh === null || mesh === void 0 || (_mesh$userData3 = mesh.userData) === null || _mesh$userData3 === void 0 || (_mesh$userData3 = _mesh$userData3.solution) === null || _mesh$userData3 === void 0 ? void 0 : _mesh$userData3.id;\n      var id = rawId != null ? String(rawId) : null;\n      if (id && this.idToGlobalIndex.has(id)) return this.idToGlobalIndex.get(id);\n\n      // Fallback: search categorized lists that carry globalIndex\n      for (var _i2 = 0, _Object$keys = Object.keys(this.categoryMeshes); _i2 < _Object$keys.length; _i2++) {\n        var cat = _Object$keys[_i2];\n        var entry = this.categoryMeshes[cat].find(function (e) {\n          var _e$solution;\n          return String((_e$solution = e.solution) === null || _e$solution === void 0 ? void 0 : _e$solution.id) === id;\n        });\n        if (entry && Number.isInteger(entry.globalIndex)) return entry.globalIndex;\n      }\n      // Last resort: find in allSolutions by id\n      if (id) {\n        var idx = this.allSolutions.findIndex(function (s) {\n          return String(s === null || s === void 0 ? void 0 : s.id) === id;\n        });\n        if (idx >= 0) return idx;\n      }\n      return -1;\n    }\n\n    // Build feedback array (unopened tabs treated as baseline/unscored)\n    // Replace buildFeedbackArray() so only real drags count as scored\n  }, {\n    key: \"buildFeedbackArray\",\n    value: function buildFeedbackArray() {\n      var _this12 = this;\n      var tabs = ['low', 'mid', 'high', 'rhythmic'];\n      var feedback = [];\n      var baseline = typeof this.globalBaselineCenterY === 'number' ? this.globalBaselineCenterY : this.scoreArea.minY;\n      tabs.forEach(function (tabId) {\n        var solids = _this12.getSolidsByTab(tabId);\n        solids.forEach(function (mesh, localIndex) {\n          var _mesh$userData$soluti2, _mesh$userData4;\n          var solutionId = (_mesh$userData$soluti2 = (_mesh$userData4 = mesh.userData) === null || _mesh$userData4 === void 0 || (_mesh$userData4 = _mesh$userData4.solution) === null || _mesh$userData4 === void 0 ? void 0 : _mesh$userData4.id) !== null && _mesh$userData$soluti2 !== void 0 ? _mesh$userData$soluti2 : mesh.uuid;\n          var globalIndex = _this12.getGlobalIndexForMesh(mesh);\n          var key = \"\".concat(tabId, \"_\").concat(mesh.uuid);\n          var hasSaved = _this12.savedYByTab.has(key);\n          var yNow = _this12.getMeshCenterY(mesh);\n          var yForScore = hasSaved ? _this12.savedYByTab.get(key) : yNow;\n\n          // Only count as scored if the user actually dragged this item\n          var was_scored = mesh.userData.hasUserDragged === true;\n\n          // If scored, compute a gentle score from Y; otherwise 0\n          var user_score = was_scored ? _this12.calculateScoreFromY(yForScore) : 0.0;\n          feedback.push({\n            global_index: globalIndex,\n            local_index: localIndex,\n            solution_id: solutionId,\n            category: tabId,\n            was_scored: was_scored,\n            user_score: Number(user_score.toFixed(3))\n          });\n        });\n      });\n      return feedback;\n    }\n  }, {\n    key: \"submitScores\",\n    value: function submitScores() {\n      var _this$pythonCommunica, _this$pythonCommunica2, _this$pythonCommunica3, _this$allSolutions;\n      if (!((_this$pythonCommunica = this.pythonCommunication) !== null && _this$pythonCommunica !== void 0 && _this$pythonCommunica.sendUserFeedback)) return;\n      var generation = (_this$pythonCommunica2 = (_this$pythonCommunica3 = this.pythonCommunication).getCurrentGeneration) === null || _this$pythonCommunica2 === void 0 ? void 0 : _this$pythonCommunica2.call(_this$pythonCommunica3);\n      if (generation !== undefined) {\n        this.currentGeneration = generation;\n      }\n      if (this.submissionLocked && this.currentGeneration === this.lastSubmittedGeneration) {\n        this.showSubmissionMessage('Scores of this generation already submitted', true);\n        return;\n      }\n\n      // FIXED: Check if already submitting to prevent duplicate requests\n      if (this._isSubmitting) {\n        console.warn('‚ö†Ô∏è Submission already in progress, ignoring duplicate request');\n        return;\n      }\n\n      // FIXED: Set submitting flag instead of global transition flag\n      this._isSubmitting = true;\n      var payload = {\n        action: 'user_feedback',\n        type: 'user_scoring',\n        current_tab: this.activeTab,\n        total_solutions: ((_this$allSolutions = this.allSolutions) === null || _this$allSolutions === void 0 ? void 0 : _this$allSolutions.length) || 0,\n        actually_scored_solutions: _toConsumableArray(this.allTabScores.values()).filter(Boolean).length,\n        all_solutions_included: true,\n        feedback: this.buildFeedbackArray()\n      };\n      var ok = this.pythonCommunication.sendUserFeedback(payload);\n\n      // FIXED: Clear submitting flag immediately after send (not after timeout)\n      this._isSubmitting = false;\n      if (ok === false) {\n        this.showSubmissionMessage('Could not submit scores', true);\n        return;\n      }\n      this.submissionLocked = true;\n      this.lastSubmittedGeneration = this.currentGeneration;\n      this.showSubmissionMessage('Scores submitted successfully, wait for new sounds to generate!');\n      this.updateSubmitButton();\n    }\n  }, {\n    key: \"calculateSmoothedHeightFromY\",\n    value: function calculateSmoothedHeightFromY(y) {\n      var n = Math.max(0, Math.min(1, (y - this.scoreArea.minY) / (this.scoreArea.maxY - this.scoreArea.minY)));\n      return 2 + n * 10;\n    }\n  }, {\n    key: \"smoothedHeightFromY\",\n    value: function smoothedHeightFromY(screenY, screenH) {\n      var ndc = 1.0 - screenY / screenH * 2.0;\n      var t = (ndc + 1.0) / 2.0;\n      var smoothT = t * t * (3.0 - 2.0 * t);\n      return smoothT * (this.evolveLayoutTop - this.evolveLayoutBottom) + this.evolveLayoutBottom;\n    }\n  }, {\n    key: \"switchTab\",\n    value: function switchTab(tabId) {\n      if (this.activeTab === tabId) return;\n      console.log(\"\\uD83D\\uDD04 Switching tab from \".concat(this.activeTab, \" to \").concat(tabId));\n\n      // CRITICAL: Stop ALL audio (not just drag state)\n      try {\n        var _this$particleSystem6;\n        (_this$particleSystem6 = this.particleSystem) === null || _this$particleSystem6 === void 0 || (_this$particleSystem6 = _this$particleSystem6.surroundController) === null || _this$particleSystem6 === void 0 || _this$particleSystem6.stopAllManualPlayback();\n      } catch (e) {\n        console.error('Failed to stop audio on tab switch:', e);\n      }\n\n      // Clear drag state\n      if (this.drag) {\n        this.drag.playingId = null;\n        this.drag.active = false;\n        this.drag.mesh = null;\n      }\n      this.activeTab = tabId;\n      var tabButtons = this.tabsContainer.querySelectorAll('.evolve-tab-button');\n      tabButtons.forEach(function (btn) {\n        btn.classList.toggle('active', btn.dataset.value === tabId);\n      });\n      if (this.isEvolvingMode) {\n        this.solidMeshes.forEach(function (m) {\n          if (m.userData.animationId) {\n            cancelAnimationFrame(m.userData.animationId);\n            m.userData.animationId = null;\n          }\n        });\n\n        // NEW: Hide scale before transition\n        if (this.scaleContainer) {\n          this.scaleContainer.style.display = 'none';\n        }\n        this.transitionToEvolvingLayout();\n      }\n    }\n  }, {\n    key: \"loadSolutionsFromParticleSystem\",\n    value: function loadSolutionsFromParticleSystem() {\n      var _this13 = this;\n      console.log('Loading solutions from particle system...');\n      if (this.pythonCommunication && this.pythonCommunication.getCurrentSolutions) {\n        this.allSolutions = this.pythonCommunication.getCurrentSolutions();\n      } else {\n        this.allSolutions = this.particleSystem.currentSolutions || [];\n      }\n      this.solidMeshes = this.particleSystem.getSolids ? this.particleSystem.getSolids() : [];\n      this.numSolids = this.solidMeshes.length;\n      if (this.allSolutions.length === 0) {\n        console.warn('No solutions available from particle system');\n        return;\n      }\n\n      // Build id -> global index map\n      this.idToGlobalIndex.clear();\n      this.allSolutions.forEach(function (sol, idx) {\n        if ((sol === null || sol === void 0 ? void 0 : sol.id) != null) _this13.idToGlobalIndex.set(sol.id, idx);\n      });\n\n      // Clear existing category storage\n      Object.keys(this.categoryMeshes).forEach(function (category) {\n        _this13.categoryMeshes[category] = [];\n      });\n\n      // Categorize solutions\n      this.allSolutions.forEach(function (solution, globalIndex) {\n        var category = solution.actual_category;\n        if (typeof category === 'string') category = category.toLowerCase();\n        if (['low', 'mid', 'high', 'rhythmic'].includes(category)) {\n          _this13.categoryMeshes[category].push({\n            solution: solution,\n            globalIndex: globalIndex\n          });\n        }\n      });\n      console.log('Solutions categorized:', this.categoryMeshes);\n    }\n  }, {\n    key: \"restoreOriginalLayout\",\n    value: function restoreOriginalLayout() {\n      var _this14 = this;\n      this.animateCamera(this.originalCameraPosition.clone(), this.originalCameraTarget.clone(), 800);\n      this.solidMeshes.forEach(function (m) {\n        if (m.userData.animationId) {\n          cancelAnimationFrame(m.userData.animationId);\n          m.userData.animationId = null;\n        }\n        var orig = _this14.originalSolidPositions.get(m.uuid);\n        if (orig) {\n          m.position.copy(orig.position);\n          m.rotation.copy(orig.rotation);\n          m.scale.copy(orig.scale);\n        }\n        m.visible = true;\n        delete m.userData.evolvingIndex;\n        m.userData.isEvolvingFrozen = false;\n        delete m.userData.evolvingTargetPosition;\n        delete m.userData.evolvingAnimation;\n        delete m.userData.evolvingManualY;\n        delete m.userData.evolvingBaseY;\n      });\n    }\n  }, {\n    key: \"showNoSolutionsMessage\",\n    value: function showNoSolutionsMessage(category) {\n      // Remove existing message if any\n      this.hideNoSolutionsMessage();\n\n      // Create message overlay\n      this.noSolutionsMessage = document.createElement('div');\n      this.noSolutionsMessage.className = 'no-solutions-message';\n      this.noSolutionsMessage.innerHTML = \"\\n        <div class=\\\"no-solutions-content\\\">\\n            <p>No solutions in this category</p>\\n        </div>\\n    \";\n      document.body.appendChild(this.noSolutionsMessage);\n      console.log(\"[Evolve] Showing no solutions message for category: \".concat(category));\n    }\n  }, {\n    key: \"hideNoSolutionsMessage\",\n    value: function hideNoSolutionsMessage() {\n      if (this.noSolutionsMessage) {\n        this.noSolutionsMessage.remove();\n        this.noSolutionsMessage = null;\n      }\n    }\n\n    // In EvolvingUI.js, update handleEvolveCategoryClick (around line 250)\n  }, {\n    key: \"handleEvolveCategoryClick\",\n    value: function handleEvolveCategoryClick(categoryName, e) {\n      var _e$target;\n      e === null || e === void 0 || e.stopPropagation();\n      console.log(\"\\uD83E\\uDDEC User requested evolution for category: \".concat(categoryName));\n\n      // Visual feedback on button (optional)\n      var btn = e === null || e === void 0 || (_e$target = e.target) === null || _e$target === void 0 ? void 0 : _e$target.closest('.evolve-category-btn');\n      if (btn) {\n        btn.classList.add('evolving');\n        btn.textContent = 'Evolving...';\n        btn.disabled = true; // Prevent multiple clicks\n      }\n\n      // Request evolution (will trigger onEvolutionStart callback in main.js)\n      var success = this.pythonComm.requestEvolution(categoryName);\n      if (success) {\n        console.log(\"\\u2705 Evolution request sent for \".concat(categoryName));\n      } else {\n        console.error('‚ùå Failed to send evolution request');\n\n        // Reset button if request failed\n        if (btn) {\n          btn.classList.remove('evolving');\n          btn.textContent = \"Evolve \".concat(categoryName);\n          btn.disabled = false;\n        }\n      }\n\n      // Note: Button will be reset when new generation data arrives\n      // (EvolvingUI.transitionToEvolvingLayout will recreate the UI)\n    }\n  }, {\n    key: \"showSubmissionMessage\",\n    value: function showSubmissionMessage(message) {\n      var isError = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      // Remove any existing message\n      var existing = document.querySelector('.submission-message');\n      if (existing) existing.remove();\n\n      // Create message element using tutorial message styles\n      var messageEl = document.createElement('div');\n      messageEl.className = 'submission-message';\n      messageEl.textContent = message;\n\n      // Apply tutorial message overlay styles\n      messageEl.style.position = 'fixed';\n      messageEl.style.top = '80px';\n      messageEl.style.left = '50%';\n      messageEl.style.transform = 'translateX(-50%)';\n      messageEl.style.zIndex = '9000';\n      messageEl.style.fontFamily = \"'Space Grotesk', sans-serif\";\n      messageEl.style.fontSize = '1.1rem';\n      messageEl.style.fontWeight = '300';\n      messageEl.style.color = isError ? '#ff6b6b' : '#53d3c0'; // Red for error, green for success\n      messageEl.style.textAlign = 'center';\n      messageEl.style.letterSpacing = '0.05em';\n      messageEl.style.maxWidth = '800px';\n      messageEl.style.width = '90%';\n      messageEl.style.padding = '20px 40px';\n      messageEl.style.textShadow = isError ? '0 0 10px rgba(255, 107, 107, 0.3)' : '0 0 10px rgba(83, 211, 192, 0.3)';\n      messageEl.style.opacity = '0';\n      messageEl.style.pointerEvents = 'none';\n      messageEl.style.transition = 'opacity 0.5s ease';\n      document.body.appendChild(messageEl);\n\n      // Fade in\n      requestAnimationFrame(function () {\n        messageEl.style.opacity = '1';\n      });\n\n      // Auto-remove after 3 seconds\n      setTimeout(function () {\n        messageEl.style.opacity = '0';\n        setTimeout(function () {\n          if (messageEl.parentElement) {\n            messageEl.remove();\n          }\n        }, 500);\n      }, 2500);\n    }\n\n    // NEW: Create close button\n  }, {\n    key: \"createCloseButton\",\n    value: function createCloseButton() {\n      var _this15 = this;\n      this.closeBtn = document.createElement('button');\n      this.closeBtn.className = 'mode-close-btn evolve-mode-close';\n      this.closeBtn.innerHTML = '√ó';\n      this.closeBtn.title = 'Exit Evolve Mode';\n      this.closeBtn.style.display = 'none';\n      this.closeBtn.onclick = function () {\n        if (_this15.isEvolvingMode) {\n          _this15.exitEvolvingMode();\n          if (window.modeManager) {\n            window.modeManager.goTo(null); // FIXED: Use goTo instead of setMode\n          }\n        }\n      };\n      document.body.appendChild(this.closeBtn);\n    }\n  }]);\n}();\n\n//# sourceURL=webpack://sound-particle-visualization/./src/components/EvolvingUI.js?");

/***/ }),

/***/ "./src/components/GeometricSolid.js":
/*!******************************************!*\
  !*** ./src/components/GeometricSolid.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createGeometricSolid: () => (/* binding */ createGeometricSolid)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\nfunction _createForOfIteratorHelper(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\n\nfunction createGeometricSolid(solution, renderer, onMaterialReady) {\n  var _ref, _ref2, _ref3, _solution$actual_cate, _solution$descriptors;\n  var audioParams = solution.parameters;\n  var descriptors = solution.descriptors;\n  console.log(\"\\uD83C\\uDFA8 Creating solid for solution \".concat(solution.id, \" with real parameters:\"), audioParams);\n\n  // CHANGED: More dramatic base radius variation (was 1.5-6.0, now 1.2-7.5)\n  var baseRadius = three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.mapLinear(audioParams.room_size, 0.01, 0.4, 1.2, 7.5);\n  var geometry = new three__WEBPACK_IMPORTED_MODULE_0__.IcosahedronGeometry(2.5, 2);\n\n  // --- Vertex welding with INCREASED deformation ---\n  var pos = geometry.attributes.position;\n  var vertexMap = new Map();\n  for (var i = 0; i < pos.count; i++) {\n    var key = \"\".concat(pos.getX(i).toFixed(5), \",\").concat(pos.getY(i).toFixed(5), \",\").concat(pos.getZ(i).toFixed(5));\n    if (!vertexMap.has(key)) vertexMap.set(key, []);\n    vertexMap.get(key).push(i);\n  }\n  vertexMap.forEach(function (indices) {\n    var i = indices[0];\n    var x = pos.getX(i);\n    var y = pos.getY(i);\n    var z = pos.getZ(i);\n    var len = Math.sqrt(x * x + y * y + z * z);\n    var nx = x / len;\n    var ny = y / len;\n    var nz = z / len;\n    var pitchVarianceNormalized = (audioParams.pitch_variance + 0.05) / 0.1; // 0-1 range\n    var spectralFluxNormalized = Math.min(descriptors.spectral_flux / 1700, 1); // 0-1 range\n\n    // CHANGED: Much more dramatic deformation (was 2.5 and 1.4, now 5.0 and 3.5)\n    var deform = (Math.random() - 0.5) * pitchVarianceNormalized * 4.0 + (Math.random() - 0.5) * spectralFluxNormalized * 3.5;\n    var _iterator = _createForOfIteratorHelper(indices),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var idx = _step.value;\n        pos.setXYZ(idx, x + nx * deform, y + ny * deform, z + nz * deform);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  });\n  geometry.computeVertexNormals();\n\n  // --- Color calculation with DISTINCT category color families ---\n  var wetLevelNormalized = (audioParams.wet_level - 0.05) / 0.25; // 0-1 range\n  var overlapNormalized = Math.min((audioParams.overlap - 0.5) / 9.5, 1); // 0-1 range\n  var grainDurationNormalized = (audioParams.grain_duration - 0.1) / 0.9; // 0-1 range\n  var pitchVarianceNormalized = (audioParams.pitch_variance + 0.05) / 0.1; // 0-1 range\n\n  // FIXED: Try multiple possible category locations\n  var rawCategory = (_ref = (_ref2 = (_ref3 = (_solution$actual_cate = solution.actual_category) !== null && _solution$actual_cate !== void 0 ? _solution$actual_cate : solution.category) !== null && _ref3 !== void 0 ? _ref3 : solution.assigned_category) !== null && _ref2 !== void 0 ? _ref2 : (_solution$descriptors = solution.descriptors) === null || _solution$descriptors === void 0 ? void 0 : _solution$descriptors.category) !== null && _ref !== void 0 ? _ref : 'mid';\n  var category = typeof rawCategory === 'string' ? rawCategory.toLowerCase() : 'mid';\n\n  // ADDED: Debug logging to see what category we're actually getting\n  console.log(\"\\uD83C\\uDFA8 Solution \".concat(solution.id, \": category=\\\"\").concat(solution.category, \"\\\", assigned=\\\"\").concat(solution.assigned_category, \"\\\", using=\\\"\").concat(category, \"\\\"\"));\n  var hueBase, hueSpan, lightBase, lightSpan, satBase;\n  switch (category) {\n    case 'low':\n      hueBase = 0.60;\n      hueSpan = 0.02;\n      lightBase = 0.20;\n      lightSpan = 0.10;\n      satBase = 0.55;\n      break;\n    case 'mid':\n      hueBase = 0.77;\n      hueSpan = 0.02;\n      lightBase = 0.26;\n      lightSpan = 0.12;\n      satBase = 0.60;\n      break;\n    case 'high':\n      hueBase = 0.52;\n      hueSpan = 0.02;\n      lightBase = 0.42;\n      lightSpan = 0.12;\n      satBase = 0.70;\n      break;\n    case 'rhythmic':\n      hueBase = 0.40;\n      hueSpan = 0.015;\n      lightBase = 0.50;\n      lightSpan = 0.10;\n      satBase = 0.75;\n      break;\n    default:\n      hueBase = 0.77;\n      hueSpan = 0.02;\n      lightBase = 0.26;\n      lightSpan = 0.12;\n      satBase = 0.60;\n  }\n  var baseHue = hueBase + hueSpan * (1 - wetLevelNormalized) * 0.3;\n  var baseSaturation = Math.min(satBase + 0.15 * overlapNormalized, 0.9);\n  var baseLightness = lightBase + lightSpan * (grainDurationNormalized * 0.4 + pitchVarianceNormalized * 0.2);\n  var wireframeColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color().setHSL(baseHue, baseSaturation, baseLightness);\n  console.log(\"\\uD83C\\uDFA8 Color for \".concat(category, \": H=\").concat(baseHue.toFixed(2), \", S=\").concat(baseSaturation.toFixed(2), \", L=\").concat(baseLightness.toFixed(2)));\n  var material = new three__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial({\n    color: wireframeColor,\n    wireframe: true,\n    transparent: false,\n    opacity: 0.6 + 0.3 * grainDurationNormalized,\n    emissive: wireframeColor.clone().multiplyScalar(0.2),\n    emissiveIntensity: 0.2 + grainDurationNormalized * 0.7 + pitchVarianceNormalized * 0.3,\n    metalness: 0.6 + overlapNormalized * 0.3,\n    roughness: 0.2 + (1 - wetLevelNormalized) * 0.5,\n    flatShading: false,\n    fog: true,\n    side: three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide\n  });\n\n  // Stabilize color updates\n  var stableColor = wireframeColor.clone();\n  material.color = stableColor;\n\n  // Create mesh\n  var mesh = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(geometry, material);\n\n  // CHANGED: Much more dramatic Y-scale variation (was 1.0-1.5, now 0.8-2.5)\n  mesh.scale.y = 0.8 + grainDurationNormalized * 1.7;\n  mesh.layers.enable(1);\n\n  // **Store solution data with the mesh**\n  mesh.userData.solution = solution;\n  mesh.userData.solutionId = solution.id;\n  mesh.userData.audioParams = audioParams;\n  mesh.userData.descriptors = descriptors;\n  mesh.userData.fitness = solution.fitness;\n  mesh.userData.category = category;\n\n  // --- Orbiting clones with MORE variation ---\n  if (audioParams.num_voices > 1) {\n    var group = new three__WEBPACK_IMPORTED_MODULE_0__.Group();\n    group.add(mesh);\n    group.userData.solution = solution;\n    group.userData.solutionId = solution.id;\n    group.userData.audioParams = audioParams;\n    group.userData.descriptors = descriptors;\n    group.userData.fitness = solution.fitness;\n    group.userData.category = category;\n    group.userData.orbitClones = [];\n    // CHANGED: Reduced distance - balanced between too close and too far\n    // Add smaller base offset plus moderate scaling\n    group.userData.orbitBaseRadius = 5 + baseRadius * 2.2; // Was 8 + baseRadius * 3.5\n    group.userData.orbitSpeed = 0.15 + Math.random() * 0.15;\n    var maxClones = Math.min(Math.floor(audioParams.num_voices), 8);\n    for (var _i = 1; _i < maxClones; _i++) {\n      var clone = mesh.clone();\n      clone.position.y = Math.random() * 0.8;\n      var overlapForScale = Math.min((audioParams.overlap - 0.5) / 9.5, 1);\n      var cloneScale = 0.12 + overlapForScale * 0.23;\n      clone.scale.set(cloneScale, cloneScale, cloneScale);\n      clone.userData.orbitAngle = _i / maxClones * Math.PI * 2;\n      clone.userData.mass = cloneScale * cloneScale;\n      clone.userData.orbitalVelocity = 0.1 + (1 - cloneScale) * 0.1;\n      clone.userData.verticalOscillation = cloneScale * 0.3;\n      clone.material = material.clone();\n      clone.material.envMap = material.envMap;\n\n      // CHANGED: More dramatic saturation shift for clones\n      var hueShift = _i / maxClones * 0.01;\n      var saturationBoost = _i / maxClones * 0.10;\n      var lightnessBoost = _i / maxClones * 0.05;\n      clone.material.color.setHSL(baseHue + hueShift, Math.min(baseSaturation * 0.7 + saturationBoost, 0.95),\n      // More saturation range\n      Math.min(baseLightness + lightnessBoost, 0.6) // Brighter clones but capped\n      );\n      clone.material.emissive = clone.material.color.clone().multiplyScalar(0.15);\n      clone.layers.enable(1);\n      clone.material.emissiveIntensity = 0.25 + grainDurationNormalized * 0.25 + _i / maxClones * 0.2;\n      group.add(clone);\n      group.userData.orbitClones.push(clone);\n    }\n    group.userData.update = function (elapsed) {\n      mesh.rotation.y = elapsed * 0.2;\n      for (var _i2 = 0; _i2 < group.userData.orbitClones.length; _i2++) {\n        var _clone = group.userData.orbitClones[_i2];\n        var baseAngle = _clone.userData.orbitAngle + elapsed * group.userData.orbitSpeed;\n        var mass = _clone.userData.mass;\n        var orbitalVel = _clone.userData.orbitalVelocity;\n        var verticalOsc = _clone.userData.verticalOscillation;\n        var angle = baseAngle + Math.sin(elapsed * orbitalVel) * (1 - mass) * 0.3;\n        // CHANGED: Increased radius multiplier for more spacing\n        var radius = group.userData.orbitBaseRadius * (0.9 + mass * 0.5); // Was 0.8 + mass * 0.4\n\n        _clone.position.x = Math.cos(angle) * radius;\n        _clone.position.z = Math.sin(angle) * radius;\n        _clone.position.y = Math.sin(elapsed * 1.5 + _i2) * verticalOsc * 0.5;\n        _clone.rotation.z = -angle * (2 - mass);\n        _clone.rotation.y = elapsed * 0.3 * (2 - mass);\n      }\n    };\n    return group;\n  }\n  mesh.userData.update = function (elapsed) {\n    mesh.rotation.z = elapsed * 0.2;\n  };\n  return mesh;\n}\n\n//# sourceURL=webpack://sound-particle-visualization/./src/components/GeometricSolid.js?");

/***/ }),

/***/ "./src/components/Library.js":
/*!***********************************!*\
  !*** ./src/components/Library.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Library: () => (/* binding */ Library)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n/* harmony import */ var _Button_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Button.js */ \"./src/components/Button.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _createForOfIteratorHelper(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\nvar Library = /*#__PURE__*/function () {\n  function Library(particleSystem, scene, camera, renderer, controls) {\n    var _this = this,\n      _particleSystem$grain,\n      _particleSystem$baseR,\n      _particleSystem$grain2,\n      _particleSystem$defau;\n    _classCallCheck(this, Library);\n    this.particleSystem = particleSystem;\n    this.scene = scene;\n    this.camera = camera;\n    this.renderer = renderer;\n    this.controls = controls;\n\n    // Saved items here: { id, type: 'solution'|'combination', name, description, category, items?, meshSnapshot:Object3D }\n    this.libraryData = [];\n\n    // Space mode state\n    this.inSpace = false;\n    this.group = new three__WEBPACK_IMPORTED_MODULE_1__.Group();\n    this.group.name = 'LibraryGroup';\n    this.cols = 6; // default columns for grid\n    this.spacingX = 20; // horizontal spacing\n    this.spacingZ = 22; // depth spacing\n    this.baseY = 0; // center Y for all items\n    this.snapScale = 1.0; // global snapshot scale factor\n    this._camRestore = null;\n\n    // Picking\n    this._raycaster = new three__WEBPACK_IMPORTED_MODULE_1__.Raycaster();\n    this._pointer = new three__WEBPACK_IMPORTED_MODULE_1__.Vector2();\n    this._onPointerDown = this._handlePointerDown.bind(this);\n    this._onPointerMove = this._handlePointerMove.bind(this);\n    this._onPointerLeave = this._handlePointerLeave.bind(this);\n\n    // Info panel near selected mesh\n    this._panel = this._createInfoPanel();\n    this._lastPanelMesh = null;\n    this.selectedItem = null;\n\n    // Hover/selection state\n    this._hoveredContainer = null;\n    this._selectedContainer = null;\n    this._isEditingName = false;\n    this._isEditingDesc = false;\n\n    // NEW: Global material cache for library items (like SaveMode)\n    this._globalLibraryMaterialCache = new WeakMap();\n\n    // UI entry point\n    this.createLibraryButton();\n    this.createCloseButton(); // NEW: Add close button\n\n    window.addEventListener('resize', function () {\n      if (_this.inSpace) _this._positionInfoPanel();\n    });\n\n    // Library swarms (grains) runtime\n    this._libItems = []; // [{ container, solid, grains:[], params:{ baseRadius, baseY, topY } }]\n    this.libraryGrainsPerSolid = (_particleSystem$grain = particleSystem === null || particleSystem === void 0 ? void 0 : particleSystem.grainsPerVisiblePeak) !== null && _particleSystem$grain !== void 0 ? _particleSystem$grain : 300;\n    this.libraryBaseRadius = (_particleSystem$baseR = particleSystem === null || particleSystem === void 0 ? void 0 : particleSystem.baseRadius) !== null && _particleSystem$baseR !== void 0 ? _particleSystem$baseR : 2;\n    this.libraryGrainColumnHeight = (_particleSystem$grain2 = particleSystem === null || particleSystem === void 0 ? void 0 : particleSystem.grainColumnHeight) !== null && _particleSystem$grain2 !== void 0 ? _particleSystem$grain2 : 6.0;\n    this.libraryGrainClearance = (_particleSystem$defau = particleSystem === null || particleSystem === void 0 ? void 0 : particleSystem.defaultGrainClearance) !== null && _particleSystem$defau !== void 0 ? _particleSystem$defau : 1.0;\n\n    // Track hidden main-scene objects while in space\n    this._hiddenMainGrains = [];\n    this._hiddenMainSolids = [];\n    this._pointerOverPanel = false;\n    this._panelEditDepth = 0;\n    this.nameMaxLength = 60;\n    this.descriptionMaxLength = 200;\n    this.nameVerticalThreshold = 18;\n\n    // Track playing audio in library\n    this._playingIds = new Set();\n    this._playingMeshes = new Map(); // Map<id, mesh> for highlighting\n  }\n\n  // Public: toggle\n  return _createClass(Library, [{\n    key: \"toggleLibrarySpace\",\n    value: function toggleLibrarySpace() {\n      if (this.inSpace) this.exitSpace();else this.enterSpace();\n    }\n  }, {\n    key: \"enterSpace\",\n    value: function enterSpace() {\n      var _this2 = this;\n      if (this.inSpace || !this.scene || !this.camera || !this.renderer) return;\n      this.inSpace = true;\n\n      // Change button text and set selected state\n      this.libraryBtn.setSelected(true);\n      // Fade out main scene sounds and stop sequencing\n      try {\n        var _this$particleSystem;\n        (_this$particleSystem = this.particleSystem) === null || _this$particleSystem === void 0 || (_this$particleSystem = _this$particleSystem.surroundController) === null || _this$particleSystem === void 0 || _this$particleSystem.startMode(500);\n      } catch (_unused) {}\n\n      // Hide main solids\n      try {\n        var solids = this.particleSystem.getSolids ? this.particleSystem.getSolids() : [];\n        solids.forEach(function (m) {\n          _this2._hiddenMainSolids.push({\n            mesh: m,\n            prev: m.visible\n          });\n          m.visible = false;\n        });\n      } catch (e) {}\n\n      // Hide main grains\n      try {\n        var _this$particleSystem2;\n        if ((_this$particleSystem2 = this.particleSystem) !== null && _this$particleSystem2 !== void 0 && _this$particleSystem2.peaks) {\n          this.particleSystem.peaks.forEach(function (peak) {\n            if (!(peak !== null && peak !== void 0 && peak.grains)) return;\n            peak.grains.forEach(function (g) {\n              if (!g) return;\n              _this2._hiddenMainGrains.push({\n                grain: g,\n                prev: g.visible\n              });\n              g.visible = false;\n            });\n          });\n        }\n      } catch (e) {}\n\n      // Build grid content\n      if (!this.group.parent) this.scene.add(this.group);\n      this._buildGridFromLibraryData();\n      this._camRestore = {\n        pos: this.camera.position.clone(),\n        target: this.controls ? this.controls.target.clone() : new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, 0, 0)\n      };\n      this._animateCameraTopDown();\n\n      // Enable picking + hover\n      this.renderer.domElement.addEventListener('pointerdown', this._onPointerDown);\n      this.renderer.domElement.addEventListener('pointermove', this._onPointerMove);\n      this.renderer.domElement.addEventListener('mouseleave', this._onPointerLeave);\n\n      // Hide any existing panel until user picks\n      this._hideInfoPanel();\n      this._lastPanelMesh = null;\n      this.selectedItem = null;\n\n      // NEW: Show close button\n      if (this.closeBtn) {\n        this.closeBtn.style.display = 'block';\n      }\n    }\n  }, {\n    key: \"exitSpace\",\n    value: function exitSpace() {\n      if (!this.inSpace) return;\n      this.inSpace = false;\n\n      // Change button text back and remove selected state\n      this.libraryBtn.setSelected(false);\n\n      // Stop all playing library sounds before exiting\n      this._stopAllLibrarySounds();\n\n      // Resume main scene sequential soundscape\n      try {\n        var _this$particleSystem3;\n        (_this$particleSystem3 = this.particleSystem) === null || _this$particleSystem3 === void 0 || (_this$particleSystem3 = _this$particleSystem3.surroundController) === null || _this$particleSystem3 === void 0 || _this$particleSystem3.resumeMainMode(5);\n      } catch (_unused2) {}\n\n      // Remove library group\n      if (this.group.parent) this.scene.remove(this.group);\n\n      // Restore main solids visibility\n      try {\n        this._hiddenMainSolids.forEach(function (_ref) {\n          var mesh = _ref.mesh,\n            prev = _ref.prev;\n          if (mesh) mesh.visible = prev;\n        });\n        this._hiddenMainSolids = [];\n      } catch (e) {}\n\n      // Restore grains visibility\n      try {\n        this._hiddenMainGrains.forEach(function (_ref2) {\n          var grain = _ref2.grain,\n            prev = _ref2.prev;\n          if (grain) grain.visible = prev;\n        });\n        this._hiddenMainGrains = [];\n      } catch (e) {}\n\n      // Restore camera\n      if (this._camRestore) {\n        this._animateCameraTo(this._camRestore.pos, this._camRestore.target, 800);\n        this._camRestore = null;\n      }\n\n      // Disable picking/hover and panel\n      this.renderer.domElement.removeEventListener('pointerdown', this._onPointerDown);\n      this.renderer.domElement.removeEventListener('pointermove', this._onPointerMove);\n      this.renderer.domElement.removeEventListener('mouseleave', this._onPointerLeave);\n\n      // NEW: Hide close button\n      if (this.closeBtn) {\n        this.closeBtn.style.display = 'none';\n      }\n      this._clearHoverOutline();\n      this._clearSelectionOutline();\n      this._hideInfoPanel();\n      this._lastPanelMesh = null;\n      this.selectedItem = null;\n    }\n\n    // Call from your main animate loop\n  }, {\n    key: \"update\",\n    value: function update() {\n      if (!this.inSpace) return;\n      this._updateLibrarySolidsAnimation();\n      this._updateLibraryGrains();\n    }\n  }, {\n    key: \"addItem\",\n    value: function addItem(item) {\n      var _item$solutionData4;\n      // FIXED: Create unique ID that includes generation number to prevent collisions\n      var normalizedSolutionId = null;\n      if (item.type === 'solution') {\n        var _item$solutionData, _item$solutionData2;\n        var baseId = ((_item$solutionData = item.solutionData) === null || _item$solutionData === void 0 ? void 0 : _item$solutionData.id) || item.solutionId || item.id || (item.solid ? item.solid.uuid : null);\n        var generation = ((_item$solutionData2 = item.solutionData) === null || _item$solutionData2 === void 0 ? void 0 : _item$solutionData2.generation) || item.generation || 0;\n\n        // Create unique ID: \"gen_<generation>_sol_<id>\"\n        normalizedSolutionId = \"gen_\".concat(generation, \"_sol_\").concat(baseId);\n      }\n\n      // Extract category from multiple sources with priority\n      var categoryValue = '';\n      if (item.type === 'solution') {\n        var _item$solid, _item$solutionData3, _item$audioParams;\n        categoryValue = item.category || ((_item$solid = item.solid) === null || _item$solid === void 0 || (_item$solid = _item$solid.userData) === null || _item$solid === void 0 ? void 0 : _item$solid.category) || ((_item$solutionData3 = item.solutionData) === null || _item$solutionData3 === void 0 ? void 0 : _item$solutionData3.actual_category) || ((_item$audioParams = item.audioParams) === null || _item$audioParams === void 0 ? void 0 : _item$audioParams.category) || '';\n      } else if (item.type === 'combination') {\n        categoryValue = item.category || '';\n      }\n      var record = {\n        id: item.id || Date.now(),\n        type: item.type || 'solution',\n        name: item.name || '(unnamed)',\n        description: item.description || '',\n        category: categoryValue ? String(categoryValue).toLowerCase() : '',\n        items: Array.isArray(item.items) ? item.items : undefined,\n        meshSnapshot: null,\n        solutionId: normalizedSolutionId,\n        solutionData: item.solutionData || null,\n        generation: item.generation || ((_item$solutionData4 = item.solutionData) === null || _item$solutionData4 === void 0 ? void 0 : _item$solutionData4.generation) || 0 // ADDED: Store generation\n      };\n      var sourceMesh = null;\n      if (record.type === 'solution') {\n        sourceMesh = item.solid || null;\n      } else if (record.type === 'combination' && Array.isArray(item.items) && item.items.length) {\n        var pick = item.items[Math.floor(Math.random() * item.items.length)];\n        sourceMesh = (pick === null || pick === void 0 ? void 0 : pick.solid) || item.solid || null;\n      }\n      if (sourceMesh) {\n        var materialsSnapshot = item.materialsSnapshot || this._captureMaterialsFromSolid(sourceMesh);\n        record.meshSnapshot = this._cloneSolid(sourceMesh, materialsSnapshot);\n      }\n      this.libraryData.push(record);\n\n      // Live update grid if in space\n      if (this.inSpace) this._buildGridFromLibraryData();\n    }\n  }, {\n    key: \"findExistingItem\",\n    value: function findExistingItem(criteria) {\n      var _criteria$solutionDat;\n      if (!criteria) return null;\n\n      // FIXED: Search by unique solution ID (with generation)\n      if (criteria.solutionId !== undefined || ((_criteria$solutionDat = criteria.solutionData) === null || _criteria$solutionDat === void 0 ? void 0 : _criteria$solutionDat.id) !== undefined) {\n        var _criteria$solutionDat2, _criteria$solutionDat3, _ref3, _criteria$generation, _criteria$solutionDat4;\n        var baseId = (_criteria$solutionDat2 = (_criteria$solutionDat3 = criteria.solutionData) === null || _criteria$solutionDat3 === void 0 ? void 0 : _criteria$solutionDat3.id) !== null && _criteria$solutionDat2 !== void 0 ? _criteria$solutionDat2 : criteria.solutionId;\n        var generation = (_ref3 = (_criteria$generation = criteria.generation) !== null && _criteria$generation !== void 0 ? _criteria$generation : (_criteria$solutionDat4 = criteria.solutionData) === null || _criteria$solutionDat4 === void 0 ? void 0 : _criteria$solutionDat4.generation) !== null && _ref3 !== void 0 ? _ref3 : 0;\n        var uniqueId = \"gen_\".concat(generation, \"_sol_\").concat(baseId);\n        var found = this.libraryData.find(function (item) {\n          if (item.type === 'solution') {\n            var _item$solutionData5;\n            return item.solutionId === uniqueId || item.solutionId === baseId ||\n            // Fallback for old saves\n            ((_item$solutionData5 = item.solutionData) === null || _item$solutionData5 === void 0 ? void 0 : _item$solutionData5.id) === baseId;\n          }\n          return false;\n        });\n        if (found) return found;\n      }\n\n      // Search by combination items (compare all IDs with generation)\n      if (criteria.type === 'combination' && Array.isArray(criteria.items)) {\n        var searchIds = criteria.items.map(function (it) {\n          var _ref4, _it$solutionData$id, _it$solutionData, _ref5, _it$generation, _it$solutionData2;\n          var baseId = (_ref4 = (_it$solutionData$id = (_it$solutionData = it.solutionData) === null || _it$solutionData === void 0 ? void 0 : _it$solutionData.id) !== null && _it$solutionData$id !== void 0 ? _it$solutionData$id : it.solutionId) !== null && _ref4 !== void 0 ? _ref4 : it.id;\n          var gen = (_ref5 = (_it$generation = it.generation) !== null && _it$generation !== void 0 ? _it$generation : (_it$solutionData2 = it.solutionData) === null || _it$solutionData2 === void 0 ? void 0 : _it$solutionData2.generation) !== null && _ref5 !== void 0 ? _ref5 : 0;\n          return \"gen_\".concat(gen, \"_sol_\").concat(baseId);\n        }).filter(Boolean).sort();\n        var _found = this.libraryData.find(function (item) {\n          if (item.type !== 'combination' || !Array.isArray(item.items)) return false;\n          var itemIds = item.items.map(function (it) {\n            var _ref6, _it$solutionData$id2, _it$solutionData3, _ref7, _it$generation2, _it$solutionData4;\n            var baseId = (_ref6 = (_it$solutionData$id2 = (_it$solutionData3 = it.solutionData) === null || _it$solutionData3 === void 0 ? void 0 : _it$solutionData3.id) !== null && _it$solutionData$id2 !== void 0 ? _it$solutionData$id2 : it.solutionId) !== null && _ref6 !== void 0 ? _ref6 : it.id;\n            var gen = (_ref7 = (_it$generation2 = it.generation) !== null && _it$generation2 !== void 0 ? _it$generation2 : (_it$solutionData4 = it.solutionData) === null || _it$solutionData4 === void 0 ? void 0 : _it$solutionData4.generation) !== null && _ref7 !== void 0 ? _ref7 : 0;\n            return \"gen_\".concat(gen, \"_sol_\").concat(baseId);\n          }).filter(Boolean).sort();\n          if (itemIds.length !== searchIds.length) return false;\n          return searchIds.every(function (id, idx) {\n            return id === itemIds[idx];\n          });\n        });\n        if (_found) return _found;\n      }\n\n      // Search by name (fallback)\n      if (criteria.name) {\n        return this.libraryData.find(function (item) {\n          return item.name.toLowerCase() === criteria.name.toLowerCase();\n        });\n      }\n      return null;\n    }\n\n    // ============== grid building ==============\n  }, {\n    key: \"_buildGridFromLibraryData\",\n    value: function _buildGridFromLibraryData() {\n      var _this3 = this;\n      // Clear current group\n      while (this.group.children.length) this.group.remove(this.group.children[0]);\n      this._libItems = [];\n\n      // NEW: Clear material cache for fresh start\n      this._globalLibraryMaterialCache = new WeakMap();\n      var items = this.libraryData;\n      if (!items.length) return;\n      var cols = Math.max(2, Math.min(this.cols, Math.ceil(Math.sqrt(items.length))));\n      var spacingX = this.spacingX;\n      var spacingZ = this.spacingZ;\n      items.forEach(function (item, idx) {\n        var snap = item.meshSnapshot ? item.meshSnapshot.clone(true) : null;\n        if (!snap) return;\n        snap.traverse(function (ch) {\n          if (ch.isMesh) ch.matrixAutoUpdate = true;\n        });\n        snap.updateMatrixWorld(true);\n\n        // NEW: Cache original materials immediately after cloning\n        snap.traverse(function (child) {\n          if (child.isMesh && !_this3._globalLibraryMaterialCache.has(child)) {\n            _this3._globalLibraryMaterialCache.set(child, child.material);\n          }\n        });\n        var primary = _this3._findPrimaryMesh(snap) || snap;\n        primary.updateMatrixWorld(true);\n        var pBox = new three__WEBPACK_IMPORTED_MODULE_1__.Box3().setFromObject(primary);\n        var pSize = pBox.getSize(new three__WEBPACK_IMPORTED_MODULE_1__.Vector3());\n        var pCenter = pBox.getCenter(new three__WEBPACK_IMPORTED_MODULE_1__.Vector3());\n        var pBottom = pCenter.y - pSize.y * 0.5;\n\n        // Wrap into a container; center horizontally using PRIMARY center\n        var container = new three__WEBPACK_IMPORTED_MODULE_1__.Group();\n        container.name = \"LibraryItem_\".concat(item.id);\n        snap.position.x -= pCenter.x;\n        snap.position.z -= pCenter.z;\n\n        // Desired bottom of primary above grains\n        var baseY = _this3.baseY;\n        var topY = baseY + _this3.libraryGrainColumnHeight;\n        var desiredBottom = topY + _this3.libraryGrainClearance;\n        var deltaY = desiredBottom - pBottom;\n        snap.position.y += deltaY;\n\n        // Place container on the grid\n        var r = Math.floor(idx / cols);\n        var c = idx % cols;\n        container.position.set((c - (cols - 1) / 2) * spacingX, 0, r * spacingZ);\n\n        // Tag and add\n        container.userData.__libraryItem = item;\n        container.userData.__libraryIsSnapshot = true;\n        container.userData.__solidRoot = snap;\n        container.add(snap);\n        _this3.group.add(container);\n\n        // Build runtime for grains and animation\n        var runtime = {\n          container: container,\n          solid: snap,\n          primary: _this3._findPrimaryMesh(snap),\n          orbitClones: [],\n          grains: [],\n          params: {\n            baseY: baseY,\n            topY: topY,\n            baseRadius: _this3.libraryBaseRadius\n          }\n        };\n        if (runtime.primary) {\n          var primaryPos = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();\n          runtime.primary.getWorldPosition(primaryPos);\n          snap.traverse(function (n) {\n            if (n.isMesh && n !== runtime.primary && n.userData && n.userData.orbitAngle !== undefined) {\n              var clonePos = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();\n              n.getWorldPosition(clonePos);\n              var radius = Math.hypot(clonePos.x - primaryPos.x, clonePos.z - primaryPos.z);\n              n.userData._libOrbitRadius = radius;\n              n.userData._libHeightOffset = n.position.y - runtime.primary.position.y;\n              runtime.orbitClones.push(n);\n            }\n          });\n        }\n\n        // Rebind/update animation functions for this clone tree\n        _this3._retargetUpdateFunctionsForClone(runtime);\n\n        // Create grains centered exactly under container\n        _this3._createLibraryGrainsForItem(runtime);\n        _this3._libItems.push(runtime);\n      });\n      this.group.position.set(0, 0, -20);\n    }\n  }, {\n    key: \"_createLibraryGrainsForItem\",\n    value: function _createLibraryGrainsForItem(runtime) {\n      var container = runtime.container,\n        params = runtime.params;\n      var count = this.libraryGrainsPerSolid;\n      var minRadius = 0.8 * params.baseRadius;\n      var maxRadius = params.baseRadius * 2.5;\n      var sharedGeom = new three__WEBPACK_IMPORTED_MODULE_1__.SphereGeometry(0.09, 8, 8);\n      var makeMaterial = function makeMaterial() {\n        return new three__WEBPACK_IMPORTED_MODULE_1__.MeshStandardMaterial({\n          color: 0xe0dbc1,\n          emissive: 0xe0dbc1,\n          emissiveIntensity: 0.3,\n          transparent: true,\n          opacity: 0.8\n        });\n      };\n      for (var j = 0; j < count; j++) {\n        var mat = makeMaterial();\n        var grain = new three__WEBPACK_IMPORTED_MODULE_1__.Mesh(sharedGeom, mat);\n        grain.layers.enable(1);\n        var heightFactor = Math.random();\n        var angle = Math.random() * Math.PI * 2;\n        var randomization = [];\n        for (var r = 0; r < 4; r++) randomization.push(0.3 + 0.4 * Math.random());\n        var baseAccel = 0.08 + 0.10 * Math.random();\n        var baseSpeed = 0.025 + 0.050 * Math.random();\n        var maxSpeed = 0.05 + 0.18 * Math.random();\n        var baseRad = minRadius + (1 - heightFactor) * (maxRadius - minRadius);\n        var cx = container.position.x;\n        var cz = container.position.z;\n        grain.userData = {\n          heightFactor: heightFactor,\n          angle: angle,\n          randomization: randomization,\n          transitionSeed: Math.random() * 100,\n          baseAccel: baseAccel,\n          baseSpeed: baseSpeed,\n          maxSpeed: maxSpeed,\n          velocity: new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(),\n          acceleration: new three__WEBPACK_IMPORTED_MODULE_1__.Vector3()\n        };\n\n        // Initial placement within the column range\n        var initialY = params.baseY + heightFactor * (params.topY - params.baseY);\n        grain.position.set(cx + baseRad * Math.cos(angle), Math.max(0.1, initialY), cz + baseRad * Math.sin(angle));\n        this.group.add(grain);\n        runtime.grains.push(grain);\n      }\n    }\n  }, {\n    key: \"_updateLibraryGrains\",\n    value: function _updateLibraryGrains() {\n      var t = performance.now() * 0.001;\n      for (var k = 0; k < this._libItems.length; k++) {\n        var runtime = this._libItems[k];\n        var container = runtime.container,\n          solid = runtime.solid,\n          grains = runtime.grains,\n          params = runtime.params;\n        if (!container || !solid || !grains || !grains.length) continue;\n\n        // Recompute topY from solid's current transform to stay precise\n        var _this$_computeSolidGr = this._computeSolidGrainTopY(solid, params.baseY),\n          topY = _this$_computeSolidGr.topY;\n        params.topY = topY;\n        var cx = container.position.x;\n        var cz = container.position.z;\n        for (var j = 0; j < grains.length; j++) {\n          var grain = grains[j];\n          if (!grain || !grain.userData) continue;\n          var _grain$userData = grain.userData,\n            heightFactor = _grain$userData.heightFactor,\n            angle = _grain$userData.angle,\n            randomization = _grain$userData.randomization;\n          var minRadius = 0.8 * params.baseRadius;\n          var maxRadius = params.baseRadius * 2.5;\n          var baseRadius = minRadius + (1 - heightFactor) * (maxRadius - minRadius);\n          var wanderAngle = angle + Math.sin(t * (0.15 + 0.4 * randomization[0]) + j) * 2.5 + Math.cos(t * (0.2 + 0.3 * randomization[1]) + j * 0.5) * 1.8;\n          var wanderRadius = baseRadius + Math.sin(t * (0.12 + 0.2 * randomization[2]) + j * 0.3) * 0.4 + Math.cos(t * (0.1 + 0.25 * randomization[3]) + j * 0.25) * 0.5;\n          var range = Math.max(0.1, params.topY - params.baseY);\n          var noise = (Math.sin(t * (0.18 + 0.25 * randomization[1]) + j * 0.2) * 0.12 + Math.cos(t * (0.22 + 0.15 * randomization[2]) + j * 0.15) * 0.08) * range * 0.2;\n          var wanderHeight = params.baseY + heightFactor * range + noise;\n          if (wanderHeight > params.topY) wanderHeight = params.topY - 0.02;\n          if (wanderHeight < params.baseY) wanderHeight = params.baseY + 0.02;\n          var vagueTarget = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(cx + wanderRadius * Math.cos(wanderAngle), Math.max(0.1, wanderHeight), cz + wanderRadius * Math.sin(wanderAngle));\n          if (!grain.userData.velocity) grain.userData.velocity = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();\n          if (!grain.userData.acceleration) grain.userData.acceleration = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();\n          var toVague = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3().subVectors(vagueTarget, grain.position);\n          var springStrength = grain.userData.baseAccel * 0.12;\n          grain.userData.acceleration.copy(toVague).multiplyScalar(springStrength);\n          var fromCenter = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(grain.position.x - cx, 0, grain.position.z - cz);\n          var distFromCenter = fromCenter.length();\n          if (distFromCenter > 0.001) {\n            var up = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, 1, 0);\n            var orbitDir = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3().crossVectors(fromCenter, up).normalize();\n            var orbitSpeed = 0.4 + 0.08 * randomization[0];\n            var orbitPhase = t * orbitSpeed + grain.userData.transitionSeed;\n            var orbitAmount = 0.15 + 0.12 * Math.sin(orbitPhase + j * 0.2);\n            if (!grain.userData.orbitDeviation || t - (grain.userData.lastDeviationTime || 0) > 1.5 + Math.random() * 1.5) {\n              grain.userData.orbitDeviation = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3((Math.random() - 0.5) * 0.15, (Math.random() - 0.5) * 0.25, (Math.random() - 0.5) * 0.2);\n              grain.userData.lastDeviationTime = t;\n            }\n            orbitDir.add(grain.userData.orbitDeviation.clone().multiplyScalar(0.3)).normalize();\n            grain.userData.acceleration.add(orbitDir.multiplyScalar(orbitAmount));\n            grain.userData.acceleration.y += Math.sin(orbitPhase + j * 0.3) * 0.03;\n          }\n          grain.userData.velocity.add(grain.userData.acceleration);\n          grain.userData.velocity.multiplyScalar(0.88);\n          var maxSpeed = grain.userData.maxSpeed * 1.8;\n          if (grain.userData.velocity.length() > maxSpeed) {\n            grain.userData.velocity.setLength(maxSpeed);\n          }\n          grain.position.add(grain.userData.velocity);\n        }\n      }\n    }\n  }, {\n    key: \"_computeSolidGrainTopY\",\n    value: function _computeSolidGrainTopY(solid, baseY) {\n      // Use primary mesh bounds (ignore orbiting clones)\n      var primary = this._findPrimaryMesh(solid) || solid;\n      primary.updateMatrixWorld(true);\n      var bb = new three__WEBPACK_IMPORTED_MODULE_1__.Box3().setFromObject(primary);\n      var size = bb.getSize(new three__WEBPACK_IMPORTED_MODULE_1__.Vector3());\n      var center = bb.getCenter(new three__WEBPACK_IMPORTED_MODULE_1__.Vector3());\n      var clearance = size.y * 0.5 + this.libraryGrainClearance;\n      var centerOffsetY = center.y - solid.position.y;\n      var centerY = solid.position.y + centerOffsetY;\n      var topY = centerY - clearance;\n      return {\n        topY: Math.max(baseY + 0.25, topY)\n      };\n    }\n\n    // ============== Camera animation ==============\n  }, {\n    key: \"_animateCameraTopDown\",\n    value: function _animateCameraTopDown() {\n      var items = this.libraryData;\n      var cols = Math.max(2, Math.min(this.cols, Math.ceil(Math.sqrt(items.length || 1))));\n      var rows = Math.max(1, Math.ceil(items.length / cols));\n      var gridWidth = (cols - 1) * this.spacingX;\n      var gridDepth = Math.max(1, rows - 1) * this.spacingZ;\n\n      // Center of the grid\n      var center = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, 0, (rows - 1) * this.spacingZ * 0.5 - 20);\n      var distance = Math.max(30, Math.max(gridWidth, gridDepth)) * 2.0;\n      var height = distance * 1.2;\n      var xOff = 0;\n      var zOff = distance;\n      var pos = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(center.x + xOff, height, center.z + zOff);\n\n      // Look at the center of the grid\n      this._animateCameraTo(pos, center, 800);\n    }\n  }, {\n    key: \"_animateCameraTo\",\n    value: function _animateCameraTo(pos, lookAt) {\n      var _this4 = this;\n      var duration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 800;\n      var startPos = this.camera.position.clone();\n      var startTarget = this.controls ? this.controls.target.clone() : new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();\n      var start = performance.now();\n      var _tick = function tick(now) {\n        var t = Math.min(1, (now - start) / duration);\n        var ease = 0.5 - 0.5 * Math.cos(Math.PI * t);\n        _this4.camera.position.lerpVectors(startPos, pos, ease);\n        if (_this4.controls) {\n          var tgt = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3().lerpVectors(startTarget, lookAt, ease);\n          _this4.controls.target.copy(tgt);\n          _this4.controls.update();\n        } else {\n          _this4.camera.lookAt(lookAt);\n        }\n        if (t < 1) requestAnimationFrame(_tick);\n      };\n      requestAnimationFrame(_tick);\n    }\n  }, {\n    key: \"_animateCameraToItem\",\n    value: function _animateCameraToItem(container) {\n      if (!container) return;\n\n      // Get the world position and bounds of the selected item\n      var box = new three__WEBPACK_IMPORTED_MODULE_1__.Box3().setFromObject(container);\n      var center = box.getCenter(new three__WEBPACK_IMPORTED_MODULE_1__.Vector3());\n      var size = box.getSize(new three__WEBPACK_IMPORTED_MODULE_1__.Vector3());\n\n      // Calculate camera position to show item on LEFT side of screen\n      var maxDim = Math.max(size.x, size.y, size.z);\n      var distance = maxDim * 3.5;\n\n      // Position camera to show solid on left 40% of screen\n      var cameraPos = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(center.x + distance * 0.7,\n      // Offset right so object appears left\n      center.y + distance * 0.4,\n      // Elevated view\n      center.z + distance * 0.8 // Pull back\n      );\n\n      // Animate camera smoothly\n      this._animateCameraTo(cameraPos, center, 600);\n    }\n\n    // ============== UI ==============\n  }, {\n    key: \"createLibraryButton\",\n    value: function createLibraryButton() {\n      this.libraryBtn = new _Button_js__WEBPACK_IMPORTED_MODULE_0__.Button('LIBRARY', 'hamburger', function () {});\n    }\n\n    // NEW: Create close button\n  }, {\n    key: \"createCloseButton\",\n    value: function createCloseButton() {\n      var _this5 = this;\n      this.closeBtn = document.createElement('button');\n      this.closeBtn.className = 'mode-close-btn library-mode-close';\n      this.closeBtn.innerHTML = '√ó';\n      this.closeBtn.title = 'Exit Library';\n      this.closeBtn.style.display = 'none';\n      this.closeBtn.onclick = function (event) {\n        if (_this5.closeBtn.disabled) {\n          event.preventDefault();\n          event.stopPropagation();\n          return;\n        }\n        if (_this5.inSpace) {\n          _this5.exitSpace();\n          if (window.modeManager) {\n            window.modeManager.goTo(null);\n          }\n        }\n      };\n      document.body.appendChild(this.closeBtn);\n    }\n\n    // ============== Picking ==============\n  }, {\n    key: \"_handlePointerDown\",\n    value: function _handlePointerDown(e) {\n      if (!this.inSpace) return;\n      if (this._pointerOverPanel) {\n        return;\n      }\n      var panel = this._panel;\n      if (panel && panel.style.display !== 'none') {\n        var rect = panel.getBoundingClientRect();\n        if (e.clientX >= rect.left && e.clientX <= rect.right && e.clientY >= rect.top && e.clientY <= rect.bottom) {\n          return;\n        }\n      }\n      var viewport = this.renderer.domElement.getBoundingClientRect();\n      this._pointer.x = (e.clientX - viewport.left) / viewport.width * 2 - 1;\n      this._pointer.y = -((e.clientY - viewport.top) / viewport.height) * 2 + 1;\n      this._raycaster.setFromCamera(this._pointer, this.camera);\n      var hits = this._raycaster.intersectObjects(this.group.children, true);\n      if (!hits.length) {\n        this._clearSelectionOutline();\n        this._hideInfoPanel();\n        this._lastPanelMesh = null;\n        this.selectedItem = null;\n        this._animateCameraTopDown();\n        return;\n      }\n      var obj = hits[0].object;\n      while (obj && obj.parent && obj.parent !== this.group) obj = obj.parent;\n      if (!obj || !obj.userData || !obj.userData.__libraryItem) return;\n\n      // Toggle selection\n      if (this._selectedContainer === obj) {\n        this._clearSelectionOutline();\n        this._hideInfoPanel();\n        this._lastPanelMesh = null;\n        this.selectedItem = null;\n        this._animateCameraTopDown();\n        return;\n      }\n      this._applySelectionOutline(obj);\n      this._openInfoPanelFor(obj, obj.userData.__libraryItem);\n\n      // Animate camera to focus on selected item (left side of screen)\n      this._animateCameraToItem(obj);\n    }\n  }, {\n    key: \"_handlePointerMove\",\n    value: function _handlePointerMove(e) {\n      if (!this.inSpace) return;\n      var rect = this.renderer.domElement.getBoundingClientRect();\n      this._pointer.x = (e.clientX - rect.left) / rect.width * 2 - 1;\n      this._pointer.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;\n      this._raycaster.setFromCamera(this._pointer, this.camera);\n      var hits = this._raycaster.intersectObjects(this.group.children, true);\n      if (!hits.length) {\n        this._clearHoverOutline();\n        return;\n      }\n      var obj = hits[0].object;\n      while (obj && obj.parent && obj.parent !== this.group) obj = obj.parent;\n      if (!obj || !obj.userData || !obj.userData.__libraryItem) {\n        this._clearHoverOutline();\n        return;\n      }\n      if (this._selectedContainer === obj) {\n        this._clearHoverOutline();\n        return;\n      }\n      if (this._hoveredContainer !== obj) {\n        this._applyHoverOutline(obj);\n      }\n    }\n  }, {\n    key: \"_handlePointerLeave\",\n    value: function _handlePointerLeave() {\n      if (!this.inSpace) return;\n      this._clearHoverOutline();\n    }\n\n    // ============== Mesh + materials cloning ==============\n  }, {\n    key: \"_captureMaterialsFromSolid\",\n    value: function _captureMaterialsFromSolid(src) {\n      var map = Object.create(null);\n      src.traverse(function (node) {\n        var _node$userData, _node$userData2, _node$userData3;\n        if (!node.isMesh) return;\n        var base = ((_node$userData = node.userData) === null || _node$userData === void 0 ? void 0 : _node$userData.__saveModeBaseMaterial) || ((_node$userData2 = node.userData) === null || _node$userData2 === void 0 ? void 0 : _node$userData2.__saveModeMaterialOriginal) || ((_node$userData3 = node.userData) === null || _node$userData3 === void 0 ? void 0 : _node$userData3.originalMaterial) || node.material;\n        map[node.uuid] = Array.isArray(base) ? base.slice() : base;\n      });\n      return map;\n    }\n  }, {\n    key: \"_cloneMaterialDeep\",\n    value: function _cloneMaterialDeep(mat) {\n      var _this6 = this;\n      if (Array.isArray(mat)) return mat.map(function (m) {\n        return _this6._cloneMaterialDeep(m);\n      });\n      if (!mat) return mat;\n      if (mat.isShaderMaterial && three__WEBPACK_IMPORTED_MODULE_1__.UniformsUtils) {\n        var cloned = mat.clone();\n        cloned.uniforms = three__WEBPACK_IMPORTED_MODULE_1__.UniformsUtils.clone(mat.uniforms || {});\n        cloned.defines = mat.defines ? _objectSpread({}, mat.defines) : cloned.defines;\n        return cloned;\n      }\n      return mat.clone ? mat.clone() : new three__WEBPACK_IMPORTED_MODULE_1__.MeshStandardMaterial({\n        color: 0xffffff\n      });\n    }\n  }, {\n    key: \"_applyMaterialsToClone\",\n    value: function _applyMaterialsToClone(sourceRoot, cloneRoot, materialsSnapshot) {\n      var srcNodes = [];\n      var cloneNodes = [];\n      sourceRoot.traverse(function (n) {\n        return srcNodes.push(n);\n      });\n      cloneRoot.traverse(function (n) {\n        return cloneNodes.push(n);\n      });\n      for (var i = 0; i < srcNodes.length; i++) {\n        var s = srcNodes[i];\n        var c = cloneNodes[i];\n        if (s !== null && s !== void 0 && s.isMesh && c !== null && c !== void 0 && c.isMesh) {\n          var snap = materialsSnapshot === null || materialsSnapshot === void 0 ? void 0 : materialsSnapshot[s.uuid];\n          if (snap !== undefined) {\n            c.material = this._cloneMaterialDeep(snap);\n          } else {\n            var baseMat = s.userData && s.userData.originalMaterial ? s.userData.originalMaterial : s.material;\n            c.material = this._cloneMaterialDeep(baseMat);\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_cloneSolid\",\n    value: function _cloneSolid(src, materialsSnapshot) {\n      try {\n        var clone = src.clone(true);\n        this._applyMaterialsToClone(src, clone, materialsSnapshot);\n        clone.traverse(function (n) {\n          if (n.isMesh) n.matrixAutoUpdate = true;\n        });\n        clone.updateMatrixWorld(true);\n        return clone;\n      } catch (e) {\n        console.warn('Failed to clone solid for library snapshot:', e);\n        return null;\n      }\n    }\n\n    // ============== Info panel ==============\n  }, {\n    key: \"_createInfoPanel\",\n    value: function _createInfoPanel() {\n      var existing = document.querySelector('.library-space-panel');\n      if (existing) {\n        this._attachPanelGuards(existing);\n        existing.style.display = 'none';\n        return existing;\n      }\n      var el = document.createElement('div');\n      el.className = 'library-space-panel';\n      this._attachPanelGuards(el);\n      document.body.appendChild(el);\n      return el;\n    }\n  }, {\n    key: \"_attachPanelGuards\",\n    value: function _attachPanelGuards(panel) {\n      var _this7 = this;\n      if (panel.__hasLibraryGuards) return;\n      panel.addEventListener('pointerenter', function () {\n        _this7._pointerOverPanel = true;\n      });\n      panel.addEventListener('pointerleave', function () {\n        _this7._pointerOverPanel = false;\n      });\n      panel.__hasLibraryGuards = true;\n    }\n  }, {\n    key: \"_renderPanelContents\",\n    value: function _renderPanelContents(item) {\n      var _this8 = this;\n      var isCombo = item.type === 'combination';\n      var categoryLabel = '';\n      if (isCombo) {\n        var cats = Array.isArray(item.items) ? item.items.map(function (it) {\n          var _it$solid, _it$solutionData5, _it$audioParams;\n          return it.category || ((_it$solid = it.solid) === null || _it$solid === void 0 || (_it$solid = _it$solid.userData) === null || _it$solid === void 0 ? void 0 : _it$solid.category) || ((_it$solutionData5 = it.solutionData) === null || _it$solutionData5 === void 0 ? void 0 : _it$solutionData5.actual_category) || ((_it$audioParams = it.audioParams) === null || _it$audioParams === void 0 ? void 0 : _it$audioParams.category) || '';\n        }).filter(Boolean) : [];\n        var pretty = this._uniqueCapCategories(cats);\n        categoryLabel = pretty.length ? pretty.join(' - ') : 'Combination';\n      } else {\n        var _item$solid2, _item$solutionData6, _item$audioParams2;\n        var cat = item.category || ((_item$solid2 = item.solid) === null || _item$solid2 === void 0 || (_item$solid2 = _item$solid2.userData) === null || _item$solid2 === void 0 ? void 0 : _item$solid2.category) || ((_item$solutionData6 = item.solutionData) === null || _item$solutionData6 === void 0 ? void 0 : _item$solutionData6.actual_category) || ((_item$audioParams2 = item.audioParams) === null || _item$audioParams2 === void 0 ? void 0 : _item$audioParams2.category) || '';\n        categoryLabel = cat ? this._capitalizeFirst(String(cat)) : '';\n      }\n      var name = this._sanitizeName(item.name);\n      var description = this._sanitizeDescription(item.description);\n      var descHTML = description ? \"<div class=\\\"library-description committed\\\" data-editable=\\\"description\\\">\".concat(this._escapeHTML(description), \"</div>\") : \"<div class=\\\"library-description committed library-desc-placeholder\\\" data-editable=\\\"description\\\">Insert description here</div>\";\n      this._panel.innerHTML = \"\\n            <button class=\\\"library-close-btn\\\" type=\\\"button\\\" title=\\\"Close\\\">\\xD7</button>\\n            <h3 class=\\\"library-name\\\" data-editable=\\\"name\\\" title=\\\"Click to edit name\\\">\\n                \".concat(this._escapeHTML(name), \"\\n            </h3>\\n            \").concat(categoryLabel ? \"<div class=\\\"library-category-label\\\">\".concat(this._escapeHTML(categoryLabel), \"</div>\") : '', \"\\n            \").concat(descHTML, \"\\n            <div class=\\\"library-info-actions\\\">\\n                <button class=\\\"library-info-btn-play\\\" type=\\\"button\\\" data-action=\\\"play\\\" title=\\\"Play\\\">\\n                    <img src=\\\"/assets/icons/Play.svg\\\" alt=\\\"Play\\\" class=\\\"library-btn-icon-play\\\">\\n                    <span>Play Sound</span>\\n                </button>\\n                <button class=\\\"library-info-btn secondary\\\" type=\\\"button\\\" data-action=\\\"export\\\" title=\\\"Export\\\">\\n                    <img src=\\\"/assets/icons/Export.svg\\\" alt=\\\"Export\\\" class=\\\"library-btn-icon\\\">\\n                    <span>Export Audio</span>\\n                </button>\\n            </div>\\n        \");\n\n      // Wire up interactions\n      var closeBtn = this._panel.querySelector('.library-close-btn');\n      var nameEl = this._panel.querySelector('[data-editable=\"name\"]');\n      var descEls = this._panel.querySelectorAll('[data-editable=\"description\"]');\n      var playBtn = this._panel.querySelector('[data-action=\"play\"]');\n      var exportBtn = this._panel.querySelector('.library-info-btn[data-action=\"export\"]');\n      if (closeBtn) {\n        closeBtn.onclick = function (e) {\n          e.stopPropagation();\n          _this8._clearSelectionOutline();\n          _this8._hideInfoPanel();\n          _this8._lastPanelMesh = null;\n          _this8.selectedItem = null;\n          _this8._animateCameraTopDown();\n        };\n      }\n      if (nameEl) {\n        nameEl.onclick = function (e) {\n          e.stopPropagation();\n          e.stopImmediatePropagation();\n          _this8._inlineEditName(nameEl, item);\n        };\n      }\n      descEls.forEach(function (descEl) {\n        descEl.onclick = function (e) {\n          e.stopPropagation();\n          e.stopImmediatePropagation();\n          _this8._inlineEditDescription(descEl, item);\n        };\n      });\n      if (playBtn) playBtn.onclick = function (e) {\n        e.stopPropagation();\n        _this8._handlePlay(item);\n      };\n      if (exportBtn) exportBtn.onclick = function (e) {\n        e.stopPropagation();\n        _this8._handleExport(item);\n      };\n    }\n  }, {\n    key: \"_openInfoPanelFor\",\n    value: function _openInfoPanelFor(mesh, item) {\n      var _this9 = this;\n      // FIXED: Stop any playing sounds when opening a different item\n      if (this.selectedItem && this.selectedItem !== item) {\n        this._stopAllLibrarySounds();\n      }\n      this._lastPanelMesh = mesh;\n      this.selectedItem = item;\n      this._renderPanelContents(item);\n      if (this.closeBtn) {\n        this.closeBtn.disabled = true;\n        this.closeBtn.setAttribute('aria-disabled', 'true');\n        this.closeBtn.classList.add('locked');\n      }\n\n      // Check if item is currently playing and update button state\n      var isPlaying = false;\n      if (item.type === 'combination' && Array.isArray(item.items)) {\n        var ids = item.items.map(function (it) {\n          var _it$solutionData$id3, _it$solutionData6;\n          return (_it$solutionData$id3 = (_it$solutionData6 = it.solutionData) === null || _it$solutionData6 === void 0 ? void 0 : _it$solutionData6.id) !== null && _it$solutionData$id3 !== void 0 ? _it$solutionData$id3 : it.id;\n        }).filter(Boolean);\n        isPlaying = ids.some(function (id) {\n          return _this9._playingIds.has(id);\n        });\n      } else {\n        var _ref8, _item$solutionId, _item$solutionData7;\n        var id = (_ref8 = (_item$solutionId = item === null || item === void 0 ? void 0 : item.solutionId) !== null && _item$solutionId !== void 0 ? _item$solutionId : item === null || item === void 0 || (_item$solutionData7 = item.solutionData) === null || _item$solutionData7 === void 0 ? void 0 : _item$solutionData7.id) !== null && _ref8 !== void 0 ? _ref8 : item === null || item === void 0 ? void 0 : item.id;\n        isPlaying = this._playingIds.has(id);\n      }\n\n      // Update button state after rendering\n      requestAnimationFrame(function () {\n        _this9._updatePlayButtonState(isPlaying);\n      });\n      this._panel.style.display = 'block';\n      this._panel.offsetHeight;\n      this._panel.classList.add('visible');\n    }\n  }, {\n    key: \"_hideInfoPanel\",\n    value: function _hideInfoPanel() {\n      var _this10 = this;\n      // FIXED: Stop all playing sounds when panel is closed\n      this._stopAllLibrarySounds();\n      if (this._panel) {\n        this._panel.classList.remove('visible');\n        this._panelEditDepth = 0;\n        this._panel.classList.remove('editing-active');\n        this._pointerOverPanel = false;\n        setTimeout(function () {\n          if (!_this10._panel.classList.contains('visible')) {\n            _this10._panel.style.display = 'none';\n            if (_this10.closeBtn) {\n              _this10.closeBtn.disabled = false;\n              _this10.closeBtn.removeAttribute('aria-disabled');\n              _this10.closeBtn.classList.remove('locked');\n            }\n          }\n        }, 400);\n      }\n    }\n\n    // ============== UI editing ==============\n  }, {\n    key: \"_escapeHTML\",\n    value: function _escapeHTML(str) {\n      return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');\n    }\n  }, {\n    key: \"_inlineEditName\",\n    value: function _inlineEditName(container, item) {\n      var _this11 = this;\n      if (this._isEditingName) return;\n      this._isEditingName = true;\n      this._beginPanelEdit();\n      var current = this._sanitizeName(item.name);\n      container.textContent = '';\n      container.classList.remove('library-name');\n      var input = document.createElement('input');\n      input.type = 'text';\n      input.value = current;\n      input.className = 'library-name library-name-edit';\n      input.maxLength = this.nameMaxLength;\n      input.addEventListener('input', function () {\n        if (input.value.length > _this11.nameMaxLength) {\n          input.value = input.value.slice(0, _this11.nameMaxLength);\n        }\n      });\n      container.appendChild(input);\n      input.focus();\n      input.select();\n      var closed = false;\n      var finalize = function finalize(commit) {\n        if (closed) return;\n        closed = true;\n        _this11._isEditingName = false;\n        _this11._endPanelEdit();\n        if (!container.isConnected) return;\n        var value = commit ? _this11._sanitizeName(input.value) : current;\n        if (commit) item.name = value;\n        _this11._applyNameLayout(container, value);\n      };\n      input.addEventListener('keydown', function (e) {\n        e.stopPropagation();\n        if (e.key === 'Enter') {\n          finalize(true);\n          input.blur();\n        } else if (e.key === 'Escape') {\n          finalize(false);\n          input.blur();\n        }\n      });\n      input.addEventListener('blur', function () {\n        setTimeout(function () {\n          return finalize(true);\n        }, 50);\n      });\n    }\n  }, {\n    key: \"_inlineEditDescription\",\n    value: function _inlineEditDescription(container, item) {\n      var _this12 = this;\n      if (this._isEditingDesc) return;\n      this._isEditingDesc = true;\n      this._beginPanelEdit();\n      var current = this._sanitizeDescription(item.description);\n      container.textContent = '';\n      var ta = document.createElement('textarea');\n      ta.value = current;\n      ta.className = 'library-description library-description-edit';\n      ta.maxLength = this.descriptionMaxLength;\n      ta.addEventListener('input', function () {\n        if (ta.value.length > _this12.descriptionMaxLength) {\n          var pos = ta.selectionStart;\n          ta.value = ta.value.slice(0, _this12.descriptionMaxLength);\n          ta.selectionStart = ta.selectionEnd = Math.min(pos, _this12.descriptionMaxLength);\n        }\n        autoSize();\n      });\n      container.appendChild(ta);\n      ta.focus();\n      var autoSize = function autoSize() {\n        ta.style.height = 'auto';\n        ta.style.height = \"\".concat(Math.min(window.innerHeight * 0.6, ta.scrollHeight), \"px\");\n      };\n      ta.addEventListener('input', autoSize);\n      autoSize();\n      var closed = false;\n      var finalize = function finalize(commit) {\n        if (closed) return;\n        closed = true;\n        _this12._isEditingDesc = false;\n        _this12._endPanelEdit();\n        if (!container.isConnected) return;\n        var value = commit ? _this12._sanitizeDescription(ta.value) : current;\n        if (commit) item.description = value;\n        if (value) {\n          container.classList.remove('library-desc-placeholder');\n          container.classList.add('library-description', 'committed');\n          container.textContent = value;\n        } else {\n          container.classList.add('library-description', 'committed', 'library-desc-placeholder');\n          container.textContent = 'Insert description here';\n        }\n      };\n      ta.addEventListener('keydown', function (e) {\n        e.stopPropagation();\n        if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'enter') {\n          finalize(true);\n          ta.blur();\n        } else if (e.key === 'Escape') {\n          finalize(false);\n          ta.blur();\n        }\n      });\n      ta.addEventListener('blur', function () {\n        setTimeout(function () {\n          return finalize(true);\n        }, 50);\n      });\n    }\n  }, {\n    key: \"_handlePlay\",\n    value: function _handlePlay(item) {\n      var _this$particleSystem4,\n        _this13 = this;\n      var sc = (_this$particleSystem4 = this.particleSystem) === null || _this$particleSystem4 === void 0 ? void 0 : _this$particleSystem4.surroundController;\n      if (!sc) return;\n      if (item.type === 'combination' && Array.isArray(item.items)) {\n        // FIXED: Extract base IDs (without generation prefix) for audio lookup\n        var ids = item.items.map(function (it) {\n          var _it$solutionData$id4, _it$solutionData7;\n          return (_it$solutionData$id4 = (_it$solutionData7 = it.solutionData) === null || _it$solutionData7 === void 0 ? void 0 : _it$solutionData7.id) !== null && _it$solutionData$id4 !== void 0 ? _it$solutionData$id4 : it.id;\n        }).filter(function (id) {\n          return id != null;\n        });\n\n        // Check if ANY sound in combination is playing\n        var isAnyPlaying = ids.some(function (id) {\n          return _this13._playingIds.has(id);\n        });\n        if (isAnyPlaying) {\n          // Stop all sounds in this combination\n          ids.forEach(function (id) {\n            if (_this13._playingIds.has(id)) {\n              _this13._stopLibrarySound(id);\n            }\n          });\n          this._updatePlayButtonState(false);\n        } else {\n          // FIXED: Check if sources actually exist before playing\n          var validIds = ids.filter(function (id) {\n            return sc.sources.has(id);\n          });\n          if (validIds.length === 0) {\n            console.warn('‚ö†Ô∏è No audio sources found for combination');\n            return;\n          }\n          validIds.forEach(function (id) {\n            _this13._playLibrarySound(id, item);\n          });\n          this._updatePlayButtonState(true);\n        }\n      } else {\n        var _item$solutionData$id, _item$solutionData8;\n        // FIXED: Extract base ID (without generation prefix) for audio lookup\n        var baseId = (_item$solutionData$id = item === null || item === void 0 || (_item$solutionData8 = item.solutionData) === null || _item$solutionData8 === void 0 ? void 0 : _item$solutionData8.id) !== null && _item$solutionData$id !== void 0 ? _item$solutionData$id : item === null || item === void 0 ? void 0 : item.id;\n        if (baseId == null) return;\n\n        // FIXED: Check if source exists before playing\n        if (!sc.sources.has(baseId)) {\n          console.warn(\"\\u26A0\\uFE0F No audio source found for solution \".concat(baseId));\n          return;\n        }\n\n        // Toggle playback using base ID\n        if (this._playingIds.has(baseId)) {\n          this._stopLibrarySound(baseId);\n          this._updatePlayButtonState(false);\n        } else {\n          this._playLibrarySound(baseId, item);\n          this._updatePlayButtonState(true);\n        }\n      }\n    }\n  }, {\n    key: \"_playLibrarySound\",\n    value: function _playLibrarySound(id, item) {\n      var _this$particleSystem5,\n        _this$_selectedContai,\n        _this14 = this;\n      var sc = (_this$particleSystem5 = this.particleSystem) === null || _this$particleSystem5 === void 0 ? void 0 : _this$particleSystem5.surroundController;\n      if (!sc) return;\n      var mesh = ((_this$_selectedContai = this._selectedContainer) === null || _this$_selectedContai === void 0 || (_this$_selectedContai = _this$_selectedContai.userData) === null || _this$_selectedContai === void 0 ? void 0 : _this$_selectedContai.__solidRoot) || this._lastPanelMesh;\n      this._playingIds.add(id);\n      this._playingMeshes.set(id, mesh);\n      sc.playOneShot(id, {\n        highlightMesh: mesh,\n        onEnded: function onEnded() {\n          _this14._playingIds[\"delete\"](id);\n          _this14._playingMeshes[\"delete\"](id);\n          if (_this14._playingIds.size === 0) {\n            _this14._updatePlayButtonState(false);\n          }\n          if (_this14._playingIds.size === 0) {\n            _this14._clearSelectionOutline();\n          }\n        },\n        allowOverlap: true\n      });\n    }\n  }, {\n    key: \"_stopLibrarySound\",\n    value: function _stopLibrarySound(id) {\n      var _this$particleSystem6;\n      var sc = (_this$particleSystem6 = this.particleSystem) === null || _this$particleSystem6 === void 0 ? void 0 : _this$particleSystem6.surroundController;\n      if (!sc) return;\n      var sourceData = sc.sources.get(id);\n      if (sourceData && sc._isSourcePlaying(sourceData)) {\n        // CHANGED: Use fade-out instead of immediate stop\n        sc._stopSource(sourceData, true); // true = fade out\n      }\n      this._playingIds[\"delete\"](id);\n      this._playingMeshes[\"delete\"](id);\n    }\n  }, {\n    key: \"_stopAllLibrarySounds\",\n    value: function _stopAllLibrarySounds() {\n      var _this$particleSystem7;\n      var sc = (_this$particleSystem7 = this.particleSystem) === null || _this$particleSystem7 === void 0 ? void 0 : _this$particleSystem7.surroundController;\n      if (!sc) return;\n      console.log('üîá Stopping all library sounds');\n\n      // Stop each playing sound with fade\n      for (var _i = 0, _Array$from = Array.from(this._playingIds); _i < _Array$from.length; _i++) {\n        var id = _Array$from[_i];\n        this._stopLibrarySound(id);\n      }\n\n      // Clear tracking\n      this._playingIds.clear();\n      this._playingMeshes.clear();\n\n      // Update UI\n      this._updatePlayButtonState(false);\n      console.log('‚úÖ All library sounds stopped');\n    }\n  }, {\n    key: \"_updatePlayButtonState\",\n    value: function _updatePlayButtonState(isPlaying) {\n      if (!this._panel) return;\n      var playBtn = this._panel.querySelector('[data-action=\"play\"]');\n      var playIcon = this._panel.querySelector('.library-btn-icon-play');\n      var playText = playBtn === null || playBtn === void 0 ? void 0 : playBtn.querySelector('span');\n      if (!playBtn || !playIcon || !playText) return;\n      if (isPlaying) {\n        playIcon.src = '/assets/icons/Stop.svg';\n        playIcon.alt = 'Stop';\n        playText.textContent = 'Stop Sound';\n        playBtn.classList.add('playing');\n      } else {\n        playIcon.src = '/assets/icons/Play.svg';\n        playIcon.alt = 'Play';\n        playText.textContent = 'Play Sound';\n        playBtn.classList.remove('playing');\n      }\n    }\n  }, {\n    key: \"_handleExport\",\n    value: function _handleExport(item) {\n      var _this$particleSystem8,\n        _this15 = this;\n      var sc = (_this$particleSystem8 = this.particleSystem) === null || _this$particleSystem8 === void 0 ? void 0 : _this$particleSystem8.surroundController;\n      if (!sc) {\n        console.warn('‚ö†Ô∏è No audio controller available for export');\n        return;\n      }\n\n      // Helper to trigger download\n      var downloadAudio = function downloadAudio(audioBuffer, filename) {\n        if (!audioBuffer) {\n          console.error('‚ùå No audio buffer to export');\n          return;\n        }\n        try {\n          // Convert AudioBuffer to WAV format\n          var wavBlob = _this15._audioBufferToWav(audioBuffer);\n\n          // Create download link\n          var url = URL.createObjectURL(wavBlob);\n          var a = document.createElement('a');\n          a.style.display = 'none';\n          a.href = url;\n          a.download = filename;\n          document.body.appendChild(a);\n          a.click();\n\n          // Cleanup\n          setTimeout(function () {\n            document.body.removeChild(a);\n            URL.revokeObjectURL(url);\n          }, 100);\n          console.log(\"\\u2705 Exported audio: \".concat(filename));\n        } catch (error) {\n          console.error('‚ùå Failed to export audio:', error);\n        }\n      };\n      if (item.type === 'combination' && Array.isArray(item.items)) {\n        // FIXED: Extract base IDs (without generation prefix) for audio lookup\n        var ids = item.items.map(function (it) {\n          var _it$solutionData$id5, _it$solutionData8;\n          return (_it$solutionData$id5 = (_it$solutionData8 = it.solutionData) === null || _it$solutionData8 === void 0 ? void 0 : _it$solutionData8.id) !== null && _it$solutionData$id5 !== void 0 ? _it$solutionData$id5 : it.id;\n        }).filter(function (id) {\n          return id != null;\n        });\n        var buffers = ids.map(function (id) {\n          var _sc$sources$get;\n          return (_sc$sources$get = sc.sources.get(id)) === null || _sc$sources$get === void 0 ? void 0 : _sc$sources$get.buffer;\n        }).filter(Boolean);\n        if (buffers.length === 0) {\n          console.warn('‚ö†Ô∏è No audio buffers found for combination');\n          return;\n        }\n\n        // Mix all buffers\n        var mixedBuffer = this._mixAudioBuffers(buffers, sc.audioContext);\n        var filename = \"\".concat(this._sanitizeFilename(item.name || 'combination'), \".wav\");\n        downloadAudio(mixedBuffer, filename);\n      } else {\n        var _item$solutionData$id2, _item$solutionData9;\n        // FIXED: Extract base ID (without generation prefix) for audio lookup\n        var baseId = (_item$solutionData$id2 = item === null || item === void 0 || (_item$solutionData9 = item.solutionData) === null || _item$solutionData9 === void 0 ? void 0 : _item$solutionData9.id) !== null && _item$solutionData$id2 !== void 0 ? _item$solutionData$id2 : item === null || item === void 0 ? void 0 : item.id;\n        if (baseId == null) {\n          console.warn('‚ö†Ô∏è No solution ID found');\n          return;\n        }\n        var sourceData = sc.sources.get(baseId);\n        if (!(sourceData !== null && sourceData !== void 0 && sourceData.buffer)) {\n          console.warn(\"\\u26A0\\uFE0F No audio buffer found for solution \".concat(baseId));\n          return;\n        }\n        var _filename = \"\".concat(this._sanitizeFilename(item.name || \"solution_\".concat(baseId)), \".wav\");\n        downloadAudio(sourceData.buffer, _filename);\n      }\n    }\n  }, {\n    key: \"_sanitizeFilename\",\n    value: function _sanitizeFilename(name) {\n      // Remove invalid filename characters\n      return String(name).replace(/[<>:\"/\\\\|?*\\x00-\\x1F]/g, '_').replace(/\\s+/g, '_').substring(0, 100);\n    }\n  }, {\n    key: \"_audioBufferToWav\",\n    value: function _audioBufferToWav(audioBuffer) {\n      var numberOfChannels = audioBuffer.numberOfChannels;\n      var sampleRate = audioBuffer.sampleRate;\n      var format = 1; // PCM\n      var bitDepth = 16;\n      var bytesPerSample = bitDepth / 8;\n      var blockAlign = numberOfChannels * bytesPerSample;\n      var samples = audioBuffer.length;\n      var dataSize = samples * blockAlign;\n      var bufferSize = 44 + dataSize;\n      var buffer = new ArrayBuffer(bufferSize);\n      var view = new DataView(buffer);\n\n      // Write WAV header\n      var writeString = function writeString(offset, string) {\n        for (var i = 0; i < string.length; i++) {\n          view.setUint8(offset + i, string.charCodeAt(i));\n        }\n      };\n      writeString(0, 'RIFF');\n      view.setUint32(4, bufferSize - 8, true);\n      writeString(8, 'WAVE');\n      writeString(12, 'fmt ');\n      view.setUint32(16, 16, true); // fmt chunk size\n      view.setUint16(20, format, true);\n      view.setUint16(22, numberOfChannels, true);\n      view.setUint32(24, sampleRate, true);\n      view.setUint32(28, sampleRate * blockAlign, true);\n      view.setUint16(32, blockAlign, true);\n      view.setUint16(34, bitDepth, true);\n      writeString(36, 'data');\n      view.setUint32(40, dataSize, true);\n\n      // Write audio data\n      var channelData = [];\n      for (var i = 0; i < numberOfChannels; i++) {\n        channelData.push(audioBuffer.getChannelData(i));\n      }\n      var offset = 44;\n      for (var _i2 = 0; _i2 < samples; _i2++) {\n        for (var channel = 0; channel < numberOfChannels; channel++) {\n          // Convert float32 (-1 to 1) to int16 (-32768 to 32767)\n          var sample = Math.max(-1, Math.min(1, channelData[channel][_i2]));\n          var int16 = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;\n          view.setInt16(offset, int16, true);\n          offset += 2;\n        }\n      }\n      return new Blob([buffer], {\n        type: 'audio/wav'\n      });\n    }\n  }, {\n    key: \"_mixAudioBuffers\",\n    value: function _mixAudioBuffers(buffers, audioContext) {\n      if (buffers.length === 0) return null;\n      if (buffers.length === 1) return buffers[0];\n\n      // Find the longest buffer\n      var maxLength = Math.max.apply(Math, _toConsumableArray(buffers.map(function (b) {\n        return b.length;\n      })));\n      var numberOfChannels = Math.max.apply(Math, _toConsumableArray(buffers.map(function (b) {\n        return b.numberOfChannels;\n      })));\n      var sampleRate = buffers[0].sampleRate;\n\n      // Create output buffer\n      var mixedBuffer = audioContext.createBuffer(numberOfChannels, maxLength, sampleRate);\n\n      // Mix all buffers\n      for (var channel = 0; channel < numberOfChannels; channel++) {\n        var outputData = mixedBuffer.getChannelData(channel);\n        var _iterator = _createForOfIteratorHelper(buffers),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var buffer = _step.value;\n            var channelIdx = Math.min(channel, buffer.numberOfChannels - 1);\n            var inputData = buffer.getChannelData(channelIdx);\n            for (var _i4 = 0; _i4 < inputData.length; _i4++) {\n              outputData[_i4] = (outputData[_i4] || 0) + inputData[_i4] / buffers.length;\n            }\n          }\n\n          // Normalize if clipping occurs\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n        var max = 0;\n        for (var i = 0; i < outputData.length; i++) {\n          var abs = Math.abs(outputData[i]);\n          if (abs > max) max = abs;\n        }\n        if (max > 1) {\n          for (var _i3 = 0; _i3 < outputData.length; _i3++) {\n            outputData[_i3] /= max;\n          }\n        }\n      }\n      return mixedBuffer;\n    }\n    // ============== Outline helpers (SaveMode-style) ==============\n  }, {\n    key: \"_applyHoverOutline\",\n    value: function _applyHoverOutline(root) {\n      var _this16 = this;\n      this._clearHoverOutline();\n      this._hoveredContainer = root;\n      var highlightColor = new three__WEBPACK_IMPORTED_MODULE_1__.Color(0xffff88);\n      root.traverse(function (child) {\n        if (!child.isMesh) return;\n        var originalMaterial = _this16._globalLibraryMaterialCache.get(child);\n        if (!originalMaterial) return;\n\n        // Clone original and apply hover tint\n        var tinted = _this16._createTintedMaterial(originalMaterial, 0.3, highlightColor);\n        child.material = tinted;\n      });\n    }\n  }, {\n    key: \"_clearHoverOutline\",\n    value: function _clearHoverOutline() {\n      var _this17 = this;\n      if (!this._hoveredContainer) return;\n      this._hoveredContainer.traverse(function (child) {\n        if (!child.isMesh) return;\n\n        // Restore from cache\n        var originalMaterial = _this17._globalLibraryMaterialCache.get(child);\n        if (originalMaterial) {\n          child.material = originalMaterial;\n        }\n      });\n      this._hoveredContainer = null;\n    }\n  }, {\n    key: \"_applySelectionOutline\",\n    value: function _applySelectionOutline(root) {\n      var _this18 = this;\n      this._clearSelectionOutline();\n      this._selectedContainer = root;\n      var highlightColor = new three__WEBPACK_IMPORTED_MODULE_1__.Color(0x53d3c0);\n      root.traverse(function (child) {\n        if (!child.isMesh) return;\n        var originalMaterial = _this18._globalLibraryMaterialCache.get(child);\n        if (!originalMaterial) return;\n\n        // Clone original and apply selection tint\n        var tinted = _this18._createTintedMaterial(originalMaterial, 0.5, highlightColor);\n        child.material = tinted;\n      });\n    }\n  }, {\n    key: \"_clearSelectionOutline\",\n    value: function _clearSelectionOutline() {\n      var _this19 = this;\n      if (!this._selectedContainer) return;\n      this._selectedContainer.traverse(function (child) {\n        if (!child.isMesh) return;\n\n        // Restore from cache\n        var originalMaterial = _this19._globalLibraryMaterialCache.get(child);\n        if (originalMaterial) {\n          child.material = originalMaterial;\n        }\n      });\n      this._selectedContainer = null;\n    }\n  }, {\n    key: \"_createTintedMaterial\",\n    value: function _createTintedMaterial(source, intensity, highlightColor) {\n      if (!source || typeof source.clone !== 'function') {\n        console.warn('‚ö†Ô∏è Cannot clone material:', source);\n        return source;\n      }\n      try {\n        var _source$opacity;\n        var cloned = source.clone();\n        if ('emissive' in cloned && cloned.emissive && typeof cloned.emissive.copy === 'function') {\n          var _cloned$emissiveInten;\n          cloned.emissive.copy(highlightColor);\n          cloned.emissiveIntensity = Math.max(intensity, (_cloned$emissiveInten = cloned.emissiveIntensity) !== null && _cloned$emissiveInten !== void 0 ? _cloned$emissiveInten : 0);\n        }\n        if ('color' in cloned && cloned.color && typeof cloned.color.lerp === 'function') {\n          cloned.color = cloned.color.clone().lerp(highlightColor, 0.45);\n        }\n        cloned.transparent = true;\n        cloned.opacity = Math.min(0.95, (_source$opacity = source.opacity) !== null && _source$opacity !== void 0 ? _source$opacity : 1);\n        cloned.needsUpdate = true;\n        return cloned;\n      } catch (e) {\n        console.warn('‚ö†Ô∏è Failed to create tinted material:', e);\n        return source;\n      }\n    }\n\n    // ============== Helper methods ==============\n  }, {\n    key: \"_findPrimaryMesh\",\n    value: function _findPrimaryMesh(root) {\n      var primary = null;\n      root.traverse(function (n) {\n        if (n.isMesh && n.userData && n.userData.isPrimary) {\n          primary = n;\n        }\n      });\n      return primary || root;\n    }\n  }, {\n    key: \"_retargetUpdateFunctionsForClone\",\n    value: function _retargetUpdateFunctionsForClone(runtime) {\n      // Placeholder for animation retargeting\n    }\n  }, {\n    key: \"_updateLibrarySolidsAnimation\",\n    value: function _updateLibrarySolidsAnimation() {\n      // Placeholder for solid animation updates\n    }\n  }, {\n    key: \"_beginPanelEdit\",\n    value: function _beginPanelEdit() {\n      this._panelEditDepth++;\n      if (this._panel) this._panel.classList.add('editing-active');\n    }\n  }, {\n    key: \"_endPanelEdit\",\n    value: function _endPanelEdit() {\n      this._panelEditDepth = Math.max(0, this._panelEditDepth - 1);\n      if (this._panelEditDepth === 0 && this._panel) {\n        this._panel.classList.remove('editing-active');\n      }\n    }\n  }, {\n    key: \"_applyNameLayout\",\n    value: function _applyNameLayout(container, name) {\n      container.textContent = '';\n      container.classList.add('library-name');\n      if (name.length > this.nameVerticalThreshold) {\n        container.classList.add('vertical');\n      } else {\n        container.classList.remove('vertical');\n      }\n      container.textContent = name;\n    }\n  }, {\n    key: \"_sanitizeName\",\n    value: function _sanitizeName(name) {\n      return String(name || '').trim().slice(0, this.nameMaxLength) || '(unnamed)';\n    }\n  }, {\n    key: \"_sanitizeDescription\",\n    value: function _sanitizeDescription(desc) {\n      return String(desc || '').trim().slice(0, this.descriptionMaxLength);\n    }\n  }, {\n    key: \"_capitalizeFirst\",\n    value: function _capitalizeFirst(str) {\n      return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();\n    }\n  }, {\n    key: \"_uniqueCapCategories\",\n    value: function _uniqueCapCategories(arr) {\n      var seen = new Set();\n      var result = [];\n      var _iterator2 = _createForOfIteratorHelper(arr),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var cat = _step2.value;\n          var lower = String(cat).toLowerCase();\n          if (!seen.has(lower)) {\n            seen.add(lower);\n            result.push(this._capitalizeFirst(cat));\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      return result;\n    }\n  }, {\n    key: \"_positionInfoPanel\",\n    value: function _positionInfoPanel() {\n      // Placeholder for panel positioning logic\n    }\n  }]);\n}();\n\n//# sourceURL=webpack://sound-particle-visualization/./src/components/Library.js?");

/***/ }),

/***/ "./src/components/LoadingScreen.js":
/*!*****************************************!*\
  !*** ./src/components/LoadingScreen.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LoadingScreen: () => (/* binding */ LoadingScreen)\n/* harmony export */ });\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar LoadingScreen = /*#__PURE__*/function () {\n  function LoadingScreen() {\n    _classCallCheck(this, LoadingScreen);\n    this.container = null;\n    this.isVisible = false;\n  }\n  return _createClass(LoadingScreen, [{\n    key: \"show\",\n    value: function show() {\n      var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Loading';\n      if (this.isVisible) return;\n\n      // Remove any existing loading screen\n      this.hide();\n\n      // Create loading container\n      this.container = document.createElement('div');\n      this.container.className = 'loading-screen';\n\n      // Create content\n      var content = document.createElement('div');\n      content.className = 'loading-content';\n\n      // Create animated text\n      var text = document.createElement('div');\n      text.className = 'loading-text';\n      text.textContent = message;\n\n      // Create animated dots\n      var dots = document.createElement('span');\n      dots.className = 'loading-dots';\n      text.appendChild(dots);\n      content.appendChild(text);\n      this.container.appendChild(content);\n      document.body.appendChild(this.container);\n      this.isVisible = true;\n\n      // Animate dots\n      this.animateDots();\n      console.log(\"\\uD83D\\uDD04 Loading screen shown: \\\"\".concat(message, \"\\\"\"));\n    }\n  }, {\n    key: \"hide\",\n    value: function hide() {\n      var _this = this;\n      if (this.container) {\n        this.container.classList.add('fade-out');\n        setTimeout(function () {\n          if (_this.container && _this.container.parentElement) {\n            _this.container.remove();\n          }\n          _this.container = null;\n          _this.isVisible = false;\n        }, 500); // Match CSS transition\n        console.log('‚úÖ Loading screen hidden');\n      }\n    }\n  }, {\n    key: \"updateMessage\",\n    value: function updateMessage(message) {\n      if (this.container) {\n        var textEl = this.container.querySelector('.loading-text');\n        if (textEl) {\n          // Preserve dots element\n          var dots = textEl.querySelector('.loading-dots');\n          textEl.textContent = message;\n          if (dots) textEl.appendChild(dots);\n        }\n      }\n    }\n  }, {\n    key: \"animateDots\",\n    value: function animateDots() {\n      var _this2 = this;\n      if (!this.container) return;\n      var dots = this.container.querySelector('.loading-dots');\n      if (!dots) return;\n      var dotCount = 0;\n      var interval = setInterval(function () {\n        if (!_this2.isVisible || !_this2.container) {\n          clearInterval(interval);\n          return;\n        }\n        dotCount = (dotCount + 1) % 4;\n        dots.textContent = '.'.repeat(dotCount);\n      }, 500);\n    }\n  }]);\n}();\n\n//# sourceURL=webpack://sound-particle-visualization/./src/components/LoadingScreen.js?");

/***/ }),

/***/ "./src/components/ParticleSystem.js":
/*!******************************************!*\
  !*** ./src/components/ParticleSystem.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ParticleSystem: () => (/* binding */ ParticleSystem)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n/* harmony import */ var _GeometricSolid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GeometricSolid */ \"./src/components/GeometricSolid.js\");\n/* harmony import */ var _SpatialGrid_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SpatialGrid.js */ \"./src/components/SpatialGrid.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _createForOfIteratorHelper(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n // CHANGED: Named import with curly braces\n\nvar complementary_map = {\n  'low': 'mid',\n  'high': 'mid',\n  'mid': 'rhythmic',\n  'rhythmic': 'mid'\n};\nfunction generateSwarmPeakPositions(numPeaks, time) {\n  var baseRadius = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 50;\n  var spread = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 75;\n  var positions = [];\n  for (var i = 0; i < numPeaks; i++) {\n    var t = time + i * 10;\n    var angle = Math.sin(t * 0.13 + i) * Math.PI + Math.cos(t * 0.17 + i * 0.5) * Math.PI * 0.5;\n    var radius = baseRadius + Math.sin(t * 0.07 + i) * spread * 0.5 + Math.cos(t * 0.11 + i) * spread * 0.3;\n    positions.push(new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(Math.cos(angle) * radius, 0, Math.sin(angle) * radius));\n  }\n  return positions;\n}\nvar ParticleSystem = /*#__PURE__*/function () {\n  function ParticleSystem(scene) {\n    var baseRadius = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n    _classCallCheck(this, ParticleSystem);\n    this.scene = scene;\n    this.baseRadius = baseRadius;\n    this.peaks = [];\n    this.previousHeights = [];\n    this.time = 0;\n    this.updateInterval = 40;\n    this.frameCounter = 0;\n    this.targetLocked = false;\n    this.frozenSwarmPositions = null;\n    this.lightPositions = [];\n    this.lightIntensities = [];\n    this.currentSolutions = [];\n    this.isEvolvingFrozen = false;\n    this.evolvingActive = false;\n    this.grainsPerVisiblePeak = 300;\n    this.categoryFilterActive = false;\n    this.defaultGrainClearance = 1.0;\n    this.grainColumnHeight = 6.0;\n    this.evolveSessionBaseY = null;\n    this.spatialGrid = new _SpatialGrid_js__WEBPACK_IMPORTED_MODULE_1__.SpatialGrid(50);\n    this.initPeaks();\n    this.peakSolids = [];\n    this.motionSystem = {\n      mode: 'lerp',\n      followLerp: 0.05,\n      maxVelocity: 1.5,\n      // NEW: units per frame (tune this!)\n\n      // === GLOBAL BEHAVIOR ===\n      swarmWeight: 0.20,\n      // REDUCED: let pairs dominate over swirl (was 0.35)\n      maxOffset: 5.0,\n      // === REPULSION (personal space) ===\n      minSeparation: 30,\n      repulsionStrength: 0.20,\n      repulsionWeight: 0.4,\n      // === COMPLEMENTARY ATTRACTION (pre-pairing) ===\n      complementaryRange: 35,\n      complementaryPull: 0.008,\n      attractionWeight: 0.2,\n      // === PAIRING (formation & maintenance) ===\n      pairFormRadius: 25,\n      pairKeepRadius: 35,\n      pairMinFrames: 480,\n      pairBreakProb: 0.0003,\n      pairCooldown: 240,\n      // === BOIDS FLOCKING (separation, cohesion, alignment) ===\n      // SEPARATION: maintain distance but stay together\n      pairDesiredSeparation: 25,\n      // INCREASED: wider gap (was 15)\n      pairSeparationStrength: 0.32,\n      // INCREASED: stronger spacing (was 0.26)\n\n      // COHESION: pull toward shared center\n      pairCohesionStrength: 0.5,\n      // INCREASED: stronger pull to center (was 0.5)\n\n      // ALIGNMENT: match headings\n      pairAlignmentStrength: 3.2,\n      // INCREASED: much stronger (was 2.5)\n      pairTravelSpeed: 2.0,\n      // INCREASED: faster (was 1.6)\n      pairHeadingSmoothing: 0.04,\n      // REDUCED: quicker sync (was 0.05)\n      pairHeadingJitter: 1,\n      // REDUCED: minimal jitter (was 2)\n      pairJitterInterval: 280,\n      // INCREASED: jitter very rarely (was 220)\n\n      // === PAIR EASE-IN ===\n      pairEaseFrames: 150,\n      // REDUCED: faster stabilization (was 180)\n\n      // === PAIR BREAK SMOOTHING ===\n      breakGraceFrames: 300,\n      // === EXPLORATION (solo movement) ===\n      wanderStrength: 0.45,\n      wanderInPair: 0.015,\n      // REDUCED: almost no wander when paired (was 0.02)\n      circularBias: 0.18,\n      explorationPairedScale: 0.10,\n      // REDUCED: minimal exploration in pairs (was 0.10)\n      maxRange: 180,\n      // === CENTER AVOIDANCE ===\n      avoidCenterRadius: 50,\n      avoidCenterStrength: 0.8,\n      // === WEIGHT SYSTEM ===\n      pairingWeight: 1.6,\n      // INCREASED: pairs dominate (was 1.2)\n      explorationWeight: 0.4,\n      // NEW: Additional tuning parameters\n      forceDamping: 0.85,\n      // Exponential decay on force offset\n      velocityBlendRate: 0.3,\n      // How quickly velocity adapts to desired\n      swirlPairedScale: 0.55,\n      // Reduce swirl influence when paired\n\n      // Grain behavior\n      grainSpringStrength: 0.12,\n      grainOrbitSpeed: 0.4,\n      grainOrbitAmount: 0.15,\n      grainVelocityDamping: 0.88,\n      grainMaxSpeedMultiplier: 1.8,\n      // Evolving\n      evolvingLerpSpeed: 0.12,\n      // Repulsion\n      pairedRepulsionScale: 0.4,\n      // Reduce repulsion between paired members\n      attractionInnerMargin: 1.2,\n      // Safety margin multiplier\n\n      // Heading\n      headingTangentWeight: 0.85,\n      // INCREASED: prioritize desired direction (was 0.6)\n      headingVelocityWeight: 0.15,\n      // Boundary\n      boundaryPushRate: 0.05\n    };\n    // Simplified state tracking\n    this._pairStates = []; // {partner: -1|index, frames: 0, cooldown: 0}\n    this._lastPositions = []; // for deriving velocities when needed\n    this._pairDirections = []; // Shared directions for pairs\n    this._velocities = []; // NEW: track actual velocities\n\n    this.initPairConnections();\n  }\n  return _createClass(ParticleSystem, [{\n    key: \"initPeaks\",\n    value: function initPeaks() {\n      var numPeaks = 10;\n      var peakSpacing = 30;\n      for (var i = 0; i < numPeaks; i++) {\n        var peak = {\n          grains: [],\n          grainTargets: [],\n          movingToNewPyramid: false,\n          nextPyramidCenter: new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(i * peakSpacing - numPeaks * peakSpacing / 2, 0, 0),\n          currentPyramidCenter: new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(i * peakSpacing - numPeaks * peakSpacing / 2, 0, 0),\n          readyForNextMove: true,\n          categoryVisible: true,\n          exploreSeed: Math.random() * 1000 // NEW seed for exploration\n        };\n        var grainCount = 300;\n        for (var j = 0; j < grainCount; j++) {\n          var grain = new three__WEBPACK_IMPORTED_MODULE_2__.Mesh(new three__WEBPACK_IMPORTED_MODULE_2__.SphereGeometry(0.09, 8, 8), new three__WEBPACK_IMPORTED_MODULE_2__.MeshStandardMaterial({\n            color: 0xe0dbc1,\n            emissive: 0xe0dbc1,\n            emissiveIntensity: 0.3,\n            transparent: true,\n            opacity: 0.8\n          }));\n          grain.layers.enable(1);\n          var heightFactor = Math.random();\n          var minRadius = 0.2 * this.baseRadius;\n          var scaledRadius = minRadius + (1 - heightFactor) * (this.baseRadius - minRadius);\n          var angle = Math.random() * Math.PI * 2;\n          var randomization = [];\n          for (var r = 0; r < 4; r++) randomization.push(0.3 + 0.4 * Math.random());\n          var baseAccel = 0.10 + 0.25 * Math.random();\n          var baseSpeed = 0.025 + 0.050 * Math.random();\n          var maxSpeed = 0.15 + 0.18 * Math.random();\n          grain.userData = {\n            heightFactor: heightFactor,\n            angle: angle,\n            randomization: randomization,\n            transitionSeed: Math.random() * 100,\n            baseAccel: baseAccel,\n            baseSpeed: baseSpeed,\n            maxSpeed: maxSpeed\n          };\n          grain.position.set(peak.currentPyramidCenter.x + scaledRadius * Math.cos(angle), heightFactor * 8 + Math.random() * 0.6 - 0.3, peak.currentPyramidCenter.z + scaledRadius * Math.sin(angle));\n          var theta = Math.random() * 2 * Math.PI;\n          var phi = Math.random() * Math.PI;\n          grain.userData.velocity = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(Math.sin(phi) * Math.cos(theta), Math.cos(phi), Math.sin(phi) * Math.sin(theta)).multiplyScalar(baseSpeed);\n          grain.userData.acceleration = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n          this.scene.add(grain);\n          peak.grains.push(grain);\n          peak.grainTargets.push(grain.position.clone());\n        }\n        this.peaks.push(peak);\n        this.previousHeights.push(8);\n      }\n    }\n  }, {\n    key: \"initPairConnections\",\n    value: function initPairConnections() {\n      this.pairLines = [];\n      var lineMaterial = new three__WEBPACK_IMPORTED_MODULE_2__.LineBasicMaterial({\n        color: 0x88ff88,\n        transparent: true,\n        opacity: 0.6\n      });\n      for (var i = 0; i < 15; i++) {\n        var lineGeometry = new three__WEBPACK_IMPORTED_MODULE_2__.BufferGeometry();\n        var line = new three__WEBPACK_IMPORTED_MODULE_2__.Line(lineGeometry, lineMaterial);\n        line.visible = false;\n        this.scene.add(line);\n        this.pairLines.push(line);\n      }\n    }\n  }, {\n    key: \"regenerateWithSolutions\",\n    value: function regenerateWithSolutions(solutions) {\n      var _this = this;\n      // Guard clause\n      if (!this.peaks || this.peaks.length === 0) {\n        console.warn('‚ö†Ô∏è Cannot regenerate - peaks not initialized. Call initializeWithData() first.');\n        return;\n      }\n      if (!solutions || solutions.length === 0) {\n        console.warn('‚ö†Ô∏è No solutions provided for regeneration');\n        return;\n      }\n      this.currentSolutions = solutions;\n      this.peakSolids.forEach(function (solid) {\n        if (solid && _this.scene) {\n          _this.scene.remove(solid);\n        }\n      });\n      this.peakSolids = [];\n      var targetPeaks = solutions.length;\n      var currentPeaks = this.peaks.length;\n      if (targetPeaks !== currentPeaks) {\n        this.adjustPeakCount(targetPeaks);\n      }\n      this.ensureArraySizes();\n      for (var i = 0; i < Math.min(solutions.length, this.peaks.length); i++) {\n        var solution = solutions[i];\n        var peak = this.peaks[i];\n        if (!peak || !peak.currentPyramidCenter) {\n          console.warn(\"\\u26A0\\uFE0F Invalid peak at index \".concat(i, \", skipping solid creation\"));\n          continue;\n        }\n        try {\n          console.log(\"\\uD83C\\uDFA8 Creating solid \".concat(i, \" for solution \").concat(solution.id, \":\"), solution.parameters);\n          var solid = (0,_GeometricSolid__WEBPACK_IMPORTED_MODULE_0__.createGeometricSolid)(solution);\n          if (solid) {\n            solid.position.copy(peak.currentPyramidCenter);\n            solid.position.y += 6;\n            this.scene.add(solid);\n            this.peakSolids.push(solid);\n          }\n        } catch (error) {\n          console.error(\"\\u274C Error creating solid \".concat(i, \":\"), error);\n        }\n      }\n      console.log('‚úÖ Regeneration complete:', this.peakSolids.length, 'solids created');\n    }\n  }, {\n    key: \"adjustPeakCount\",\n    value: function adjustPeakCount(targetCount) {\n      if (targetCount <= 0) {\n        console.warn('‚ö†Ô∏è Invalid target count for peaks:', targetCount);\n        return;\n      }\n      var currentCount = this.peaks.length;\n      if (targetCount > currentCount) {\n        for (var i = currentCount; i < targetCount; i++) {\n          this.createSinglePeak(i, targetCount);\n        }\n      } else if (targetCount < currentCount) {\n        for (var _i = currentCount - 1; _i >= targetCount; _i--) {\n          this.removeSinglePeak(_i);\n        }\n      }\n      this.repositionPeaks();\n    }\n  }, {\n    key: \"createSinglePeak\",\n    value: function createSinglePeak(index, totalPeaks) {\n      var peakSpacing = 80;\n      var peak = {\n        grains: [],\n        grainTargets: [],\n        movingToNewPyramid: false,\n        nextPyramidCenter: new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(index * peakSpacing - totalPeaks * peakSpacing / 2, 0, 0),\n        currentPyramidCenter: new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(index * peakSpacing - totalPeaks * peakSpacing / 2, 0, 0),\n        readyForNextMove: true,\n        velocity: new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(),\n        acceleration: new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(),\n        categoryVisible: true // <- default visible\n      };\n      var grainCount = 300;\n      for (var j = 0; j < grainCount; j++) {\n        try {\n          var grain = this.createSingleGrain(peak);\n          if (grain) {\n            this.scene.add(grain);\n            peak.grains.push(grain);\n            peak.grainTargets.push(grain.position.clone());\n          }\n        } catch (error) {\n          console.error(\"Error creating grain \".concat(j, \" for peak \").concat(index, \":\"), error);\n        }\n      }\n      this.peaks.push(peak);\n      this.previousHeights.push(8);\n    }\n  }, {\n    key: \"removeSinglePeak\",\n    value: function removeSinglePeak(index) {\n      var _this2 = this;\n      if (index < 0 || index >= this.peaks.length) return;\n      var peak = this.peaks[index];\n      if (peak && peak.grains) {\n        peak.grains.forEach(function (grain) {\n          if (grain && _this2.scene) {\n            _this2.scene.remove(grain);\n          }\n        });\n      }\n      this.peaks.splice(index, 1);\n      if (this.previousHeights.length > index) {\n        this.previousHeights.splice(index, 1);\n      }\n    }\n  }, {\n    key: \"createSingleGrain\",\n    value: function createSingleGrain(peak) {\n      var grain = new three__WEBPACK_IMPORTED_MODULE_2__.Mesh(new three__WEBPACK_IMPORTED_MODULE_2__.SphereGeometry(0.09, 8, 8), new three__WEBPACK_IMPORTED_MODULE_2__.MeshStandardMaterial({\n        color: 0xe0dbc1,\n        emissive: 0xe0dbc1,\n        emissiveIntensity: 0.3,\n        transparent: true,\n        opacity: 0.8\n      }));\n      grain.layers.enable(1);\n      var heightFactor = Math.random();\n      var minRadius = 0.2 * this.baseRadius;\n      var scaledRadius = minRadius + (1 - heightFactor) * (this.baseRadius - minRadius);\n      var angle = Math.random() * Math.PI * 2;\n      var randomization = [];\n      for (var r = 0; r < 4; r++) randomization.push(0.3 + 0.4 * Math.random());\n      var baseAccel = 0.08 + 0.10 * Math.random();\n      var baseSpeed = 0.025 + 0.050 * Math.random();\n      var maxSpeed = 0.05 + 0.18 * Math.random();\n      grain.userData = {\n        heightFactor: heightFactor,\n        angle: angle,\n        randomization: randomization,\n        transitionSeed: Math.random() * 100,\n        baseAccel: baseAccel,\n        baseSpeed: baseSpeed,\n        maxSpeed: maxSpeed,\n        velocity: new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(),\n        acceleration: new three__WEBPACK_IMPORTED_MODULE_2__.Vector3()\n      };\n      grain.position.set(peak.currentPyramidCenter.x + scaledRadius * Math.cos(angle), heightFactor * 8 + Math.random() * 0.6 - 0.3, peak.currentPyramidCenter.z + scaledRadius * Math.sin(angle));\n      var theta = Math.random() * 2 * Math.PI;\n      var phi = Math.random() * Math.PI;\n      grain.userData.velocity = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(Math.sin(phi) * Math.cos(theta), Math.cos(phi), Math.sin(phi) * Math.sin(theta)).multiplyScalar(baseSpeed);\n      return grain;\n    }\n  }, {\n    key: \"repositionPeaks\",\n    value: function repositionPeaks() {\n      var peakSpacing = 30;\n      for (var i = 0; i < this.peaks.length; i++) {\n        var newX = i * peakSpacing - this.peaks.length * peakSpacing / 2;\n        if (this.peaks[i]) {\n          this.peaks[i].currentPyramidCenter.x = newX;\n          this.peaks[i].nextPyramidCenter.x = newX;\n        }\n      }\n    }\n  }, {\n    key: \"ensureArraySizes\",\n    value: function ensureArraySizes() {\n      var peakCount = this.peaks.length;\n      while (this.previousHeights.length < peakCount) {\n        this.previousHeights.push(8);\n      }\n      while (this.previousHeights.length > peakCount) {\n        this.previousHeights.pop();\n      }\n      while (this.peakSolids.length > peakCount) {\n        var solid = this.peakSolids.pop();\n        if (solid && this.scene) {\n          this.scene.remove(solid);\n        }\n      }\n      if (this.frozenSwarmPositions && this.frozenSwarmPositions.length !== peakCount) {\n        if (this.targetLocked) {\n          this.frozenSwarmPositions = generateSwarmPeakPositions(peakCount, this.time);\n        }\n      }\n    }\n  }, {\n    key: \"smoothTransition\",\n    value: function smoothTransition(current, target, speed) {\n      return current + (target - current) * speed;\n    }\n  }, {\n    key: \"setNewGrainTargets\",\n    value: function setNewGrainTargets(peak, smoothedHeight) {\n      for (var j = 0; j < peak.grains.length; j++) {\n        var _peak$grains$j$userDa = peak.grains[j].userData,\n          heightFactor = _peak$grains$j$userDa.heightFactor,\n          angle = _peak$grains$j$userDa.angle;\n        var minRadius = 0.2 * this.baseRadius;\n        var scaledRadius = minRadius + (1 - heightFactor) * (this.baseRadius - minRadius);\n        peak.grainTargets[j] = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(peak.nextPyramidCenter.x + scaledRadius * Math.cos(angle), heightFactor * smoothedHeight, peak.nextPyramidCenter.z + scaledRadius * Math.sin(angle));\n      }\n      peak.movingToNewPyramid = true;\n    }\n  }, {\n    key: \"startEvolvingAlignment\",\n    value: function startEvolvingAlignment(targetList) {\n      var _this3 = this;\n      if (!Array.isArray(targetList) || targetList.length === 0) return;\n      this.evolvingActive = true;\n      targetList.forEach(function (entry) {\n        var solid = entry.solid;\n        var target = entry.target;\n        var peakIndex = _this3.peakSolids.indexOf(solid);\n        if (peakIndex !== -1 && _this3.peaks[peakIndex]) {\n          var peak = _this3.peaks[peakIndex];\n          peak.evolvingTargetCenter = target.clone();\n          peak.evolvingMoveSpeed = 0.12;\n          peak.evolvingLock = false; // allow movement\n        }\n      });\n    }\n  }, {\n    key: \"startEvolvingAlignmentInstant\",\n    value:\n    // NEW: Instant evolving alignment (snaps peaks and grains immediately)\n    function startEvolvingAlignmentInstant(targetList) {\n      var _this4 = this;\n      if (!Array.isArray(targetList) || targetList.length === 0) return;\n      this.evolvingActive = true;\n\n      // Ensure helper arrays exist\n      while (this._lastPositions.length < this.peaks.length) {\n        this._lastPositions.push(new three__WEBPACK_IMPORTED_MODULE_2__.Vector3());\n      }\n      while (this._velocities.length < this.peaks.length) {\n        this._velocities.push(new three__WEBPACK_IMPORTED_MODULE_2__.Vector3());\n      }\n      targetList.forEach(function (entry) {\n        var solid = entry.solid;\n        var target = entry.target;\n        var peakIndex = _this4.peakSolids.indexOf(solid);\n        if (peakIndex === -1) return;\n        var peak = _this4.peaks[peakIndex];\n        if (!peak) return;\n\n        // Calculate delta to move grains relatively\n        var delta = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3().subVectors(target, peak.currentPyramidCenter);\n\n        // INSTANT snap peak center\n        peak.currentPyramidCenter.copy(target);\n\n        // INSTANT move all grains by the same delta\n        if (Array.isArray(peak.grains)) {\n          for (var g = 0; g < peak.grains.length; g++) {\n            var grain = peak.grains[g];\n            if (grain) {\n              grain.position.add(delta);\n              // Zero motion to prevent drift\n              if (grain.userData.velocity) grain.userData.velocity.set(0, 0, 0);\n              if (grain.userData.acceleration) grain.userData.acceleration.set(0, 0, 0);\n            }\n          }\n        }\n\n        // INSTANT snap solid position\n        if (solid) {\n          solid.position.x = peak.currentPyramidCenter.x;\n          solid.position.z = peak.currentPyramidCenter.z;\n        }\n\n        // NEW: Set lock flag to prevent forces from moving peaks\n        peak.evolvingLock = true;\n\n        // Zero motion history to prevent velocity spike\n        if (_this4._lastPositions[peakIndex]) {\n          _this4._lastPositions[peakIndex].copy(peak.currentPyramidCenter);\n        }\n        if (_this4._velocities[peakIndex]) {\n          _this4._velocities[peakIndex].set(0, 0, 0);\n        }\n      });\n    }\n  }, {\n    key: \"stopEvolvingAlignment\",\n    value: function stopEvolvingAlignment() {\n      this.evolvingActive = false;\n      this.peaks.forEach(function (p) {\n        if (!p) return;\n        delete p.evolvingTargetCenter;\n        delete p.evolvingLock;\n        delete p.evolvingMoveSpeed;\n        delete p.manualHeight;\n        delete p.evolveBaseY;\n      });\n      this.evolveSessionBaseY = null;\n    }\n  }, {\n    key: \"update\",\n    value: function update(frequencyData) {\n      var _this5 = this;\n      // Guard clause - don't update if not initialized or no valid data\n      if (!this.peaks || this.peaks.length === 0) {\n        return; // Exit early if no peaks exist yet\n      }\n\n      // Guard clause - handle missing or invalid frequency data\n      if (!frequencyData || frequencyData.length === 0) {\n        // Use zeros/silence if no audio data available\n        frequencyData = new Uint8Array(10);\n      }\n      this.time += 0.016;\n      this.frameCounter++;\n      if (this.frameCounter % Math.floor(this.updateInterval / 16) !== 0) {\n        return;\n      }\n\n      // Initialize state arrays if needed\n      while (this._pairStates.length < this.peaks.length) {\n        this._pairStates.push({\n          partner: -1,\n          frames: 0,\n          cooldown: 0,\n          breakFrames: 0,\n          breakDir: new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(),\n          breakGrace: 0,\n          breakPartner: -1,\n          breakFade: 0,\n          breakHeading: new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(),\n          breakEase: 1.0 // NEW: store ease level at break time\n        });\n      }\n      while (this._lastPositions.length < this.peaks.length) {\n        this._lastPositions.push(new three__WEBPACK_IMPORTED_MODULE_2__.Vector3());\n      }\n      while (this._velocities.length < this.peaks.length) {\n        this._velocities.push(new three__WEBPACK_IMPORTED_MODULE_2__.Vector3());\n      }\n\n      // Swarm targets\n      var swarmPositions;\n      if (this.targetLocked && this.frozenSwarmPositions && this.frozenSwarmPositions.length === this.peaks.length) {\n        swarmPositions = this.frozenSwarmPositions;\n      } else {\n        swarmPositions = generateSwarmPeakPositions(this.peaks.length, this.time);\n      }\n\n      // Find and establish pairs\n      this._findPairs();\n\n      // Get reference to motion config\n      var M = this.motionSystem;\n\n      // Process each peak for movement\n      for (var i = 0; i < this.peaks.length; i++) {\n        var peak = this.peaks[i];\n        if (!peak || !peak.currentPyramidCenter) continue;\n        if (this.categoryFilterActive && peak.categoryVisible === false) continue;\n\n        // NEW: Skip ALL movement if stopAllMovement is true (Save Mode)\n        if (this.stopAllMovement) {\n          continue;\n        }\n\n        // Evolving alignment override - LOCK XZ position completely\n        if (this.evolvingActive && peak.evolvingLock) {\n          // Peak is locked in evolve mode - skip ALL movement logic\n          continue;\n        }\n\n        // Legacy check for smooth alignment (shouldn't happen with instant mode)\n        if (peak.evolvingTargetCenter && !peak.evolvingLock) {\n          var _peak$evolvingMoveSpe;\n          peak.currentPyramidCenter.lerp(peak.evolvingTargetCenter, (_peak$evolvingMoveSpe = peak.evolvingMoveSpeed) !== null && _peak$evolvingMoveSpe !== void 0 ? _peak$evolvingMoveSpe : 0.1);\n          if (peak.currentPyramidCenter.distanceTo(peak.evolvingTargetCenter) < 0.02) {\n            peak.currentPyramidCenter.copy(peak.evolvingTargetCenter);\n            peak.evolvingLock = true;\n          }\n          continue;\n        }\n\n        // Base target from swarm pattern\n        var baseTarget = swarmPositions[i];\n\n        // Accumulate force offset (positional) instead of velocity\n        var forceOffset = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n\n        // NEW: Track if break happens this frame\n        this._pairStates[i].breakThisFrame = false;\n\n        // Apply forces (pairing first so it can flag breaks)\n        this._applyPairingForces(i, forceOffset);\n\n        // Only apply repulsion if no break happened\n        if (!this._pairStates[i].breakThisFrame) {\n          this._applyRepulsionForces(i, forceOffset);\n        }\n        this._applyExplorationForces(i, forceOffset, this.time);\n\n        // Apply exponential decay to force offset (reduces oscillation)\n        var dampingFactor = 0.85;\n        forceOffset.multiplyScalar(dampingFactor);\n\n        // Clamp total force\n        if (forceOffset.length() > M.maxOffset) {\n          forceOffset.setLength(M.maxOffset);\n        }\n\n        // NEW: Track velocity and limit it\n        if (!this._velocities[i]) this._velocities[i] = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n        var velocity = this._velocities[i];\n\n        // Blend swirl target with current position\n        var state = this._pairStates[i];\n        var swirlWeight = state && state.partner !== -1 ? M.swarmWeight * 0.55 : M.swarmWeight;\n        var swirlTarget = peak.currentPyramidCenter.clone().lerp(baseTarget, swirlWeight);\n        var adjustedTarget = swirlTarget.add(forceOffset);\n\n        // Calculate desired velocity from LERP\n        var desiredMove = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3().subVectors(adjustedTarget, peak.currentPyramidCenter);\n        var desiredVel = desiredMove.multiplyScalar(M.followLerp);\n\n        // Smoothly blend velocity (prevents abrupt changes)\n        velocity.lerp(desiredVel, 0.3);\n\n        // LIMIT VELOCITY to maxVelocity\n        if (velocity.length() > M.maxVelocity) {\n          velocity.setLength(M.maxVelocity);\n        }\n\n        // Apply velocity\n        peak.currentPyramidCenter.add(velocity);\n      }\n\n      // Update state tracking\n      for (var _i2 = 0; _i2 < this.peaks.length; _i2++) {\n        if (this.peaks[_i2] && this.peaks[_i2].currentPyramidCenter) {\n          if (!this._lastPositions[_i2]) this._lastPositions[_i2] = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n          this._lastPositions[_i2].copy(this.peaks[_i2].currentPyramidCenter);\n        }\n      }\n\n      // Grain updates\n      this.peaks.forEach(function (peak, index) {\n        if (!peak || !peak.grains) return;\n        if (_this5.categoryFilterActive && peak.categoryVisible === false) return;\n\n        // Default/audio height for main screen\n        var frequencyIndex = index % Math.max(frequencyData.length, 1);\n        var targetHeight = frequencyData.length > 0 ? frequencyData[frequencyIndex] / 256 * 5 : 5;\n        if (typeof _this5.previousHeights[index] !== 'number') _this5.previousHeights[index] = targetHeight;\n        var smoothedHeight = _this5.previousHeights[index] * 0.8 + targetHeight * 0.2;\n        _this5.previousHeights[index] = smoothedHeight;\n        var topY = null;\n        if (_this5.evolvingActive) {\n          var solid = _this5.peakSolids[index];\n          if (solid) {\n            var _solid$userData, _solid$userData2;\n            var clearance = (_solid$userData = solid.userData) === null || _solid$userData === void 0 ? void 0 : _solid$userData.grainClearance;\n            var centerOffsetY = (_solid$userData2 = solid.userData) === null || _solid$userData2 === void 0 ? void 0 : _solid$userData2.centerOffsetY;\n            if (clearance === undefined || centerOffsetY === undefined) {\n              var bb = new three__WEBPACK_IMPORTED_MODULE_2__.Box3().setFromObject(solid);\n              var size = bb.getSize(new three__WEBPACK_IMPORTED_MODULE_2__.Vector3());\n              var center = bb.getCenter(new three__WEBPACK_IMPORTED_MODULE_2__.Vector3());\n              clearance = size.y * 0.5 + _this5.defaultGrainClearance;\n              centerOffsetY = center.y - solid.position.y;\n              solid.userData.grainClearance = clearance;\n              solid.userData.centerOffsetY = centerOffsetY;\n            }\n            var centerY = solid.position.y + centerOffsetY;\n            topY = centerY - clearance;\n          }\n        }\n        var GRAIN_THRESHOLD = _this5.categoryFilterActive ? _this5.grainsPerVisiblePeak : peak.grains.length;\n        for (var j = 0; j < peak.grains.length; j++) {\n          var grain = peak.grains[j];\n          if (!grain || !grain.userData) continue;\n          if (_this5.categoryFilterActive && grain.visible === false || j >= GRAIN_THRESHOLD) continue;\n          var _grain$userData = grain.userData,\n            heightFactor = _grain$userData.heightFactor,\n            angle = _grain$userData.angle,\n            randomization = _grain$userData.randomization;\n          if (!heightFactor || !angle || !randomization) continue;\n          var t = performance.now() * 0.001;\n          var minRadius = 0.8 * _this5.baseRadius;\n          var maxRadius = _this5.baseRadius * 2.5;\n          var baseRadius = minRadius + (1 - heightFactor) * (maxRadius - minRadius);\n          var wanderAngle = angle + Math.sin(t * (0.15 + 0.4 * randomization[0]) + j) * 2.5 + Math.cos(t * (0.2 + 0.3 * randomization[1]) + j * 0.5) * 1.8;\n          var wanderRadius = baseRadius + Math.sin(t * (0.12 + 0.2 * randomization[2]) + j * 0.3) * 0.4 + Math.cos(t * (0.1 + 0.25 * randomization[3]) + j * 0.25) * 0.5;\n          var wanderHeight = void 0;\n          if (_this5.evolvingActive && topY !== null) {\n            var baseY = typeof peak.evolveBaseY === 'number' ? peak.evolveBaseY : typeof _this5.evolveSessionBaseY === 'number' ? _this5.evolveSessionBaseY : 0;\n            var range = Math.max(0.1, topY - baseY); // ensure positive\n\n            var noise = (Math.sin(t * (0.18 + 0.25 * randomization[1]) + j * 0.2) * 0.12 + Math.cos(t * (0.22 + 0.15 * randomization[2]) + j * 0.15) * 0.08) * range * 0.2;\n            wanderHeight = baseY + heightFactor * range + noise;\n            // Clamp strictly within [baseY, topY]\n            if (wanderHeight > topY) wanderHeight = topY - 0.02;\n            if (wanderHeight < baseY) wanderHeight = baseY + 0.02;\n          } else {\n            // Default main-screen behavior\n            wanderHeight = heightFactor * smoothedHeight + Math.sin(t * (0.18 + 0.25 * randomization[1]) + j * 0.2) * 0.8 * smoothedHeight * 0.3 + Math.cos(t * (0.22 + 0.15 * randomization[2]) + j * 0.15) * 0.6 * smoothedHeight * 0.25;\n          }\n          var vagueTarget = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(peak.currentPyramidCenter.x + wanderRadius * Math.cos(wanderAngle), Math.max(0.1, wanderHeight), peak.currentPyramidCenter.z + wanderRadius * Math.sin(wanderAngle));\n          if (!grain.userData.velocity) grain.userData.velocity = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n          if (!grain.userData.acceleration) grain.userData.acceleration = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n          var toVague = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3().subVectors(vagueTarget, grain.position);\n          var springStrength = grain.userData.baseAccel * 0.12;\n          grain.userData.acceleration.copy(toVague).multiplyScalar(springStrength);\n          var fromCenter = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3().subVectors(grain.position, peak.currentPyramidCenter);\n          var distFromCenter = fromCenter.length();\n          if (distFromCenter > 0.001) {\n            var up = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(0, 1, 0);\n            var orbitDir = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3().crossVectors(fromCenter, up).normalize();\n            var orbitSpeed = 0.4 + 0.08 * randomization[0];\n            var orbitPhase = t * orbitSpeed + grain.userData.transitionSeed;\n            var orbitAmount = 0.15 + 0.12 * Math.sin(orbitPhase + j * 0.2);\n            if (!grain.userData.orbitDeviation || t - (grain.userData.lastDeviationTime || 0) > 1.5 + Math.random() * 1.5) {\n              grain.userData.orbitDeviation = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3((Math.random() - 0.5) * 0.15, (Math.random() - 0.5) * 0.25, (Math.random() - 0.5) * 0.2);\n              grain.userData.lastDeviationTime = t;\n            }\n            orbitDir.add(grain.userData.orbitDeviation.clone().multiplyScalar(0.3)).normalize();\n            grain.userData.acceleration.add(orbitDir.multiplyScalar(orbitAmount));\n            grain.userData.acceleration.y += Math.sin(orbitPhase + j * 0.3) * 0.03;\n          }\n          grain.userData.velocity.add(grain.userData.acceleration);\n          grain.userData.velocity.multiplyScalar(0.88);\n          var maxSpeed = grain.userData.maxSpeed * 1.8;\n          if (grain.userData.velocity.length() > maxSpeed) {\n            grain.userData.velocity.setLength(maxSpeed);\n          }\n          grain.position.add(grain.userData.velocity);\n        }\n      });\n\n      // Update solid positions\n      var minSolidLength = Math.min(this.peaks.length, this.peakSolids.length, this.previousHeights.length);\n      for (var _i3 = 0; _i3 < minSolidLength; _i3++) {\n        var _ref, _ref2, _solid$userData$solut, _solid$userData$solut2, _solid$userData$solut3, _solid$userData$solut4;\n        var solid = this.peakSolids[_i3];\n        var _peak = this.peaks[_i3];\n        var height = this.previousHeights[_i3];\n        if (!solid || !_peak || !_peak.currentPyramidCenter || typeof height !== 'number') continue;\n        if (this.categoryFilterActive && (_peak.categoryVisible === false || solid.visible === false)) continue;\n        solid.position.x = _peak.currentPyramidCenter.x;\n        solid.position.z = _peak.currentPyramidCenter.z;\n        if (!solid.userData.evolvingManualY) {\n          solid.position.y = height + 10;\n        }\n\n        // ADDED: Update category in userData to match solution\n        solid.userData.category = (_ref = (_ref2 = (_solid$userData$solut = (_solid$userData$solut2 = solid.userData.solution) === null || _solid$userData$solut2 === void 0 ? void 0 : _solid$userData$solut2.actual_category) !== null && _solid$userData$solut !== void 0 ? _solid$userData$solut : (_solid$userData$solut3 = solid.userData.solution) === null || _solid$userData$solut3 === void 0 ? void 0 : _solid$userData$solut3.category) !== null && _ref2 !== void 0 ? _ref2 : (_solid$userData$solut4 = solid.userData.solution) === null || _solid$userData$solut4 === void 0 ? void 0 : _solid$userData$solut4.assigned_category) !== null && _ref !== void 0 ? _ref : 'mid';\n      }\n\n      // Update solids' custom animations\n      var _iterator = _createForOfIteratorHelper(this.peakSolids),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _solid = _step.value;\n          if (_solid && _solid.userData && _solid.userData.update) {\n            var elapsed = performance.now() * 0.001;\n            _solid.userData.update(elapsed);\n          }\n        }\n\n        // Update grid lighting\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      this.updateGridLighting();\n    }\n  }, {\n    key: \"updateGridLighting\",\n    value: function updateGridLighting() {\n      var lightPositions = [];\n      var lightIntensities = [];\n      for (var i = 0; i < this.peakSolids.length; i++) {\n        var solid = this.peakSolids[i];\n        if (solid && solid.position && (!this.categoryFilterActive || solid.visible !== false)) {\n          // <--- respect flag\n          lightPositions.push(solid.position.x, solid.position.y, solid.position.z);\n          lightIntensities.push(1.5);\n        }\n      }\n      for (var _i4 = 0; _i4 < this.peaks.length; _i4 += 2) {\n        var peak = this.peaks[_i4];\n        if (peak && peak.currentPyramidCenter && lightIntensities.length < 20) {\n          lightPositions.push(peak.currentPyramidCenter.x, peak.currentPyramidCenter.y + this.previousHeights[_i4] * 0.5, peak.currentPyramidCenter.z);\n          lightIntensities.push(0.6);\n        }\n      }\n      while (lightPositions.length < 60) {\n        lightPositions.push(0);\n      }\n      while (lightIntensities.length < 20) {\n        lightIntensities.push(0);\n      }\n      if (this.scene.userData.dynamicGrid) {\n        var material = this.scene.userData.dynamicGrid.material;\n        var posArray = new Float32Array(lightPositions);\n        var intArray = new Float32Array(lightIntensities);\n        material.uniforms.lightPositions.value = posArray;\n        material.uniforms.lightIntensities.value = intArray;\n        material.uniforms.maxLights.value = Math.min(lightIntensities.filter(function (i) {\n          return i > 0;\n        }).length, 20);\n        material.needsUpdate = true;\n      }\n    }\n  }, {\n    key: \"getPeakPositions\",\n    value: function getPeakPositions() {\n      var positions = [];\n      for (var i = 0; i < this.peaks.length; i++) {\n        if (this.peaks[i] && this.peaks[i].currentPyramidCenter) {\n          positions.push({\n            index: i,\n            position: this.peaks[i].currentPyramidCenter.clone()\n          });\n        }\n      }\n      return positions;\n    }\n  }, {\n    key: \"getSolids\",\n    value: function getSolids() {\n      // Guard clause - return empty array if not initialized\n      if (!this.peakSolids || this.peakSolids.length === 0) {\n        return [];\n      }\n      return this.peakSolids;\n    }\n  }, {\n    key: \"updatePeaks\",\n    value: function updatePeaks() {\n      if (this.stopAllMovement) {\n        return;\n      }\n    }\n  }, {\n    key: \"updateSolidPositions\",\n    value: function updateSolidPositions() {\n      if (this.stopAllMovement) {\n        return;\n      }\n    }\n  }, {\n    key: \"applyCategoryVisibilityBySolids\",\n    value: function applyCategoryVisibilityBySolids(visibleSolids) {\n      var grainsPerSolution = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 300;\n      this.categoryFilterActive = true;\n      this.grainsPerVisiblePeak = grainsPerSolution;\n      var visibleSet = new Set(visibleSolids);\n      for (var i = 0; i < this.peaks.length; i++) {\n        var peak = this.peaks[i];\n        var solid = this.peakSolids[i];\n        var isVisible = solid ? visibleSet.has(solid) : false;\n        if (solid) solid.visible = isVisible;\n        if (peak) {\n          peak.categoryVisible = isVisible;\n          if (Array.isArray(peak.grains)) {\n            for (var g = 0; g < peak.grains.length; g++) {\n              var grain = peak.grains[g];\n              if (!grain) continue;\n              grain.visible = isVisible && g < grainsPerSolution;\n            }\n          }\n        }\n      }\n    }\n\n    // Restore everything (deactivate filter)\n  }, {\n    key: \"clearCategoryVisibility\",\n    value: function clearCategoryVisibility() {\n      this.categoryFilterActive = false;\n      for (var i = 0; i < this.peaks.length; i++) {\n        var peak = this.peaks[i];\n        var solid = this.peakSolids[i];\n        if (solid) solid.visible = true;\n        if (peak) {\n          peak.categoryVisible = true;\n          if (Array.isArray(peak.grains)) {\n            for (var g = 0; g < peak.grains.length; g++) {\n              var grain = peak.grains[g];\n              if (grain) grain.visible = true;\n            }\n          }\n        }\n      }\n    }\n\n    // Find and establish pairs\n  }, {\n    key: \"_findPairs\",\n    value: function _findPairs() {\n      var M = this.motionSystem;\n\n      // Clear cooldowns and decay grace\n      for (var i = 0; i < this._pairStates.length; i++) {\n        var state = this._pairStates[i];\n        if (state.cooldown > 0) state.cooldown--;\n        if (state.breakGrace > 0) {\n          state.breakGrace--;\n          if (state.breakGrace === 0) state.breakPartner = -1;\n        }\n      }\n\n      // NEW: Rebuild spatial grid (O(N))\n      this.spatialGrid.clear();\n      for (var _i5 = 0; _i5 < this.peaks.length; _i5++) {\n        var peak = this.peaks[_i5];\n        if (peak !== null && peak !== void 0 && peak.currentPyramidCenter) {\n          this.spatialGrid.insert(_i5, peak.currentPyramidCenter);\n        }\n      }\n\n      // Check existing pairs for distance-based breaks (O(P) where P = number of pairs)\n      for (var _i6 = 0; _i6 < this._pairStates.length; _i6++) {\n        var _this$peaks$_i, _this$peaks$partnerId, _M$pairKeepRadius;\n        var _state = this._pairStates[_i6];\n        var partnerIdx = _state.partner;\n        if (partnerIdx === -1) continue;\n        var partnerState = this._pairStates[partnerIdx];\n        var A = (_this$peaks$_i = this.peaks[_i6]) === null || _this$peaks$_i === void 0 ? void 0 : _this$peaks$_i.currentPyramidCenter;\n        var B = (_this$peaks$partnerId = this.peaks[partnerIdx]) === null || _this$peaks$partnerId === void 0 ? void 0 : _this$peaks$partnerId.currentPyramidCenter;\n        if (!A || !B || !partnerState) continue;\n        var dist = A.distanceTo(B);\n        if (dist > ((_M$pairKeepRadius = M.pairKeepRadius) !== null && _M$pairKeepRadius !== void 0 ? _M$pairKeepRadius : Infinity)) {\n          var grace = M.breakGraceFrames || 0;\n\n          // Set grace on both\n          _state.breakGrace = grace;\n          _state.breakPartner = partnerIdx;\n          partnerState.breakGrace = grace;\n          partnerState.breakPartner = _i6;\n\n          // Symmetric unpair + cooldown\n          _state.partner = -1;\n          _state.frames = 0;\n          _state.cooldown = M.pairCooldown;\n          partnerState.partner = -1;\n          partnerState.frames = 0;\n          partnerState.cooldown = M.pairCooldown;\n        }\n      }\n\n      // Try to form new pairs using spatial grid (O(N * k) where k = avg neighbors per cell)\n      for (var _i7 = 0; _i7 < this.peaks.length; _i7++) {\n        var _solidA$userData$solu, _solidA$userData, _solidA$userData2;\n        var _state2 = this._pairStates[_i7];\n        if (_state2.partner !== -1 || _state2.cooldown > 0) continue;\n        var peakA = this.peaks[_i7];\n        if (!peakA || !peakA.currentPyramidCenter) continue;\n        var solidA = this.peakSolids[_i7];\n        var catA = (_solidA$userData$solu = solidA === null || solidA === void 0 || (_solidA$userData = solidA.userData) === null || _solidA$userData === void 0 || (_solidA$userData = _solidA$userData.solution) === null || _solidA$userData === void 0 ? void 0 : _solidA$userData.actual_category) !== null && _solidA$userData$solu !== void 0 ? _solidA$userData$solu : solidA === null || solidA === void 0 || (_solidA$userData2 = solidA.userData) === null || _solidA$userData2 === void 0 || (_solidA$userData2 = _solidA$userData2.solution) === null || _solidA$userData2 === void 0 ? void 0 : _solidA$userData2.assigned_category;\n        if (!catA) continue;\n        var bestPartner = -1;\n        var bestDist = M.pairFormRadius;\n\n        // NEW: Only check nearby peaks (spatial query)\n        var nearbyIndices = this.spatialGrid.getNearby(peakA.currentPyramidCenter, M.pairFormRadius);\n        var _iterator2 = _createForOfIteratorHelper(nearbyIndices),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var _solidB$userData$solu, _solidB$userData, _solidB$userData2;\n            var j = _step2.value;\n            if (_i7 === j) continue;\n            var stB = this._pairStates[j];\n            if (stB.partner !== -1 || stB.cooldown > 0) continue;\n            var peakB = this.peaks[j];\n            if (!peakB || !peakB.currentPyramidCenter) continue;\n            var solidB = this.peakSolids[j];\n            var catB = (_solidB$userData$solu = solidB === null || solidB === void 0 || (_solidB$userData = solidB.userData) === null || _solidB$userData === void 0 || (_solidB$userData = _solidB$userData.solution) === null || _solidB$userData === void 0 ? void 0 : _solidB$userData.actual_category) !== null && _solidB$userData$solu !== void 0 ? _solidB$userData$solu : solidB === null || solidB === void 0 || (_solidB$userData2 = solidB.userData) === null || _solidB$userData2 === void 0 || (_solidB$userData2 = _solidB$userData2.solution) === null || _solidB$userData2 === void 0 ? void 0 : _solidB$userData2.assigned_category;\n            if (!(catB && (complementary_map[catA] === catB || complementary_map[catB] === catA))) continue;\n            var _dist = peakA.currentPyramidCenter.distanceTo(peakB.currentPyramidCenter);\n            if (_dist <= bestDist) {\n              bestDist = _dist;\n              bestPartner = j;\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n        if (bestPartner !== -1) {\n          _state2.partner = bestPartner;\n          _state2.frames = 0;\n          this._pairStates[bestPartner].partner = _i7;\n          this._pairStates[bestPartner].frames = 0;\n          var pairIndex = Math.min(_i7, bestPartner);\n          if (!this._pairDirections[pairIndex]) {\n            this._pairDirections[pairIndex] = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(Math.random() - 0.5, 0, Math.random() - 0.5).normalize();\n          }\n        }\n      }\n    }\n\n    // Apply repulsion/attraction forces\n  }, {\n    key: \"_applyRepulsionForces\",\n    value: function _applyRepulsionForces(index, forceOffset) {\n      var peak = this.peaks[index];\n      var M = this.motionSystem;\n      var myState = this._pairStates[index];\n      var myPartner = myState === null || myState === void 0 ? void 0 : myState.partner;\n\n      // NEW: Only check nearby peaks (spatial query) - REPLACES the full loop\n      var searchRadius = Math.max(M.minSeparation, M.complementaryRange);\n      var nearbyIndices = this.spatialGrid.getNearby(peak.currentPyramidCenter, searchRadius);\n\n      // CHANGED: Loop only through nearby peaks instead of ALL peaks\n      var _iterator3 = _createForOfIteratorHelper(nearbyIndices),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var j = _step3.value;\n          if (index === j) continue;\n          var other = this.peaks[j];\n          if (!other || !other.currentPyramidCenter) continue;\n          var delta = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3().subVectors(peak.currentPyramidCenter, other.currentPyramidCenter);\n          var dist = delta.length();\n          if (dist < 0.0001) continue;\n\n          // Fade interactions with the most-recent ex-partner after break\n          var graceScale = 1.0;\n          if (myState && myState.breakGrace > 0 && j === myState.breakPartner) {\n            var t = myState.breakGrace / Math.max(1, M.breakGraceFrames);\n            graceScale = 1 - t;\n          }\n\n          // Reduce repulsion between paired members\n          var repulsionScale = 1.0;\n          if (myPartner !== -1 && j === myPartner) {\n            repulsionScale = 0.4;\n          }\n\n          // Repulsion\n          if (dist < M.minSeparation) {\n            var push = (1 - dist / M.minSeparation) * M.repulsionStrength * M.repulsionWeight * graceScale * repulsionScale;\n            forceOffset.addScaledVector(delta.normalize(), push * M.minSeparation);\n          }\n\n          // Complementary attraction\n          var solidA = this.peakSolids[index];\n          var solidB = this.peakSolids[j];\n          if (solidA && solidB) {\n            var _solidA$userData3, _solidB$userData3;\n            var catA = (_solidA$userData3 = solidA.userData) === null || _solidA$userData3 === void 0 || (_solidA$userData3 = _solidA$userData3.solution) === null || _solidA$userData3 === void 0 ? void 0 : _solidA$userData3.actual_category;\n            var catB = (_solidB$userData3 = solidB.userData) === null || _solidB$userData3 === void 0 || (_solidB$userData3 = _solidB$userData3.solution) === null || _solidB$userData3 === void 0 ? void 0 : _solidB$userData3.actual_category;\n            if (catA && catB && (complementary_map[catA] === catB || complementary_map[catB] === catA)) {\n              if (myPartner !== -1 && j !== myPartner) continue;\n              var inner = M.minSeparation * 1.2;\n              if (dist < M.complementaryRange && dist > inner) {\n                var _t = (dist - inner) / Math.max(1e-6, M.complementaryRange - inner);\n                _t = Math.min(Math.max(_t, 0), 1);\n                var smooth = (1 - _t) * (1 - _t);\n                var pull = M.complementaryPull * M.attractionWeight * smooth * graceScale;\n                forceOffset.addScaledVector(delta.normalize(), -pull * M.minSeparation);\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    }\n\n    // Apply pairing forces\n  }, {\n    key: \"_applyPairingForces\",\n    value: function _applyPairingForces(index, forceOffset) {\n      var peak = this.peaks[index];\n      var state = this._pairStates[index];\n      var M = this.motionSystem;\n      while (this._pairDirections.length < this.peaks.length) {\n        this._pairDirections.push(new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(Math.random() - 0.5, 0, Math.random() - 0.5).normalize());\n      }\n      if (state.partner !== -1) {\n        state.frames++;\n        var partner = this.peaks[state.partner];\n        if (!(partner !== null && partner !== void 0 && partner.currentPyramidCenter)) return;\n        var toPartner = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3().subVectors(partner.currentPyramidCenter, peak.currentPyramidCenter);\n        var dist = toPartner.length();\n        if (dist < 1e-6) return;\n        var u = toPartner.normalize();\n\n        // === BOIDS FLOCKING: 3 forces ===\n\n        // 1. SEPARATION: maintain desired spacing\n        var separationError = dist - M.pairDesiredSeparation;\n        if (dist < M.pairDesiredSeparation) {\n          // Too close: push apart\n          var proximity = 1 - dist / M.pairDesiredSeparation; // 1 at overlap, 0 at desired\n          var separationForce = proximity * M.pairSeparationStrength * M.pairingWeight;\n          forceOffset.addScaledVector(u, -separationForce); // push away\n        } else if (dist > M.pairDesiredSeparation * 1.5) {\n          // Too far: pull together (cohesion kicks in)\n          var excess = dist - M.pairDesiredSeparation;\n          var _cohesionForce = excess / M.pairDesiredSeparation * M.pairSeparationStrength * 0.5 * M.pairingWeight;\n          forceOffset.addScaledVector(u, _cohesionForce); // pull closer\n        }\n\n        // 2. COHESION: pull toward shared center (explicit flocking behavior)\n        var midpoint = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3().addVectors(peak.currentPyramidCenter, partner.currentPyramidCenter).multiplyScalar(0.5);\n        var toMidpoint = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3().subVectors(midpoint, peak.currentPyramidCenter);\n        var cohesionForce = M.pairCohesionStrength * M.pairingWeight;\n        forceOffset.addScaledVector(toMidpoint.normalize(), cohesionForce);\n\n        // 3. ALIGNMENT: match heading with partner\n        var pairIndex = Math.min(index, state.partner);\n        var heading = this._pairDirections[pairIndex];\n\n        // Update shared heading (only once per pair)\n        if (index === pairIndex) {\n          // Desired heading = tangent to circular motion around origin\n          var center = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3().addVectors(peak.currentPyramidCenter, partner.currentPyramidCenter).multiplyScalar(0.5);\n          var radial = center.clone().setY(0);\n          var tangent = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(1, 0, 0);\n          if (radial.lengthSq() > 1e-6) {\n            tangent.crossVectors(radial, new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(0, 1, 0)).normalize();\n          }\n\n          // Blend LESS with actual velocities (they lag behind desired heading)\n          var myVel = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3().subVectors(peak.currentPyramidCenter, this._lastPositions[index] || peak.currentPyramidCenter);\n          var partnerVel = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3().subVectors(partner.currentPyramidCenter, this._lastPositions[state.partner] || partner.currentPyramidCenter);\n          var avgVel = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3().addVectors(myVel, partnerVel);\n          if (avgVel.lengthSq() > 1e-6) {\n            // CHANGED: 85% tangent, 15% actual velocity (was 60/40)\n            // This prioritizes the desired direction over current momentum\n            tangent.multiplyScalar(M.headingTangentWeight || 0.85).addScaledVector(avgVel.normalize(), M.headingVelocityWeight || 0.15).normalize();\n          }\n\n          // Occasional jitter\n          if (state.frames % M.pairJitterInterval === 0) {\n            var jitterRad = M.pairHeadingJitter * Math.PI / 180 * (Math.random() - 0.5);\n            var cos = Math.cos(jitterRad);\n            var sin = Math.sin(jitterRad);\n            tangent.set(tangent.x * cos - tangent.z * sin, 0, tangent.x * sin + tangent.z * cos).normalize();\n          }\n\n          // Smooth heading update\n          heading.lerp(tangent, M.pairHeadingSmoothing).normalize();\n        }\n\n        // Apply alignment and travel forces\n        var easeProgress = Math.min(1, state.frames / Math.max(1, M.pairEaseFrames));\n        var ease = easeProgress * easeProgress * (3 - 2 * easeProgress);\n\n        // CHANGED: Apply forces separately with different weights\n        var alignForce = ease * M.pairAlignmentStrength * M.pairingWeight;\n        var travelForce = ease * M.pairTravelSpeed * M.pairingWeight;\n\n        // Alignment: steer toward heading\n        forceOffset.addScaledVector(heading, alignForce);\n\n        // Travel: move forward along heading\n        forceOffset.addScaledVector(heading, travelForce);\n\n        // Minimal wander (don't break alignment)\n        forceOffset.x += (Math.random() - 0.5) * M.wanderInPair * 0.5; // REDUCED influence (was 1.0)\n        forceOffset.z += (Math.random() - 0.5) * M.wanderInPair * 0.5;\n\n        // Check for break\n        if (state.frames > M.pairMinFrames && Math.random() < M.pairBreakProb) {\n          this._breakPair(index, state.partner, heading.clone(), ease);\n        }\n      } else {\n        var _state$breakHeading;\n        // Solo: fade out pair forces after break\n        if (state.breakFade > 0 && ((_state$breakHeading = state.breakHeading) === null || _state$breakHeading === void 0 ? void 0 : _state$breakHeading.lengthSq()) > 1e-6) {\n          var fadeProgress = state.breakFade / Math.max(1, M.breakGraceFrames);\n          var storedEase = state.breakEase || 1.0;\n          var _alignForce = fadeProgress * storedEase * M.pairAlignmentStrength * M.pairingWeight;\n          var _travelForce = fadeProgress * storedEase * M.pairTravelSpeed * M.pairingWeight;\n          forceOffset.addScaledVector(state.breakHeading, _alignForce + _travelForce);\n          state.breakFade--;\n        }\n\n        // Exploration: ramp up as pair forces fade\n        var explorationScale = state.breakFade > 0 ? 1 - state.breakFade / Math.max(1, M.breakGraceFrames) : 1.0;\n        forceOffset.x += (Math.random() - 0.5) * M.wanderStrength * explorationScale;\n        forceOffset.z += (Math.random() - 0.5) * M.wanderStrength * explorationScale;\n      }\n    }\n    // Helper method to break a pair cleanly\n  }, {\n    key: \"_breakPair\",\n    value: function _breakPair(indexA, indexB, currentHeading, currentEase) {\n      var M = this.motionSystem;\n      var grace = M.breakGraceFrames || 0;\n\n      // Break member A\n      var stateA = this._pairStates[indexA];\n      stateA.partner = -1;\n      stateA.frames = 0;\n      stateA.cooldown = M.pairCooldown;\n      stateA.breakGrace = grace;\n      stateA.breakPartner = indexB;\n      stateA.breakFade = grace;\n      stateA.breakHeading.copy(currentHeading);\n      stateA.breakEase = currentEase;\n      stateA.breakThisFrame = true;\n\n      // Break member B\n      var stateB = this._pairStates[indexB];\n      if (stateB) {\n        stateB.partner = -1;\n        stateB.frames = 0;\n        stateB.cooldown = M.pairCooldown;\n        stateB.breakGrace = grace;\n        stateB.breakPartner = indexA;\n        stateB.breakFade = grace;\n        stateB.breakHeading.copy(currentHeading);\n        stateB.breakEase = currentEase;\n        stateB.breakThisFrame = true;\n      }\n    }\n    // Apply exploration forces  \n  }, {\n    key: \"_applyExplorationForces\",\n    value: function _applyExplorationForces(index, forceOffset, time) {\n      var peak = this.peaks[index];\n      var M = this.motionSystem;\n      var state = this._pairStates[index];\n      var isPaired = state && state.partner !== -1;\n\n      // 1. REDUCE EXPLORATION WHEN PAIRED (so pair heading dominates)\n      var scale = isPaired ? M.explorationPairedScale : 1.0;\n\n      // 2. CIRCULAR DRIFT (orbit around origin)\n      var seed = peak.exploreSeed || 0;\n      var orbitAngle = time * 0.07 + seed * 0.013;\n      var orbitRadius = 40;\n      var circularDrift = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(Math.cos(orbitAngle) * orbitRadius, 0, Math.sin(orbitAngle) * orbitRadius);\n\n      // Apply as force (not position), scaled by circular bias\n      var circularForce = M.circularBias * M.explorationWeight * scale;\n      forceOffset.addScaledVector(circularDrift.normalize(), circularForce);\n\n      // 3. NOISE WANDER (random walk)\n      var noisePhase = time * 0.12 + seed * 0.3;\n      var noiseX = Math.sin(noisePhase * 1.31 + seed * 0.2);\n      var noiseZ = Math.cos(noisePhase * 1.17 + seed * 0.35);\n      forceOffset.x += noiseX * M.wanderStrength * scale;\n      forceOffset.z += noiseZ * M.wanderStrength * scale;\n\n      // 4. BOUNDARY FORCES\n      var radial = peak.currentPyramidCenter.clone().setY(0);\n      var radialLen = radial.length();\n\n      // Soft outer boundary (push inward when too far)\n      if (radialLen > M.maxRange) {\n        var excess = radialLen - M.maxRange;\n        var pushInward = excess * 0.05;\n        forceOffset.addScaledVector(radial.normalize(), -pushInward);\n      }\n\n      // Center avoidance (push outward when too close to origin)\n      if (radialLen < M.avoidCenterRadius) {\n        var proximity = 1 - radialLen / M.avoidCenterRadius; // 1 at center, 0 at radius\n        var pushOutward = proximity * proximity * M.avoidCenterStrength; // quadratic falloff\n\n        if (radialLen > 1e-4) {\n          forceOffset.addScaledVector(radial.normalize(), pushOutward);\n        } else {\n          // Exactly at center - pick random outward direction\n          var randomDir = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(Math.random() - 0.5, 0, Math.random() - 0.5).normalize();\n          forceOffset.addScaledVector(randomDir, M.avoidCenterStrength);\n        }\n      }\n    }\n  }], [{\n    key: \"create\",\n    value: function create(scene) {\n      var baseRadius = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n      return new ParticleSystem(scene, baseRadius);\n    }\n  }]);\n}();\n\n//# sourceURL=webpack://sound-particle-visualization/./src/components/ParticleSystem.js?");

/***/ }),

/***/ "./src/components/PythonCommunication.js":
/*!***********************************************!*\
  !*** ./src/components/PythonCommunication.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PythonCommunication: () => (/* binding */ PythonCommunication)\n/* harmony export */ });\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar PythonCommunication = /*#__PURE__*/function () {\n  function PythonCommunication(particleSystem) {\n    var _this = this;\n    var onGenerationData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    var onConnectionReady = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    var onRegenerationStart = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    _classCallCheck(this, PythonCommunication);\n    console.log('üêç Initializing Python Communication...');\n    this.particleSystem = particleSystem;\n    this.websocket = null;\n    this.currentGeneration = null;\n    this.currentSolutions = [];\n    this.connectionStatus = 'connecting';\n    this.onGenerationData = onGenerationData;\n    this.onConnectionReady = onConnectionReady;\n    this.onRegenerationStart = onRegenerationStart;\n    this.dataReceived = false;\n    this._lastFeedbackTime = 0; // FIXED: Initialize to 0 instead of null\n\n    this.connectToPython();\n    this.connectionCheckInterval = setInterval(function () {\n      _this.logConnectionStatus();\n    }, 5000);\n  }\n  return _createClass(PythonCommunication, [{\n    key: \"logConnectionStatus\",\n    value: function logConnectionStatus() {\n      console.log('üîç Connection Status Check:');\n      console.log('  - WebSocket exists:', !!this.websocket);\n      console.log('  - WebSocket state:', this.websocket ? this.websocket.readyState : 'N/A');\n      console.log('  - Current status:', this.connectionStatus);\n      console.log('  - Solutions received:', this.currentSolutions.length);\n    }\n  }, {\n    key: \"connectToPython\",\n    value: function connectToPython() {\n      var _this2 = this;\n      try {\n        console.log('üêç Attempting to connect to Python WebSocket server at ws://localhost:8765');\n        this.websocket = new WebSocket('wss://parodistically-nonfluidic-clarice.ngrok-free.dev');\n        this.websocket.onopen = function () {\n          console.log('‚úÖ Connected to Python evolution engine');\n          _this2.updateConnectionStatus('connected');\n        };\n        this.websocket.onmessage = function (event) {\n          try {\n            var data = JSON.parse(event.data);\n            console.log('üì® Message received:', data.type, \"Generation \".concat(data.generation));\n            _this2.handlePythonMessage(data);\n          } catch (error) {\n            console.error('‚ùå Failed to parse JSON message:', error);\n          }\n        };\n        this.websocket.onclose = function (event) {\n          console.log('üêç WebSocket connection closed');\n          _this2.updateConnectionStatus('disconnected');\n          setTimeout(function () {\n            return _this2.connectToPython();\n          }, 3000);\n        };\n        this.websocket.onerror = function (error) {\n          console.error('üêç WebSocket error:', error);\n          _this2.updateConnectionStatus('error');\n        };\n      } catch (error) {\n        console.error('üêç Failed to create WebSocket connection:', error);\n        this.updateConnectionStatus('error');\n      }\n    }\n  }, {\n    key: \"handlePythonMessage\",\n    value: function handlePythonMessage(data) {\n      switch (data.type) {\n        case 'generation_data':\n          this.handleGenerationData(data);\n          break;\n        case 'evolution_complete':\n          this.handleEvolutionComplete(data);\n          break;\n        case 'error':\n          console.error('üêç Python error:', data.message);\n          break;\n      }\n    }\n  }, {\n    key: \"handleGenerationData\",\n    value: function handleGenerationData(data) {\n      var _data$solutions,\n        _this3 = this;\n      console.log(\"\\uD83E\\uDDEC Processing generation \".concat(data.generation, \" with \").concat(((_data$solutions = data.solutions) === null || _data$solutions === void 0 ? void 0 : _data$solutions.length) || 0, \" solutions\"));\n\n      // Validate data\n      if (!data.solutions || !Array.isArray(data.solutions) || data.solutions.length === 0) {\n        console.error('‚ùå Invalid generation data - no solutions:', data);\n        return;\n      }\n\n      // FIXED: Add generation number to each solution for unique identification\n      data.solutions = data.solutions.map(function (sol) {\n        return _objectSpread(_objectSpread({}, sol), {}, {\n          generation: data.generation\n        });\n      });\n\n      // NEW: Force exit to main scene before processing new generation\n      var modeManager = window.modeManager;\n      if (modeManager) {\n        var isInMode = modeManager.isActive('save') || modeManager.isActive('evolve') || modeManager.isActive('library');\n        if (isInMode) {\n          console.log('‚ö†Ô∏è New generation arrived while in mode - forcing exit to main scene');\n\n          // Force exit all modes synchronously\n          try {\n            var _modeManager$save, _modeManager$evolve, _modeManager$library, _modeManager$_closeTo;\n            if ((_modeManager$save = modeManager.save) !== null && _modeManager$save !== void 0 && _modeManager$save.isSaveMode) {\n              var _modeManager$save$for, _modeManager$save2, _modeManager$save$exi, _modeManager$save3;\n              (_modeManager$save$for = (_modeManager$save2 = modeManager.save).forceReset) === null || _modeManager$save$for === void 0 || _modeManager$save$for.call(_modeManager$save2, {\n                restoreMaterials: true\n              });\n              (_modeManager$save$exi = (_modeManager$save3 = modeManager.save).exitSaveMode) === null || _modeManager$save$exi === void 0 || _modeManager$save$exi.call(_modeManager$save3);\n            }\n            if ((_modeManager$evolve = modeManager.evolve) !== null && _modeManager$evolve !== void 0 && _modeManager$evolve.isEvolvingMode) {\n              var _modeManager$evolve$e, _modeManager$evolve2;\n              (_modeManager$evolve$e = (_modeManager$evolve2 = modeManager.evolve).exitEvolvingMode) === null || _modeManager$evolve$e === void 0 || _modeManager$evolve$e.call(_modeManager$evolve2);\n            }\n            if ((_modeManager$library = modeManager.library) !== null && _modeManager$library !== void 0 && _modeManager$library.inSpace) {\n              var _modeManager$library$, _modeManager$library2;\n              (_modeManager$library$ = (_modeManager$library2 = modeManager.library).exitSpace) === null || _modeManager$library$ === void 0 || _modeManager$library$.call(_modeManager$library2);\n            }\n\n            // Clear audio and normalize to main\n            (_modeManager$_closeTo = modeManager._closeToMain) === null || _modeManager$_closeTo === void 0 || _modeManager$_closeTo.call(modeManager);\n          } catch (err) {\n            console.error('Failed to exit modes:', err);\n          }\n\n          // Wait a frame to ensure cleanup completes\n          setTimeout(function () {\n            _this3._processGenerationData(data);\n          }, 100);\n          return;\n        }\n      }\n\n      // Process immediately if already in main scene\n      this._processGenerationData(data);\n    }\n\n    // NEW: Separate method for actual data processing\n  }, {\n    key: \"_processGenerationData\",\n    value: function _processGenerationData(data) {\n      // CRITICAL: Reset click tracking for new generation\n      if (window.lastClickedSolidId !== undefined) {\n        console.log('üîÑ Resetting click tracking for new generation');\n        window.lastClickedSolidId = null;\n      }\n      this.currentGeneration = data;\n      this.currentSolutions = data.solutions;\n      this.dataReceived = true;\n      console.log('‚úÖ Generation data validated:', {\n        generation: data.generation,\n        solutionCount: data.solutions.length,\n        firstSolution: data.solutions[0]\n      });\n\n      // NEW: Notify that regeneration is starting (show loading screen)\n      if (typeof this.onRegenerationStart === 'function') {\n        this.onRegenerationStart(data);\n      }\n\n      // Update visuals\n      this.updateSolidsFromGeneration(data);\n\n      // Notify callback (audio system) - will hide loading screen after audio loads\n      if (typeof this.onGenerationData === 'function') {\n        console.log('üì¢ Calling onGenerationData callback...');\n        this.onGenerationData(data);\n      }\n    }\n  }, {\n    key: \"updateSolidsFromGeneration\",\n    value: function updateSolidsFromGeneration(generationData) {\n      var solutions = generationData.solutions;\n      console.log(\"\\uD83C\\uDFA8 Updating \".concat(solutions.length, \" solids from generation data\"));\n      this.currentSolutions = solutions;\n      this.particleSystem.regenerateWithSolutions(solutions);\n    }\n  }, {\n    key: \"updateConnectionStatus\",\n    value: function updateConnectionStatus(status) {\n      this.connectionStatus = status;\n      console.log(\"\\uD83D\\uDD0C Connection status: \".concat(status));\n    }\n\n    // **UTILITY METHODS (keep existing)**\n  }, {\n    key: \"getCurrentGeneration\",\n    value: function getCurrentGeneration() {\n      return this.currentGeneration;\n    }\n  }, {\n    key: \"getCurrentSolutions\",\n    value: function getCurrentSolutions() {\n      return this.currentSolutions;\n    }\n  }, {\n    key: \"getSolutionById\",\n    value: function getSolutionById(id) {\n      return this.currentSolutions.find(function (solution) {\n        return solution.id === id;\n      });\n    }\n  }, {\n    key: \"getSolutionByIndex\",\n    value: function getSolutionByIndex(index) {\n      return this.currentSolutions[index] || null;\n    }\n  }, {\n    key: \"isConnected\",\n    value: function isConnected() {\n      return this.connectionStatus === 'connected' && this.websocket && this.websocket.readyState === WebSocket.OPEN;\n    }\n  }, {\n    key: \"sendUserFeedback\",\n    value: function sendUserFeedback(feedbackData) {\n      if (!this.isConnected()) {\n        console.warn('‚ö†Ô∏è WS not connected. Skipping sendUserFeedback.');\n        return false;\n      }\n\n      // REMOVED: window.__modeTransitioning check (handled in EvolvingUI instead)\n\n      // Check if this is a duplicate request (within 500ms)\n      var now = Date.now();\n      if (this._lastFeedbackTime && now - this._lastFeedbackTime < 500) {\n        console.warn('‚ö†Ô∏è Skipping duplicate feedback request (last: ' + (now - this._lastFeedbackTime) + 'ms ago)');\n        return false;\n      }\n\n      // Validate feedback data\n      if (!feedbackData || _typeof(feedbackData) !== 'object') {\n        console.error('‚ùå Invalid feedback data:', feedbackData);\n        return false;\n      }\n\n      // CRITICAL: Check if this is actually a feedback action (not a random button click)\n      if (feedbackData.action !== 'user_feedback') {\n        console.warn('‚ö†Ô∏è Invalid action in feedback data:', feedbackData.action);\n        return false;\n      }\n      this._lastFeedbackTime = now;\n      var payload = _objectSpread(_objectSpread({\n        action: 'user_feedback'\n      }, feedbackData), {}, {\n        timestamp: now\n      });\n      try {\n        var json = JSON.stringify(payload);\n        console.log('‚û°Ô∏è WS SEND user_feedback:', payload);\n        this.websocket.send(json);\n        return true;\n      } catch (err) {\n        console.error('‚ùå Failed to serialize feedback payload:', err, feedbackData);\n        return false;\n      }\n    }\n  }, {\n    key: \"requestEvolution\",\n    value: function requestEvolution(category) {\n      var _this$currentGenerati;\n      if (!this.isConnected()) return false;\n      this.websocket.send(JSON.stringify({\n        action: 'evolve_generation',\n        category: category,\n        generation: ((_this$currentGenerati = this.currentGeneration) === null || _this$currentGenerati === void 0 ? void 0 : _this$currentGenerati.generation) || 0,\n        timestamp: Date.now()\n      }));\n      return true;\n    }\n  }]);\n}();\n\n//# sourceURL=webpack://sound-particle-visualization/./src/components/PythonCommunication.js?");

/***/ }),

/***/ "./src/components/SaveMode.js":
/*!************************************!*\
  !*** ./src/components/SaveMode.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SaveMode: () => (/* binding */ SaveMode)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n/* harmony import */ var _Library_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Library.js */ \"./src/components/Library.js\");\n/* harmony import */ var _Button_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Button.js */ \"./src/components/Button.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _createForOfIteratorHelper(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n // Add this line\n\nvar SaveMode = /*#__PURE__*/function () {\n  function SaveMode(mainRenderer, mainCamera, controls, particleSystem) {\n    var library = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n    _classCallCheck(this, SaveMode);\n    this.mainRenderer = mainRenderer;\n    this.mainCamera = mainCamera;\n    this.controls = controls;\n    this.particleSystem = particleSystem;\n    this.solidMeshes = this.particleSystem.getSolids ? this.particleSystem.getSolids() : [];\n    this.isSaveMode = false;\n    this.selectedSolid = null;\n    this.selectedSolidIndex = -1;\n    this.hoveredSolid = null;\n    this.hoveredSolidIndex = -1;\n    this.originalPositions = [];\n    this.saveToLibraryBtn = null;\n    this.saveCombinationBtn = null;\n    this.selectedSolids = [];\n    this.boundingBoxHelpers = []; // Store bounding box helpers\n    this._saveLabelTexture = null;\n    this._hoverCooldown = new WeakMap();\n    this._saveModePlayingIds = new Set();\n\n    // NEW: Cache materials IMMEDIATELY on construction (before any modifications)\n    this._globalMaterialCache = new WeakMap(); // mesh -> original material\n    this._cacheAllMaterialsNow();\n\n    // Track currently playing sound in Save mode\n    this._saveModePlayingId = null;\n    if (library) {\n      this.library = library;\n    } else {\n      console.error('No library provided to SaveMode');\n      return;\n    }\n    this.createSaveButton();\n    this.setupInteractions();\n  }\n\n  // NEW: Cache ALL materials immediately on construction\n  return _createClass(SaveMode, [{\n    key: \"_cacheAllMaterialsNow\",\n    value: function _cacheAllMaterialsNow() {\n      var _this$particleSystem,\n        _this = this;\n      if (!((_this$particleSystem = this.particleSystem) !== null && _this$particleSystem !== void 0 && _this$particleSystem.getSolids)) return;\n      var solids = this.particleSystem.getSolids();\n      solids.forEach(function (solid) {\n        solid.traverse(function (child) {\n          if (child.isMesh && !_this._globalMaterialCache.has(child)) {\n            // Store the ORIGINAL material (current state before ANY modifications)\n            _this._globalMaterialCache.set(child, child.material);\n          }\n        });\n      });\n      console.log('‚úÖ Global material cache initialized:', this._globalMaterialCache.size, 'meshes');\n    }\n  }, {\n    key: \"createSaveButton\",\n    value: function createSaveButton() {\n      this.saveBtn = new _Button_js__WEBPACK_IMPORTED_MODULE_1__.Button('SAVE', 'hamburger', function () {});\n\n      // NEW: Create close button for Save mode\n      this.createCloseButton();\n    }\n\n    // NEW: Create close button\n  }, {\n    key: \"createCloseButton\",\n    value: function createCloseButton() {\n      var _this2 = this;\n      this.closeBtn = document.createElement('button');\n      this.closeBtn.className = 'mode-close-btn save-mode-close';\n      this.closeBtn.innerHTML = '√ó';\n      this.closeBtn.title = 'Exit Save Mode';\n      this.closeBtn.style.display = 'none';\n      this.closeBtn.onclick = function () {\n        if (_this2.isSaveMode) {\n          _this2.exitSaveMode();\n          if (window.modeManager) {\n            window.modeManager.goTo(null); // FIXED: Use goTo instead of setMode\n          }\n        }\n      };\n      document.body.appendChild(this.closeBtn);\n    }\n  }, {\n    key: \"toggleSaveMode\",\n    value: function toggleSaveMode() {\n      if (this.isSaveMode) {\n        this.exitSaveMode();\n      } else {\n        this.enterSaveMode();\n      }\n    }\n  }, {\n    key: \"enterSaveMode\",\n    value: function enterSaveMode() {\n      var _this3 = this;\n      // Guard clause\n      if (!this.particleSystem.peaks || this.particleSystem.peaks.length === 0) {\n        console.warn('‚ö†Ô∏è Cannot enter save mode - no peaks initialized');\n        return;\n      }\n      console.log('üíæ Entering save mode');\n      this.isSaveMode = true;\n\n      // Fade out main soundscape and stop sequencing; clear any previous green highlights\n      try {\n        var _this$particleSystem2, _this$particleSystem3;\n        (_this$particleSystem2 = this.particleSystem) === null || _this$particleSystem2 === void 0 || (_this$particleSystem2 = _this$particleSystem2.surroundController) === null || _this$particleSystem2 === void 0 || _this$particleSystem2.startMode(500);\n        (_this$particleSystem3 = this.particleSystem) === null || _this$particleSystem3 === void 0 || (_this$particleSystem3 = _this$particleSystem3.surroundController) === null || _this$particleSystem3 === void 0 || _this$particleSystem3.clearAllGreenOutlines();\n      } catch (_unused) {}\n\n      // Reset Save-mode playing tracker\n      this._saveModePlayingId = null;\n      this.solidMeshes = this.particleSystem.getSolids();\n\n      // Refresh cache in case new solids were added\n      this._cacheAllMaterialsNow();\n      this._hoverCooldown = new WeakMap();\n      this.saveBtn.setSelected(true);\n      this.originalPositions = [];\n      for (var i = 0; i < this.solidMeshes.length; i++) {\n        var solid = this.solidMeshes[i];\n        this.originalPositions.push({\n          position: solid.position.clone(),\n          rotation: solid.rotation.clone()\n        });\n        solid.userData.frozenPosition = solid.position.clone();\n        solid.userData.frozenRotation = solid.rotation.clone();\n      }\n      this.particleSystem.targetLocked = true;\n      this.particleSystem.stopAllMovement = true;\n      this.particleSystem.peaks.forEach(function (peak, index) {\n        peak.lockedCenter = peak.currentPyramidCenter.clone();\n        peak.readyForNextMove = false;\n        peak.lockedHeight = _this3.particleSystem.previousHeights[index] || 5;\n        peak.frozen = true;\n      });\n      this.particleSystem.frozenSwarmPositions = this.particleSystem.peaks.map(function (peak) {\n        return peak.currentPyramidCenter.clone();\n      });\n      this.mainRenderer.domElement.addEventListener('click', this.onMouseClick);\n      this.mainRenderer.domElement.addEventListener('mousemove', this.onMouseMove);\n\n      // NEW: Show close button\n      if (this.closeBtn) {\n        this.closeBtn.style.display = 'block';\n      }\n      console.log('‚úÖ Entered Save Mode - All movement stopped, solids frozen in place');\n    }\n  }, {\n    key: \"exitSaveMode\",\n    value: function exitSaveMode() {\n      if (!this.isSaveMode) return;\n      console.log('üö™ Exiting Save Mode...');\n      this.isSaveMode = false;\n\n      // CRITICAL: Stop ALL audio FIRST\n      try {\n        var _this$particleSystem4;\n        (_this$particleSystem4 = this.particleSystem) === null || _this$particleSystem4 === void 0 || (_this$particleSystem4 = _this$particleSystem4.surroundController) === null || _this$particleSystem4 === void 0 || _this$particleSystem4.stopAllManualPlayback();\n      } catch (e) {\n        console.error('Failed to stop audio on save exit:', e);\n      }\n\n      // STEP 2: Update UI\n      this.saveBtn.setSelected(false);\n\n      // STEP 3: Remove event listeners\n      this.mainRenderer.domElement.removeEventListener('click', this.onMouseClick);\n      this.mainRenderer.domElement.removeEventListener('mousemove', this.onMouseMove);\n\n      // STEP 4: Clear hover state\n      this.hoveredSolid = null;\n      this.hoveredSolidIndex = -1;\n      this.mainRenderer.domElement.style.cursor = 'default';\n\n      // STEP 5: ATOMIC material cleanup\n      this._atomicMaterialCleanup();\n\n      // STEP 6: Unfreeze movement\n      this.particleSystem.targetLocked = false;\n      this.particleSystem.stopAllMovement = false;\n      this.particleSystem.peaks.forEach(function (peak) {\n        peak.frozen = false;\n        peak.readyForNextMove = true;\n      });\n\n      // STEP 7: Reset trackers\n      this._hoverCooldown = new WeakMap();\n      this._baseMaterialsCached = false;\n\n      // NEW: Hide close button\n      if (this.closeBtn) {\n        this.closeBtn.style.display = 'none';\n      }\n      console.log('‚úÖ Save Mode exited cleanly');\n    }\n\n    // NEW: Single atomic cleanup function that does EVERYTHING\n  }, {\n    key: \"_atomicMaterialCleanup\",\n    value: function _atomicMaterialCleanup() {\n      var _this4 = this;\n      console.log('üßπ Starting atomic material cleanup');\n\n      // Track what we're cleaning\n      var cleanedMeshes = 0;\n      var restoredMaterials = 0;\n      this.solidMeshes.forEach(function (solid) {\n        if (!solid) return;\n\n        // Remove UI elements for this solid\n        if (solid.userData.saveToLibraryBtn) {\n          solid.userData.saveToLibraryBtn.remove();\n          solid.userData.saveToLibraryBtn = null;\n        }\n        if (solid.userData.save3DIcon) {\n          _this4.particleSystem.scene.remove(solid.userData.save3DIcon);\n          solid.userData.save3DIcon = null;\n        }\n        if (solid.userData.saveConnectionLine) {\n          var _solid$userData$saveC, _solid$userData$saveC2;\n          _this4.particleSystem.scene.remove(solid.userData.saveConnectionLine);\n          _this4.particleSystem.scene.remove(solid.userData.saveConnectionLine);\n          (_solid$userData$saveC = solid.userData.saveConnectionLine.geometry) === null || _solid$userData$saveC === void 0 || _solid$userData$saveC.dispose();\n          (_solid$userData$saveC2 = solid.userData.saveConnectionLine.material) === null || _solid$userData$saveC2 === void 0 || _solid$userData$saveC2.dispose();\n          solid.userData.saveConnectionLine = null;\n        }\n        if (solid.userData.saveLabelSprite) {\n          solid.userData.saveLabelSprite = null;\n        }\n\n        // Clear flags\n        delete solid.userData.__saveModeSelected;\n\n        // Restore materials for all child meshes\n        solid.traverse(function (child) {\n          if (!child.isMesh) return;\n          cleanedMeshes++;\n\n          // Get the ORIGINAL cached material\n          var originalMaterial = _this4._globalMaterialCache.get(child);\n          if (originalMaterial) {\n            child.material = originalMaterial;\n            restoredMaterials++;\n          }\n\n          // Clean up CSS classes\n          if (child.element) {\n            child.element.classList.remove('selected-solid', 'hovered-solid', 'hovered-aura');\n          }\n\n          // Delete ALL temporary material references\n          delete child.userData.__saveModeMaterialTint;\n          delete child.userData.__saveModeMaterialOriginal;\n          delete child.userData.__surroundPlayOriginal;\n          delete child.userData.__surroundOriginalMaterial;\n          delete child.userData.__saveModeBaseMaterial;\n          delete child.userData.__saveModeOriginalMaterial;\n        });\n      });\n\n      // Clear selection array\n      this.selectedSolids = [];\n\n      // Remove combination button\n      if (this.saveCombinationBtn) {\n        this.saveCombinationBtn.remove();\n        this.saveCombinationBtn = null;\n      }\n      console.log(\"\\u2705 Cleaned \".concat(cleanedMeshes, \" meshes, restored \").concat(restoredMaterials, \" materials\"));\n    }\n  }, {\n    key: \"forceReset\",\n    value: function forceReset() {\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$restoreMaterials = _ref.restoreMaterials,\n        restoreMaterials = _ref$restoreMaterials === void 0 ? true : _ref$restoreMaterials;\n      this.clearHover();\n      this.clearAllSelections({\n        restoreMaterials: false\n      }); // Don't double-restore\n      if (restoreMaterials) {\n        this._restoreAllFromGlobalCache();\n      }\n      this._hoverCooldown = new WeakMap();\n      this.selectedSolids = [];\n    }\n\n    // NEW: Restore ALL materials from the global cache\n  }, {\n    key: \"createBoundingBoxes\",\n    value:\n    //Helper function to create Bounding boxes\n    function createBoundingBoxes() {\n      // Remove any existing bounding boxes first\n      this.removeBoundingBoxes();\n      for (var i = 0; i < this.solidMeshes.length; i++) {\n        var solid = this.solidMeshes[i];\n\n        // Calculate bounding box\n        var box = new three__WEBPACK_IMPORTED_MODULE_2__.Box3().setFromObject(solid);\n\n        // Create wireframe geometry for the bounding box\n        var size = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n        box.getSize(size);\n        var center = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n        box.getCenter(center);\n\n        // Create box geometry at origin\n        var boxGeometry = new three__WEBPACK_IMPORTED_MODULE_2__.BoxGeometry(size.x, size.y, size.z);\n\n        // Create wireframe material\n        var boxMaterial = new three__WEBPACK_IMPORTED_MODULE_2__.MeshBasicMaterial({\n          color: 0x00ff00,\n          wireframe: true,\n          transparent: true,\n          opacity: 0.5\n        });\n\n        // Create mesh\n        var boxHelper = new three__WEBPACK_IMPORTED_MODULE_2__.Mesh(boxGeometry, boxMaterial);\n\n        // Position the box at the center of the bounding box\n        boxHelper.position.copy(center);\n\n        // Add to scene\n        this.particleSystem.scene.add(boxHelper);\n\n        // Store reference\n        this.boundingBoxHelpers.push(boxHelper);\n        console.log(\"Created bounding box for solid \".concat(i, \":\"), {\n          center: center,\n          size: size\n        });\n      }\n    }\n  }, {\n    key: \"removeBoundingBoxes\",\n    value: function removeBoundingBoxes() {\n      // Remove all bounding box helpers from the scene\n      var _iterator = _createForOfIteratorHelper(this.boundingBoxHelpers),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var helper = _step.value;\n          this.particleSystem.scene.remove(helper);\n          helper.geometry.dispose();\n          helper.material.dispose();\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      this.boundingBoxHelpers = [];\n      this._saveLabelTexture = null;\n      this._hoverCooldown = new WeakMap();\n    }\n  }, {\n    key: \"setupInteractions\",\n    value: function setupInteractions() {\n      this.onMouseClick = this.onMouseClick.bind(this);\n      this.onMouseMove = this.onMouseMove.bind(this);\n      this.raycaster = new three__WEBPACK_IMPORTED_MODULE_2__.Raycaster();\n      this.mouse = new three__WEBPACK_IMPORTED_MODULE_2__.Vector2();\n    }\n  }, {\n    key: \"onMouseMove\",\n    value: function onMouseMove(event) {\n      if (!this.isSaveMode) return;\n      var rect = this.mainRenderer.domElement.getBoundingClientRect();\n      this.mouse.x = (event.clientX - rect.left) / rect.width * 2 - 1;\n      this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;\n      this.raycaster.setFromCamera(this.mouse, this.mainCamera);\n      var intersects = this.raycaster.intersectObjects(this.solidMeshes, true);\n      if (intersects.length > 0) {\n        var rootSolid = intersects[0].object;\n        while (rootSolid.parent && !this.solidMeshes.includes(rootSolid)) {\n          rootSolid = rootSolid.parent;\n        }\n        var solidIndex = this.solidMeshes.indexOf(rootSolid);\n        if (solidIndex !== -1) {\n          var cooldownUntil = this._hoverCooldown.get(rootSolid);\n          if (cooldownUntil && performance.now() < cooldownUntil) return;\n          if (cooldownUntil) this._hoverCooldown[\"delete\"](rootSolid);\n          this.hoverSolid(rootSolid, solidIndex);\n          return;\n        }\n      }\n\n      // Clear hover when pointer is NOT over any solid\n      this.clearHover();\n    }\n  }, {\n    key: \"onMouseClick\",\n    value: function onMouseClick(event) {\n      if (!this.isSaveMode) return;\n\n      // Calculate mouse position in normalized device coordinates\n      var rect = this.mainRenderer.domElement.getBoundingClientRect();\n      this.mouse.x = (event.clientX - rect.left) / rect.width * 2 - 1;\n      this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;\n\n      // Update the raycaster\n      this.raycaster.setFromCamera(this.mouse, this.mainCamera);\n\n      // Find intersections with solids\n      var intersects = this.raycaster.intersectObjects(this.solidMeshes, true);\n      if (intersects.length > 0) {\n        var clickedObject = intersects[0].object;\n\n        // Find the root solid (in case we clicked on a child mesh)\n        var rootSolid = clickedObject;\n        while (rootSolid.parent && !this.solidMeshes.includes(rootSolid)) {\n          rootSolid = rootSolid.parent;\n        }\n\n        // If we found a valid solid, select it\n        var solidIndex = this.solidMeshes.indexOf(rootSolid);\n        if (solidIndex !== -1) {\n          this.selectSolid(rootSolid, solidIndex);\n        }\n      }\n    }\n  }, {\n    key: \"hoverSolid\",\n    value: function hoverSolid(solid, index) {\n      var cooldownUntil = this._hoverCooldown.get(solid);\n      if (cooldownUntil && performance.now() < cooldownUntil) return;\n\n      // Don't re-hover if already hovering this solid\n      if (solid === this.hoveredSolid) return;\n\n      // Clear previous hover\n      if (this.hoveredSolid) {\n        this.clearHover();\n      }\n      this.hoveredSolid = solid;\n      this.hoveredSolidIndex = index;\n      this.addHoverOutline(solid);\n      this.mainRenderer.domElement.style.cursor = 'pointer';\n    }\n  }, {\n    key: \"addHoverOutline\",\n    value: function addHoverOutline(solid) {\n      var _this5 = this;\n      var isSelected = this.selectedSolids.includes(solid);\n      solid.traverse(function (child) {\n        if (!child.isMesh) return;\n        if (!child.userData.__saveModeMaterialOriginal) {\n          child.userData.__saveModeMaterialOriginal = child.material;\n        }\n        _this5._applySolidTint(child, isSelected ? 0.6 : 0.35);\n      });\n    }\n  }, {\n    key: \"clearHover\",\n    value: function clearHover() {\n      var _this6 = this;\n      if (!this.hoveredSolid) return;\n      var isSelected = this.selectedSolids.includes(this.hoveredSolid);\n      if (!isSelected) {\n        // Restore to original material from global cache\n        this.hoveredSolid.traverse(function (child) {\n          if (child.isMesh) {\n            var originalMaterial = _this6._globalMaterialCache.get(child);\n            if (originalMaterial) {\n              child.material = originalMaterial;\n            }\n            if (child.element) {\n              child.element.classList.remove('hovered-solid', 'hovered-aura');\n            }\n          }\n        });\n      } else {\n        // Re-apply selection tint (without hover intensity)\n        this.addSelectionOutline(this.hoveredSolid);\n      }\n      this.hoveredSolid = null;\n      this.hoveredSolidIndex = -1;\n      this.mainRenderer.domElement.style.cursor = 'default';\n    }\n  }, {\n    key: \"addSelectionOutline\",\n    value: function addSelectionOutline(solid) {\n      var _this7 = this;\n      solid.traverse(function (child) {\n        if (!child.isMesh) return;\n        if (!child.userData.__saveModeMaterialOriginal) {\n          child.userData.__saveModeMaterialOriginal = child.material;\n        }\n        _this7._applySolidTint(child, 0.65);\n      });\n    }\n  }, {\n    key: \"selectSolid\",\n    value: function selectSolid(solid, index) {\n      var _solid$userData;\n      // If already selected, deselect\n      if (solid.userData.__saveModeSelected === true || this.selectedSolids.includes(solid)) {\n        this.deselectSolid(solid, index);\n        return;\n      }\n      solid.userData.__saveModeSelected = true;\n      this.selectedSolids.push(solid);\n\n      // CHANGED: Play with overlap allowed\n      var id = solid === null || solid === void 0 || (_solid$userData = solid.userData) === null || _solid$userData === void 0 || (_solid$userData = _solid$userData.solution) === null || _solid$userData === void 0 ? void 0 : _solid$userData.id;\n      if (id != null) {\n        try {\n          var _this$particleSystem5;\n          (_this$particleSystem5 = this.particleSystem) === null || _this$particleSystem5 === void 0 || (_this$particleSystem5 = _this$particleSystem5.surroundController) === null || _this$particleSystem5 === void 0 || _this$particleSystem5.playOneShot(id, {\n            allowOverlap: true,\n            // CHANGED: Allow multiple sounds\n            highlightMesh: solid\n          });\n          this._saveModePlayingIds.add(id); // CHANGED: Add to Set\n        } catch (e) {\n          console.error('Failed to play audio on select:', e);\n        }\n      }\n      this.addSelectionOutline(solid);\n      if (!solid.userData.saveIconWorldPosition) {\n        solid.userData.saveIconWorldPosition = this.getCameraFacingFaceCenter(solid);\n      }\n      this.createSaveToLibraryButton(solid, index);\n      this.updateSaveCombinationButton();\n      console.log(\"Selected solid \".concat(index, \", playing: \").concat(Array.from(this._saveModePlayingIds)));\n    }\n  }, {\n    key: \"getCameraFacingFaceCenter\",\n    value: function getCameraFacingFaceCenter(solid) {\n      // Get bounding box\n      var box = new three__WEBPACK_IMPORTED_MODULE_2__.Box3().setFromObject(solid);\n      var min = box.min;\n      var max = box.max;\n\n      // Get camera direction relative to the solid\n      var solidWorldPosition = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n      solid.getWorldPosition(solidWorldPosition);\n      var cameraDirection = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n      cameraDirection.subVectors(this.mainCamera.position, solidWorldPosition).normalize();\n\n      // Define the 6 face centers and their normals\n      var faces = [{\n        center: new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(max.x, (min.y + max.y) / 2, (min.z + max.z) / 2),\n        normal: new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(1, 0, 0)\n      },\n      // Right face\n      {\n        center: new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(min.x, (min.y + max.y) / 2, (min.z + max.z) / 2),\n        normal: new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(-1, 0, 0)\n      },\n      // Left face\n      {\n        center: new three__WEBPACK_IMPORTED_MODULE_2__.Vector3((min.x + max.x) / 2, max.y, (min.z + max.z) / 2),\n        normal: new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(0, 1, 0)\n      },\n      // Top face\n      {\n        center: new three__WEBPACK_IMPORTED_MODULE_2__.Vector3((min.x + max.x) / 2, min.y, (min.z + max.z) / 2),\n        normal: new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(0, -1, 0)\n      },\n      // Bottom face\n      {\n        center: new three__WEBPACK_IMPORTED_MODULE_2__.Vector3((min.x + max.x) / 2, (min.y + max.y) / 2, max.z),\n        normal: new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(0, 0, 1)\n      },\n      // Front face\n      {\n        center: new three__WEBPACK_IMPORTED_MODULE_2__.Vector3((min.x + max.x) / 2, (min.y + max.y) / 2, min.z),\n        normal: new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(0, 0, -1)\n      } // Back face\n      ];\n\n      // Find the face that's most aligned with the camera direction\n      var bestFace = faces[0];\n      var bestDot = -Infinity;\n      for (var _i = 0, _faces = faces; _i < _faces.length; _i++) {\n        var face = _faces[_i];\n        // Calculate how much this face normal aligns with camera direction\n        var dot = face.normal.dot(cameraDirection);\n        if (dot > bestDot) {\n          bestDot = dot;\n          bestFace = face;\n        }\n      }\n      console.log(\"Camera-facing face center for solid:\", bestFace.center, \"(normal: \".concat(bestFace.normal.x, \", \").concat(bestFace.normal.y, \", \").concat(bestFace.normal.z, \")\"));\n      return bestFace.center.clone();\n    }\n  }, {\n    key: \"deselectSolid\",\n    value: function deselectSolid(solid, index) {\n      var _solid$userData2;\n      this.selectedSolids = this.selectedSolids.filter(function (s) {\n        return s !== solid;\n      });\n      solid.userData.__saveModeSelected = false;\n\n      // FIXED: Stop only THIS solid's audio\n      var id = solid === null || solid === void 0 || (_solid$userData2 = solid.userData) === null || _solid$userData2 === void 0 || (_solid$userData2 = _solid$userData2.solution) === null || _solid$userData2 === void 0 ? void 0 : _solid$userData2.id;\n      if (id != null) {\n        this._saveModePlayingIds[\"delete\"](id);\n        try {\n          var _this$particleSystem6, _this$particleSystem7, _this$particleSystem8;\n          // Call the stop method with proper fade\n          (_this$particleSystem6 = this.particleSystem) === null || _this$particleSystem6 === void 0 || (_this$particleSystem6 = _this$particleSystem6.surroundController) === null || _this$particleSystem6 === void 0 || (_this$particleSystem7 = _this$particleSystem6.stopOneShotById) === null || _this$particleSystem7 === void 0 || _this$particleSystem7.call(_this$particleSystem6, id, 250);\n\n          // ADDED: Explicitly clear the green outline from audio\n          (_this$particleSystem8 = this.particleSystem) === null || _this$particleSystem8 === void 0 || (_this$particleSystem8 = _this$particleSystem8.surroundController) === null || _this$particleSystem8 === void 0 || _this$particleSystem8._unhighlightSource(id);\n        } catch (e) {\n          console.error('Failed to stop audio on deselect:', e);\n        }\n      }\n\n      // ADDED: Block hover for longer time\n      this._hoverCooldown.set(solid, performance.now() + 800);\n      if (this.hoveredSolid === solid) {\n        this.hoveredSolid = null;\n        this.hoveredSolidIndex = -1;\n      }\n      this._restoreSolidMaterial(solid);\n\n      // Remove UI elements\n      if (solid.userData.saveToLibraryBtn) {\n        solid.userData.saveToLibraryBtn.remove();\n        solid.userData.saveToLibraryBtn = null;\n      }\n      if (solid.userData.save3DIcon) {\n        this.particleSystem.scene.remove(solid.userData.save3DIcon);\n        solid.userData.save3DIcon = null;\n      }\n      if (solid.userData.saveConnectionLine) {\n        this.particleSystem.scene.remove(solid.userData.saveConnectionLine);\n        solid.userData.saveConnectionLine.geometry.dispose();\n        solid.userData.saveConnectionLine.material.dispose();\n        solid.userData.saveConnectionLine = null;\n      }\n      if (solid.userData.saveLabelSprite) {\n        solid.userData.saveLabelSprite = null;\n      }\n      this.updateSaveCombinationButton();\n      console.log(\"Deselected solid \".concat(index, \", still playing: \").concat(Array.from(this._saveModePlayingIds)));\n    }\n  }, {\n    key: \"createSaveToLibraryButton\",\n    value: function createSaveToLibraryButton(solid, solidIndex) {\n      // Remove any existing button for this solid\n      if (solid.userData.saveToLibraryBtn) {\n        solid.userData.saveToLibraryBtn.remove();\n        solid.userData.saveToLibraryBtn = null;\n      }\n\n      // Remove any existing 3D icon\n      if (solid.userData.save3DIcon) {\n        this.particleSystem.scene.remove(solid.userData.save3DIcon);\n        solid.userData.save3DIcon = null;\n      }\n      this.create3DSaveIcon(solid, solidIndex);\n      this.createHTMLButton(solid, solidIndex);\n    }\n  }, {\n    key: \"saveToLibrary\",\n    value: function saveToLibrary(solid, solidIndex) {\n      var _this8 = this;\n      console.log(\"\\uD83D\\uDCBE Saving solid \".concat(solidIndex, \" to library\"));\n      var solutionData = solid.userData.solution;\n      var audioParams = solid.userData.audioParams;\n      var descriptors = solid.userData.descriptors;\n      var category = solid.userData.category;\n      if (!solutionData || !audioParams) {\n        console.warn('‚ö†Ô∏è No real solution data found for solid, using fallback');\n        this.saveToLibraryWithFallback(solid, solidIndex);\n        return;\n      }\n\n      // FIXED: Check if already exists with comprehensive criteria\n      var testItem = {\n        type: 'solution',\n        solutionId: solutionData === null || solutionData === void 0 ? void 0 : solutionData.id,\n        solutionData: solutionData,\n        solid: solid\n      };\n      var existing = this.library.findExistingItem(testItem);\n      if (existing) {\n        this.showAlreadySavedMessage('solution', existing.name);\n        return;\n      }\n      this.showNameInputWidget('solution', function (name) {\n        var libraryItem = {\n          id: (solutionData === null || solutionData === void 0 ? void 0 : solutionData.id) || Date.now(),\n          name: name,\n          type: 'solution',\n          category: category || 'unknown',\n          description: '',\n          solid: solid,\n          solutionData: solutionData,\n          audioParams: audioParams,\n          descriptors: descriptors\n        };\n\n        // Temporarily restore material for snapshot\n        var swaps = [];\n        solid.traverse(function (child) {\n          if (child.isMesh) {\n            var original = _this8._globalMaterialCache.get(child);\n            if (original && child.material !== original) {\n              swaps.push({\n                child: child,\n                temp: child.material\n              });\n              child.material = original;\n            }\n          }\n        });\n        _this8.library.addItem(libraryItem);\n\n        // Restore tinted materials\n        swaps.forEach(function (_ref2) {\n          var child = _ref2.child,\n            temp = _ref2.temp;\n          child.material = temp;\n        });\n\n        // CHANGED: Use stylized message instead of alert\n        _this8.showSuccessMessage(\"Solution \\\"\".concat(name, \"\\\" saved to library!\"));\n        _this8.deselectSolid(solid, solidIndex);\n      });\n    }\n\n    // **NEW: Fallback method for solids without real data**\n  }, {\n    key: \"saveToLibraryWithFallback\",\n    value: function saveToLibraryWithFallback(solid, solidIndex) {\n      var _this9 = this;\n      console.warn('‚ö†Ô∏è Using fallback dummy data for solid without real solution data');\n      var fallbackId = solid.uuid;\n\n      // FIXED: Check with comprehensive criteria\n      var testItem = {\n        type: 'solution',\n        solutionId: fallbackId,\n        id: fallbackId,\n        solid: solid\n      };\n      var existing = this.library.findExistingItem(testItem);\n      if (existing) {\n        this.showAlreadySavedMessage('solution', existing.name);\n        return;\n      }\n      this.showNameInputWidget('solution', function (name) {\n        var audioParams = _this9.getFallbackAudioParams();\n        var libraryItem = {\n          id: fallbackId,\n          // **FIX: Use solid.uuid as primary ID**\n          solutionId: fallbackId,\n          // **FIX: Also set solutionId explicitly**\n          name: name,\n          type: 'solution',\n          category: audioParams.category || 'unknown',\n          description: '',\n          solid: solid,\n          solutionData: null,\n          // No real solution data\n          audioParams: audioParams,\n          descriptors: _this9.getFallbackDescriptors()\n        };\n        _this9.library.addItem(libraryItem);\n        alert(\"Solution \\\"\".concat(name, \"\\\" saved to library with fallback data!\"));\n        _this9.deselectSolid(solid, solidIndex);\n      });\n    }\n  }, {\n    key: \"create3DSaveIcon\",\n    value: function create3DSaveIcon(solid, solidIndex) {\n      var _this10 = this;\n      var iconGroup = new three__WEBPACK_IMPORTED_MODULE_2__.Group();\n\n      // INCREASED SIZE: Larger icon\n      var horizontalGeometry = new three__WEBPACK_IMPORTED_MODULE_2__.BoxGeometry(3.0, 0.3, 0.6); // Increased from 2.0, 0.15, 0.5\n      var verticalGeometry = new three__WEBPACK_IMPORTED_MODULE_2__.BoxGeometry(0.3, 3.0, 0.6); // Increased from 0.15, 2.0, 0.5\n\n      // Glowing material\n      var iconMaterial = new three__WEBPACK_IMPORTED_MODULE_2__.MeshStandardMaterial({\n        color: 0x00ffaa,\n        emissive: 0x00ffaa,\n        emissiveIntensity: 1.2,\n        transparent: true,\n        opacity: 1.0,\n        metalness: 0.3,\n        roughness: 0.2\n      });\n      var horizontalBar = new three__WEBPACK_IMPORTED_MODULE_2__.Mesh(horizontalGeometry, iconMaterial);\n      var verticalBar = new three__WEBPACK_IMPORTED_MODULE_2__.Mesh(verticalGeometry, iconMaterial);\n      iconGroup.add(horizontalBar);\n      iconGroup.add(verticalBar);\n\n      // Get solid bounding box to find top center\n      var box = new three__WEBPACK_IMPORTED_MODULE_2__.Box3().setFromObject(solid);\n      var size = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n      box.getSize(size);\n      var center = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n      box.getCenter(center);\n\n      // Position icon ABOVE the solid with extra height\n      var heightAboveSolid = 8; // Height above the solid's top\n      var topY = box.max.y + heightAboveSolid;\n\n      // Use the center X and Z, but position at top\n      var iconPosition = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(center.x, topY, center.z);\n      iconGroup.position.copy(iconPosition);\n\n      // Store for line connection\n      solid.userData.saveIconWorldPosition = iconPosition;\n      solid.userData.solidTopPosition = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(center.x, box.max.y, center.z);\n\n      // Scale based on distance\n      var distance = iconPosition.distanceTo(this.mainCamera.position);\n      var minScale = 1.0;\n      var maxScale = 1.5;\n      var minDist = 10;\n      var maxDist = 80;\n      var scale = Math.max(minScale, Math.min(maxScale, maxScale - (distance - minDist) / (maxDist - minDist) * (maxScale - minScale)));\n      iconGroup.scale.setScalar(scale);\n\n      // Always face camera\n      iconGroup.lookAt(this.mainCamera.position);\n\n      // CREATE VERTICAL LINE from solid top to icon\n      var lineGeometry = new three__WEBPACK_IMPORTED_MODULE_2__.BufferGeometry();\n      var linePositions = new Float32Array([center.x, box.max.y, center.z,\n      // Start at solid top\n      center.x, topY, center.z // End at icon position\n      ]);\n      lineGeometry.setAttribute('position', new three__WEBPACK_IMPORTED_MODULE_2__.BufferAttribute(linePositions, 3));\n      var lineMaterial = new three__WEBPACK_IMPORTED_MODULE_2__.LineBasicMaterial({\n        color: 0x00ffaa,\n        // Same color as icon\n        transparent: true,\n        opacity: 0,\n        linewidth: 1\n      });\n      var connectionLine = new three__WEBPACK_IMPORTED_MODULE_2__.Line(lineGeometry, lineMaterial);\n      connectionLine.layers.enable(1); // Enable bloom\n\n      // Add line to scene\n      /* this.particleSystem.scene.add(connectionLine);*/\n\n      // Store line reference\n      solid.userData.saveConnectionLine = connectionLine;\n\n      // Animation with line update\n      iconGroup.userData.animationOffset = Math.random() * Math.PI * 2;\n      iconGroup.userData.baseY = topY;\n      iconGroup.userData.update = function (time) {\n        // Subtle floating animation\n        var floatOffset = Math.sin(time * 2 + iconGroup.userData.animationOffset) * 0.15;\n        iconGroup.position.y = iconGroup.userData.baseY + floatOffset;\n\n        // Update line end position to follow icon\n        var positions = connectionLine.geometry.attributes.position.array;\n        positions[4] = iconGroup.position.y; // Update Y of second point (end of line)\n        connectionLine.geometry.attributes.position.needsUpdate = true;\n\n        // Gentle rotation\n        iconGroup.rotation.z = Math.sin(time * 1.5 + iconGroup.userData.animationOffset) * 0.1;\n\n        // Always face camera\n        iconGroup.lookAt(_this10.mainCamera.position);\n\n        // Subtle line opacity pulse\n        connectionLine.material.opacity = 0.6 + Math.sin(time * 1.5) * 0.2;\n      };\n\n      // Enable bloom layer\n      iconGroup.layers.enable(1);\n      iconGroup.traverse(function (child) {\n        if (child.isMesh) {\n          child.layers.enable(1);\n        }\n      });\n\n      // Add to scene\n      this.particleSystem.scene.add(iconGroup);\n\n      // Store reference\n      solid.userData.save3DIcon = iconGroup;\n      console.log(\"Created 3D save icon with connection line for solid \".concat(solidIndex));\n      var label = this._createSaveLabelSprite();\n      label.position.set(0, -2.8, 0);\n      label.scale.set(6, 2.2, 1);\n      label.renderOrder = 5;\n      label.material.depthTest = false;\n      iconGroup.add(label);\n    }\n  }, {\n    key: \"createHTMLButton\",\n    value: function createHTMLButton(solid, solidIndex) {\n      var _this11 = this;\n      // Create invisible HTML button for click detection\n      var saveBtn = document.createElement('button');\n      saveBtn.className = 'save-to-library-btn-3d';\n      saveBtn.setAttribute('data-solid-index', solidIndex);\n      saveBtn.style.position = 'absolute';\n      saveBtn.style.background = 'transparent';\n      saveBtn.style.border = 'none';\n      saveBtn.style.cursor = 'pointer';\n      saveBtn.style.zIndex = '2000';\n      saveBtn.style.borderRadius = '50%';\n      var distance = solid.userData.saveIconWorldPosition.distanceTo(this.mainCamera.position);\n      var minScale = 0.5;\n      var maxScale = 1.0;\n      var minDist = 10;\n      var maxDist = 80;\n      var scale = Math.max(minScale, Math.min(maxScale, maxScale - (distance - minDist) / (maxDist - minDist) * (maxScale - minScale)));\n\n      // Base button size scaled by distance\n      var baseSize = 60;\n      var scaledSize = baseSize * scale;\n      saveBtn.style.width = \"\".concat(scaledSize, \"px\");\n      saveBtn.style.height = \"\".concat(scaledSize, \"px\");\n\n      // Position button over the 3D icon\n      this.updateHTMLButtonPosition(saveBtn, solid);\n      document.body.appendChild(saveBtn);\n\n      // Store reference\n      solid.userData.saveToLibraryBtn = saveBtn;\n      saveBtn.onclick = function () {\n        return _this11.saveToLibrary(solid, solidIndex);\n      };\n    }\n  }, {\n    key: \"updateHTMLButtonPosition\",\n    value: function updateHTMLButtonPosition(button, solid) {\n      if (!solid.userData.save3DIcon) return;\n\n      // Project 3D icon position to screen space\n      var iconPosition = solid.userData.save3DIcon.position.clone();\n      var projected = iconPosition.project(this.mainCamera);\n      var x = (projected.x * 0.5 + 0.5) * window.innerWidth;\n      var y = (projected.y * -0.5 + 0.5) * window.innerHeight;\n      var buttonSize = parseFloat(button.style.width) || 60;\n      var halfSize = buttonSize / 2;\n\n      // Center the button on the projected position\n      button.style.left = \"\".concat(x - halfSize, \"px\");\n      button.style.top = \"\".concat(y - halfSize, \"px\");\n    }\n  }, {\n    key: \"update3DIconPositions\",\n    value: function update3DIconPositions() {\n      var _this12 = this;\n      if (!this.isSaveMode) return;\n      var time = performance.now() * 0.001;\n      this.selectedSolids.forEach(function (solid) {\n        // Update 3D icon animation\n        if (solid.userData.save3DIcon && solid.userData.save3DIcon.userData.update) {\n          solid.userData.save3DIcon.userData.update(time);\n        }\n\n        // Update HTML button position\n        if (solid.userData.saveToLibraryBtn) {\n          _this12.updateHTMLButtonPosition(solid.userData.saveToLibraryBtn, solid);\n        }\n      });\n    }\n  }, {\n    key: \"saveCombination\",\n    value: function saveCombination() {\n      var _this13 = this;\n      console.log(\"\\uD83D\\uDCBE Saving combination of \".concat(this.selectedSolids.length, \" solids\"));\n      var items = this.selectedSolids.map(function (solid, index) {\n        var solutionData = solid.userData.solution;\n        var audioParams = solid.userData.audioParams;\n        var descriptors = solid.userData.descriptors;\n        var category = solid.userData.category;\n        return {\n          name: solutionData ? \"\".concat(category || 'Unknown', \" Sound \").concat(index + 1) : \"Sound \".concat(index + 1),\n          solid: solid,\n          solutionData: solutionData,\n          audioParams: audioParams || _this13.getFallbackAudioParams(),\n          descriptors: descriptors || _this13.getFallbackDescriptors(),\n          category: category || 'unknown',\n          fitness: (solutionData === null || solutionData === void 0 ? void 0 : solutionData.fitness) || 0,\n          id: (solutionData === null || solutionData === void 0 ? void 0 : solutionData.id) || solid.uuid,\n          solutionId: (solutionData === null || solutionData === void 0 ? void 0 : solutionData.id) || solid.uuid\n        };\n      });\n\n      // FIXED: Check with proper criteria\n      var testItem = {\n        type: 'combination',\n        items: items\n      };\n      var existing = this.library.findExistingItem(testItem);\n      if (existing) {\n        this.showAlreadySavedMessage('combination', existing.name);\n        return;\n      }\n      this.showNameInputWidget('combination', function (name) {\n        var categories = items.map(function (i) {\n          return i.category;\n        }).filter(Boolean);\n        var avgFitness = items.reduce(function (s, it) {\n          return s + (it.fitness || 0);\n        }, 0) / Math.max(1, items.length);\n        var uniqueCategories = _toConsumableArray(new Set(categories));\n        var libraryItem = {\n          id: Date.now(),\n          name: name,\n          type: 'combination',\n          description: '',\n          items: items,\n          solid: _this13.selectedSolids[Math.floor(Math.random() * _this13.selectedSolids.length)]\n        };\n        _this13.library.addItem(libraryItem);\n\n        // CHANGED: Use stylized message instead of alert\n        _this13.showSuccessMessage(\"Combination \\\"\".concat(name, \"\\\" saved to library!\"));\n        _this13.clearAllSelections();\n      });\n    }\n\n    // NEW: Show stylized success message\n  }, {\n    key: \"showSuccessMessage\",\n    value: function showSuccessMessage(text) {\n      // Create or reuse message element\n      var messageEl = document.getElementById('save-mode-message');\n      if (!messageEl) {\n        messageEl = document.createElement('div');\n        messageEl.id = 'save-mode-message';\n        messageEl.className = 'submission-message success';\n        document.body.appendChild(messageEl);\n      }\n      messageEl.textContent = text;\n      messageEl.classList.remove('error');\n      messageEl.classList.add('success', 'visible');\n\n      // Auto-hide after 3 seconds\n      setTimeout(function () {\n        messageEl.classList.remove('visible');\n      }, 3000);\n    }\n\n    // NEW: Show stylized error message\n  }, {\n    key: \"showErrorMessage\",\n    value: function showErrorMessage(text) {\n      // Create or reuse message element\n      var messageEl = document.getElementById('save-mode-message');\n      if (!messageEl) {\n        messageEl = document.createElement('div');\n        messageEl.id = 'save-mode-message';\n        messageEl.className = 'submission-message error';\n        document.body.appendChild(messageEl);\n      }\n      messageEl.textContent = text;\n      messageEl.classList.remove('success');\n      messageEl.classList.add('error', 'visible');\n\n      // Auto-hide after 3 seconds\n      setTimeout(function () {\n        messageEl.classList.remove('visible');\n      }, 3000);\n    }\n  }, {\n    key: \"showNameInputWidget\",\n    value: function showNameInputWidget(type, onSave) {\n      // Create overlay\n      var overlay = document.createElement('div');\n      overlay.className = 'name-input-overlay';\n\n      // Create widget\n      var widget = document.createElement('div');\n      widget.className = 'name-input-widget';\n\n      // Create title\n      var title = document.createElement('h3');\n      title.textContent = \"Name your \".concat(type);\n      widget.appendChild(title);\n\n      // Create input\n      var input = document.createElement('input');\n      input.type = 'text';\n      input.placeholder = \"Enter \".concat(type, \" name...\");\n      input.value = \"My \".concat(type, \" \").concat(Date.now());\n      widget.appendChild(input);\n\n      // Create buttons container\n      var buttonsContainer = document.createElement('div');\n      buttonsContainer.className = 'name-input-buttons';\n\n      // Create save button with icon\n      var saveBtn = document.createElement('button');\n      saveBtn.className = 'name-input-btn save';\n      saveBtn.title = 'Save';\n      saveBtn.innerHTML = '<img src=\"/assets/icons/Confirm.svg\" alt=\"Save\" class=\"name-input-icon\">';\n      saveBtn.onclick = function () {\n        var name = input.value.trim();\n        if (name) {\n          onSave(name);\n          overlay.remove();\n        } else {\n          input.focus();\n          input.style.borderColor = '#dc3545';\n        }\n      };\n\n      // Create cancel button with icon\n      var cancelBtn = document.createElement('button');\n      cancelBtn.className = 'name-input-btn cancel';\n      cancelBtn.title = 'Cancel';\n      cancelBtn.innerHTML = '<img src=\"/assets/icons/Cancel.svg\" alt=\"Cancel\" class=\"name-input-icon\">';\n      cancelBtn.onclick = function () {\n        overlay.remove();\n      };\n      buttonsContainer.appendChild(saveBtn);\n      buttonsContainer.appendChild(cancelBtn);\n      widget.appendChild(buttonsContainer);\n      overlay.appendChild(widget);\n      document.body.appendChild(overlay);\n\n      // Auto-focus input\n      setTimeout(function () {\n        input.focus();\n        input.select();\n      }, 100);\n\n      // NEW: Stop propagation of ALL keyboard events from input\n      input.addEventListener('keydown', function (e) {\n        e.stopPropagation(); // Prevent event from bubbling up\n        e.stopImmediatePropagation(); // Stop other handlers on same element\n\n        if (e.key === 'Enter') {\n          e.preventDefault();\n          saveBtn.click();\n        } else if (e.key === 'Escape') {\n          e.preventDefault();\n          cancelBtn.click();\n        }\n      });\n\n      // NEW: Also stop keyup and keypress events\n      input.addEventListener('keyup', function (e) {\n        e.stopPropagation();\n        e.stopImmediatePropagation();\n      });\n      input.addEventListener('keypress', function (e) {\n        e.stopPropagation();\n        e.stopImmediatePropagation();\n      });\n\n      // Click overlay to close\n      overlay.addEventListener('click', function (e) {\n        if (e.target === overlay) {\n          overlay.remove();\n        }\n      });\n    }\n  }, {\n    key: \"updateSaveCombinationButton\",\n    value: function updateSaveCombinationButton() {\n      var _this14 = this;\n      // Remove if exists\n      if (this.saveCombinationBtn) {\n        this.saveCombinationBtn.remove();\n        this.saveCombinationBtn = null;\n      }\n      if (this.selectedSolids.length > 1) {\n        this.saveCombinationBtn = document.createElement('button');\n        this.saveCombinationBtn.className = 'save-combination-btn';\n        this.saveCombinationBtn.innerText = 'Save Combination';\n        document.body.appendChild(this.saveCombinationBtn);\n        this.saveCombinationBtn.onclick = function () {\n          return _this14.saveCombination();\n        };\n      }\n    }\n  }, {\n    key: \"clearSelection\",\n    value: function clearSelection() {\n      var _this15 = this;\n      this.selectedSolids.forEach(function (solid) {\n        var _solid$userData3;\n        solid.userData.__saveModeSelected = false;\n        // If any selected solid owns the currently playing id, silence it\n        var id = solid === null || solid === void 0 || (_solid$userData3 = solid.userData) === null || _solid$userData3 === void 0 || (_solid$userData3 = _solid$userData3.solution) === null || _solid$userData3 === void 0 ? void 0 : _solid$userData3.id;\n        if (id != null && _this15._saveModePlayingId === id) {\n          try {\n            var _this15$particleSyste;\n            (_this15$particleSyste = _this15.particleSystem) === null || _this15$particleSyste === void 0 || (_this15$particleSyste = _this15$particleSyste.surroundController) === null || _this15$particleSyste === void 0 || _this15$particleSyste.fadeOutAll(120);\n          } catch (_unused2) {}\n          _this15._saveModePlayingId = null;\n        }\n        solid.traverse(function (child) {\n          if (child.isMesh) {\n            // Always restore the true original material\n            if (child.userData.originalMaterial) {\n              child.material = child.userData.originalMaterial;\n              delete child.userData.originalMaterial;\n            }\n            // Remove any leftover hover material reference\n            if (child.userData.originalHoverMaterial) {\n              delete child.userData.originalHoverMaterial;\n            }\n          }\n          if (child.element) {\n            child.element.classList.remove('selected-solid');\n            child.element.classList.remove('hovered-solid');\n            child.element.classList.remove('hovered-aura');\n          }\n        });\n\n        // Remove this solid's HTML button\n        if (solid.userData.saveToLibraryBtn) {\n          solid.userData.saveToLibraryBtn.remove();\n          solid.userData.saveToLibraryBtn = null;\n        }\n\n        // Remove 3D icon\n        if (solid.userData.save3DIcon) {\n          _this15.particleSystem.scene.remove(solid.userData.save3DIcon);\n          solid.userData.save3DIcon = null;\n        }\n\n        // **NEW: Remove connection line**\n        if (solid.userData.saveConnectionLine) {\n          _this15.particleSystem.scene.remove(solid.userData.saveConnectionLine);\n          solid.userData.saveConnectionLine.geometry.dispose();\n          solid.userData.saveConnectionLine.material.dispose();\n          solid.userData.saveConnectionLine = null;\n        }\n      });\n\n      // Ensure nothing continues playing\n      try {\n        var _this$particleSystem9;\n        (_this$particleSystem9 = this.particleSystem) === null || _this$particleSystem9 === void 0 || (_this$particleSystem9 = _this$particleSystem9.surroundController) === null || _this$particleSystem9 === void 0 || _this$particleSystem9.fadeOutAll(120);\n      } catch (_unused3) {}\n      this._saveModePlayingId = null;\n    }\n  }, {\n    key: \"clearAllSelections\",\n    value: function clearAllSelections() {\n      var _this16 = this;\n      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref3$restoreMaterial = _ref3.restoreMaterials,\n        restoreMaterials = _ref3$restoreMaterial === void 0 ? true : _ref3$restoreMaterial;\n      _toConsumableArray(this.selectedSolids).forEach(function (solid) {\n        var _solid$userData4;\n        var index = _this16.solidMeshes.indexOf(solid);\n        var id = solid === null || solid === void 0 || (_solid$userData4 = solid.userData) === null || _solid$userData4 === void 0 || (_solid$userData4 = _solid$userData4.solution) === null || _solid$userData4 === void 0 ? void 0 : _solid$userData4.id;\n\n        // CHANGED: Stop each sound individually\n        if (id != null && _this16._saveModePlayingIds.has(id)) {\n          _this16._saveModePlayingIds[\"delete\"](id);\n          try {\n            var _this16$particleSyste, _this16$particleSyste2;\n            (_this16$particleSyste = _this16.particleSystem) === null || _this16$particleSyste === void 0 || (_this16$particleSyste = _this16$particleSyste.surroundController) === null || _this16$particleSyste === void 0 || (_this16$particleSyste2 = _this16$particleSyste.stopOneShotById) === null || _this16$particleSyste2 === void 0 || _this16$particleSyste2.call(_this16$particleSyste, id, 250);\n          } catch (_unused4) {}\n        }\n        _this16.deselectSolid(solid, index);\n      });\n      if (this.saveCombinationBtn) {\n        this.saveCombinationBtn.remove();\n        this.saveCombinationBtn = null;\n      }\n      if (restoreMaterials) {\n        this._forceCleanupAllMaterials(false);\n      }\n    }\n  }, {\n    key: \"showAlreadySavedMessage\",\n    value: function showAlreadySavedMessage(type, existingName) {\n      // Create overlay\n      var overlay = document.createElement('div');\n      overlay.className = 'name-input-overlay';\n\n      // Create widget\n      var widget = document.createElement('div');\n      widget.className = 'name-input-widget';\n\n      // Create title\n      var title = document.createElement('h3');\n      title.textContent = \"\".concat(type.charAt(0).toUpperCase() + type.slice(1), \" Already Saved\");\n      widget.appendChild(title);\n\n      // Create message\n      var message = document.createElement('p');\n      message.innerHTML = \"This \".concat(type, \" is already in your library as:<br><strong>\\\"\").concat(existingName, \"\\\"</strong>\"); // CHANGED: Removed inline styles\n      widget.appendChild(message);\n\n      // Create buttons container\n      var buttonsContainer = document.createElement('div');\n      buttonsContainer.className = 'name-input-buttons';\n\n      // Create OK button\n      var okBtn = document.createElement('button');\n      okBtn.className = 'name-input-btn save';\n      okBtn.textContent = 'OK';\n      okBtn.onclick = function () {\n        overlay.remove();\n      };\n      buttonsContainer.appendChild(okBtn);\n      widget.appendChild(buttonsContainer);\n      overlay.appendChild(widget);\n      document.body.appendChild(overlay);\n\n      // Auto-focus OK button\n      setTimeout(function () {\n        return okBtn.focus();\n      }, 100);\n\n      // Allow ESC and Enter to close\n      var _handleKey = function handleKey(e) {\n        if (e.key === 'Enter' || e.key === 'Escape') {\n          overlay.remove();\n          document.removeEventListener('keydown', _handleKey);\n        }\n      };\n      document.addEventListener('keydown', _handleKey);\n\n      // Click overlay to close\n      overlay.addEventListener('click', function (e) {\n        if (e.target === overlay) {\n          overlay.remove();\n          document.removeEventListener('keydown', _handleKey);\n        }\n      });\n    }\n\n    // CHANGE 1: Fix material caching to NOT clone (use reference instead)\n  }, {\n    key: \"_cacheOriginalMaterials\",\n    value: function _cacheOriginalMaterials() {\n      var _this17 = this;\n      if (this._baseMaterialsCached) return;\n      console.log('üì¶ Caching original materials');\n      this.solidMeshes.forEach(function (solid) {\n        solid.traverse(function (child) {\n          if (!child.isMesh) return;\n\n          // CRITICAL: Cache the CURRENT material as the true original\n          // (This should be the untinted material from main scene)\n          if (!child.userData.__saveModeOriginalMaterial) {\n            child.userData.__saveModeOriginalMaterial = child.material;\n            child.userData.__saveModeBaseMaterial = _this17._cloneMaterial(child.material);\n          }\n        });\n      });\n      this._baseMaterialsCached = true;\n      console.log('‚úÖ Original materials cached');\n    }\n\n    // CHANGE 2: Fix material restoration to use reference, not clone\n  }, {\n    key: \"_restoreSolidMaterial\",\n    value: function _restoreSolidMaterial(solid) {\n      var _this18 = this;\n      if (!solid) return;\n      solid.traverse(function (child) {\n        if (!child.isMesh) return;\n\n        // Always restore from global cache\n        var originalMaterial = _this18._globalMaterialCache.get(child);\n        if (originalMaterial) {\n          child.material = originalMaterial;\n        }\n        if (child.element) {\n          child.element.classList.remove('selected-solid', 'hovered-solid', 'hovered-aura');\n        }\n      });\n    }\n\n    // CHANGE 3: Fix force cleanup to use reference\n  }, {\n    key: \"_forceCleanupAllMaterials\",\n    value: function _forceCleanupAllMaterials() {\n      var removeCache = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      console.log('üßπ Force cleaning all materials');\n      this.solidMeshes.forEach(function (solid) {\n        if (!solid) return;\n        solid.traverse(function (child) {\n          if (!child.isMesh) return;\n\n          // CRITICAL: Always restore to the ORIGINAL material we cached on enter\n          var originalMaterial = child.userData.__saveModeOriginalMaterial;\n          if (originalMaterial) {\n            child.material = originalMaterial;\n          }\n\n          // Clean up CSS classes\n          if (child.element) {\n            child.element.classList.remove('selected-solid', 'hovered-solid', 'hovered-aura');\n          }\n\n          // Delete ALL temporary material references\n          delete child.userData.__saveModeMaterialTint;\n          delete child.userData.__saveModeMaterialOriginal;\n          if (removeCache) {\n            delete child.userData.__saveModeBaseMaterial;\n            delete child.userData.__saveModeOriginalMaterial;\n          }\n        });\n\n        // Clean up solid-level flags\n        delete solid.userData.__saveModeSelected;\n      });\n      console.log('‚úÖ All materials restored to original state');\n    }\n  }, {\n    key: \"_createSaveLabelSprite\",\n    value: function _createSaveLabelSprite() {\n      if (!this._saveLabelTexture) {\n        var canvas = document.createElement('canvas');\n        canvas.width = 256;\n        canvas.height = 128;\n        var ctx = canvas.getContext('2d');\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        ctx.font = '600 58px \"Space Grotesk\", sans-serif';\n        ctx.fillStyle = '#ffffff';\n        ctx.textAlign = 'center';\n        ctx.textBaseline = 'middle';\n        ctx.fillText('SAVE', canvas.width / 2, canvas.height / 2);\n        this._saveLabelTexture = new three__WEBPACK_IMPORTED_MODULE_2__.CanvasTexture(canvas);\n        this._saveLabelTexture.minFilter = three__WEBPACK_IMPORTED_MODULE_2__.LinearFilter;\n        this._saveLabelTexture.magFilter = three__WEBPACK_IMPORTED_MODULE_2__.LinearFilter;\n        this._saveLabelTexture.needsUpdate = true;\n      }\n      return new three__WEBPACK_IMPORTED_MODULE_2__.Sprite(new three__WEBPACK_IMPORTED_MODULE_2__.SpriteMaterial({\n        map: this._saveLabelTexture,\n        transparent: true,\n        depthWrite: false,\n        depthTest: false\n      }));\n    }\n  }, {\n    key: \"_applySolidTint\",\n    value: function _applySolidTint(child) {\n      var intensity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.5;\n      if (!child.isMesh) return;\n      var originalMaterial = this._globalMaterialCache.get(child);\n      if (!originalMaterial) {\n        console.warn('‚ö†Ô∏è No cached material for mesh');\n        return;\n      }\n\n      // Clone the ORIGINAL and tint it\n      var tinted = this._createTintedMaterial(originalMaterial, intensity);\n      child.material = tinted;\n    }\n  }, {\n    key: \"_createTintedMaterial\",\n    value: function _createTintedMaterial(source, intensity) {\n      var _source$opacity;\n      if (!source || typeof source.clone !== 'function') return source;\n      var cloned = source.clone();\n      var aura = new three__WEBPACK_IMPORTED_MODULE_2__.Color(0x53d3c0);\n      if ('emissive' in cloned) {\n        var _cloned$emissiveInten;\n        cloned.emissive = aura.clone();\n        cloned.emissiveIntensity = Math.max(intensity, (_cloned$emissiveInten = cloned.emissiveIntensity) !== null && _cloned$emissiveInten !== void 0 ? _cloned$emissiveInten : 0);\n      }\n      if ('color' in cloned) {\n        cloned.color = cloned.color.clone().lerp(aura, 0.45);\n      }\n      cloned.transparent = true;\n      cloned.opacity = Math.min(0.95, (_source$opacity = source.opacity) !== null && _source$opacity !== void 0 ? _source$opacity : 1);\n      cloned.needsUpdate = true;\n      return cloned;\n    }\n  }, {\n    key: \"_restoreAllFromGlobalCache\",\n    value: function _restoreAllFromGlobalCache() {\n      var _this19 = this;\n      console.log('üîÑ Restoring all materials from global cache');\n      this.solidMeshes.forEach(function (solid) {\n        solid.traverse(function (child) {\n          if (child.isMesh) {\n            var originalMaterial = _this19._globalMaterialCache.get(child);\n            if (originalMaterial) {\n              child.material = originalMaterial;\n            }\n\n            // Clean up ALL temporary userData\n            delete child.userData.__saveModeMaterialTint;\n            delete child.userData.__saveModeMaterialOriginal;\n            delete child.userData.__saveModeBaseMaterial;\n            delete child.userData.__saveModeOriginalMaterial;\n            delete child.userData.__surroundPlayOriginal;\n            delete child.userData.__surroundOriginalMaterial;\n\n            // Clean up CSS classes\n            if (child.element) {\n              child.element.classList.remove('selected-solid', 'hovered-solid', 'hovered-aura');\n            }\n          }\n        });\n        delete solid.userData.__saveModeSelected;\n      });\n    }\n  }]);\n}();\n\n//# sourceURL=webpack://sound-particle-visualization/./src/components/SaveMode.js?");

/***/ }),

/***/ "./src/components/SpatialGrid.js":
/*!***************************************!*\
  !*** ./src/components/SpatialGrid.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SpatialGrid: () => (/* binding */ SpatialGrid),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n// Add this helper class at the top of ParticleSystem.js (before the ParticleSystem class)\n\nvar SpatialGrid = /*#__PURE__*/function () {\n  function SpatialGrid(cellSize) {\n    _classCallCheck(this, SpatialGrid);\n    this.cellSize = cellSize;\n    this.grid = new Map();\n  }\n  return _createClass(SpatialGrid, [{\n    key: \"_hash\",\n    value: function _hash(x, z) {\n      var cx = Math.floor(x / this.cellSize);\n      var cz = Math.floor(z / this.cellSize);\n      return \"\".concat(cx, \",\").concat(cz);\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.grid.clear();\n    }\n  }, {\n    key: \"insert\",\n    value: function insert(index, position) {\n      var key = this._hash(position.x, position.z);\n      if (!this.grid.has(key)) {\n        this.grid.set(key, []);\n      }\n      this.grid.get(key).push(index);\n    }\n  }, {\n    key: \"getNearby\",\n    value: function getNearby(position, radius) {\n      var nearby = [];\n      var cells = Math.ceil(radius / this.cellSize);\n      var cx = Math.floor(position.x / this.cellSize);\n      var cz = Math.floor(position.z / this.cellSize);\n\n      // Check neighboring cells\n      for (var dx = -cells; dx <= cells; dx++) {\n        for (var dz = -cells; dz <= cells; dz++) {\n          var key = \"\".concat(cx + dx, \",\").concat(cz + dz);\n          var cell = this.grid.get(key);\n          if (cell) {\n            nearby.push.apply(nearby, _toConsumableArray(cell));\n          }\n        }\n      }\n      return nearby;\n    }\n  }]);\n}();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SpatialGrid);\n\n//# sourceURL=webpack://sound-particle-visualization/./src/components/SpatialGrid.js?");

/***/ })

}]);