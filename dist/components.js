"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunksound_particle_visualization"] = self["webpackChunksound_particle_visualization"] || []).push([["components"],{

/***/ "./src/components/Button.js":
/*!**********************************!*\
  !*** ./src/components/Button.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Button: () => (/* binding */ Button)\n/* harmony export */ });\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar Button = /*#__PURE__*/function () {\n  function Button(text, position, onClick) {\n    _classCallCheck(this, Button);\n    this.text = text;\n    this.position = position;\n    this.onClick = onClick;\n    this.button = null;\n    this.isSelected = false;\n    this.createButton();\n  }\n  return _createClass(Button, [{\n    key: \"createButton\",\n    value: function createButton() {\n      var existingBtn = document.getElementById(\"\".concat(this.text.toLowerCase(), \"-btn\"));\n      if (existingBtn) {\n        this.button = existingBtn;\n        this.button.onclick = this.handleClick.bind(this);\n        return;\n      }\n      this.button = document.createElement('button');\n      this.button.id = \"\".concat(this.text.toLowerCase(), \"-btn\");\n      this.button.className = 'main-screen-btn';\n\n      // Wrap text in a span for the animation\n      var textSpan = document.createElement('span');\n      textSpan.className = 'button-text';\n      textSpan.innerText = this.text.toUpperCase();\n      this.button.appendChild(textSpan);\n      this.button.onclick = this.handleClick.bind(this);\n      this.addToContainer();\n    }\n\n    // Handle click to toggle selection and call original onClick\n  }, {\n    key: \"handleClick\",\n    value: function handleClick() {\n      var _this = this;\n      // DON'T call this.onClick() here anymore - let main.js handle it\n      // this.onClick();  // <-- REMOVE THIS LINE\n\n      // Just manage menu closing\n      setTimeout(function () {\n        var _document$querySelect;\n        var isSaveModeActive = ((_document$querySelect = document.querySelector('#save-btn .button-text')) === null || _document$querySelect === void 0 ? void 0 : _document$querySelect.innerText) === 'EXIT SAVE';\n        if (!isSaveModeActive) {\n          _this.closeHamburgerMenu();\n        }\n      }, 100);\n    }\n  }, {\n    key: \"closeHamburgerMenu\",\n    value: function closeHamburgerMenu() {\n      var hamburgerButton = document.querySelector('.hamburger-button');\n      var optionsContainer = document.querySelector('.hamburger-options');\n      if (hamburgerButton && optionsContainer) {\n        hamburgerButton.classList.remove('open');\n        optionsContainer.classList.remove('open');\n      }\n    }\n  }, {\n    key: \"addToContainer\",\n    value: function addToContainer() {\n      if (!window.navigationContainers) return;\n\n      // All buttons now go to the hamburger menu instead of corners\n      var container = window.navigationContainers.hamburgerMenu || document.body;\n      container.appendChild(this.button);\n    }\n\n    // Set selected state \n  }, {\n    key: \"setSelected\",\n    value: function setSelected() {\n      var selected = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      this.isSelected = selected;\n      if (selected) {\n        this.button.classList.add('selected');\n      } else {\n        this.button.classList.remove('selected', 'show-underline-delayed');\n      }\n    }\n\n    // Smooth text change with animation\n  }, {\n    key: \"changeText\",\n    value: function changeText(newText) {\n      var _this2 = this;\n      var textSpan = this.button.querySelector('.button-text');\n      if (textSpan.innerText === newText.toUpperCase()) return;\n\n      // Convert old span to .old\n      textSpan.className = 'button-text old';\n\n      // Create new span as .new\n      var newSpan = document.createElement('span');\n      newSpan.className = 'button-text new';\n      newSpan.innerText = newText.toUpperCase();\n      this.button.appendChild(newSpan);\n\n      // Force reflow for transition\n      this.button.offsetHeight;\n\n      // Trigger transition\n      this.button.classList.add('text-changing');\n\n      // Clean up after transition\n      setTimeout(function () {\n        _this2.button.classList.remove('text-changing');\n        textSpan.remove();\n        newSpan.className = 'button-text';\n      }, 1400);\n    }\n  }, {\n    key: \"hide\",\n    value: function hide() {\n      if (this.button) {\n        this.button.classList.add('hidden');\n      }\n    }\n  }, {\n    key: \"show\",\n    value: function show() {\n      if (this.button) {\n        this.button.classList.remove('hidden');\n      }\n    }\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      if (this.button) {\n        this.button.remove();\n      }\n    }\n  }]);\n}();\n\n//# sourceURL=webpack://sound-particle-visualization/./src/components/Button.js?");

/***/ }),

/***/ "./src/components/EvolvingUI.js":
/*!**************************************!*\
  !*** ./src/components/EvolvingUI.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EvolvingUI: () => (/* binding */ EvolvingUI)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n/* harmony import */ var _Button_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Button.js */ \"./src/components/Button.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _createForOfIteratorHelper(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\nvar EvolvingUI = /*#__PURE__*/function () {\n  function EvolvingUI(mainRenderer, mainCamera, controls, particleSystem, pythonCommunication, library) {\n    var _this = this;\n    _classCallCheck(this, EvolvingUI);\n    this.mainRenderer = mainRenderer;\n    this.mainCamera = mainCamera;\n    this.controls = controls;\n    this.particleSystem = particleSystem;\n    this.pythonCommunication = pythonCommunication;\n    this.library = library;\n\n    // **NEW: Scene transition mode storage**\n    this.allSolutions = [];\n    this.categoryMeshes = {\n      'low': [],\n      'mid': [],\n      'high': [],\n      'rhythmic': []\n    };\n\n    // **NEW: Scoring storage**\n    this.allTabScores = new Map();\n    this.submitButton = null;\n\n    // **Scoring system bounds**\n\n    this.scoreArea = {\n      minY: -12,\n      maxY: 30,\n      minScore: 0.0,\n      maxScore: 1.0\n    };\n    this.solidMeshes = this.particleSystem.getSolids ? this.particleSystem.getSolids() : [];\n    this.numSolids = this.solidMeshes.length;\n    this.activeTab = 'low';\n\n    // Store original camera and solid positions**\n    this.originalCameraPosition = this.mainCamera.position.clone();\n    this.originalCameraTarget = this.controls && this.controls.target ? this.controls.target.clone() : new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();\n    this.originalSolidPositions = new Map();\n    this.isEvolvingMode = false;\n\n    // Interaction state**\n    this.drag = {\n      active: false,\n      mesh: null,\n      playingId: null\n    };\n    this.dragYScale = 0.04;\n\n    // Persist Y per-tab until submit\n    this.savedYByTab = new Map();\n    this.idToGlobalIndex = new Map();\n    this.globalBaselineCenterY = null;\n\n    // NEW: track which tabs were actually opened/aligned this session\n    this.visitedTabs = new Set();\n\n    // 'auto-average' = average center-Y of all solids at enterEvolvingMode (default)\n\n    this.baselineMode = 'auto-average';\n    //this.fixedBaselineCenterY = 10;  \n\n    this.fixedCameraTargetPos = null; // THREE.Vector3\n    this.fixedCameraTargetLook = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, 0, 0);\n\n    // Look for existing button\n    var existingEvolveBtn = document.getElementById('evolve-btn');\n    if (existingEvolveBtn) {\n      this.evolveBtn = existingEvolveBtn;\n    } else {\n      this.evolveBtn = new _Button_js__WEBPACK_IMPORTED_MODULE_0__.Button('EVOLVE', 'hamburger', function () {});\n    }\n\n    // Remove any old toggle handlers so modeManager has full control\n    var detachClick = function detachClick(btnRef) {\n      if (!btnRef) return;\n      if (btnRef.button instanceof HTMLElement) {\n        btnRef.button.onclick = null;\n      } else if (btnRef.element instanceof HTMLElement) {\n        btnRef.element.onclick = null;\n      } else if (btnRef instanceof HTMLElement) {\n        btnRef.onclick = null;\n      }\n    };\n    detachClick(this.evolveBtn);\n    this.evolveBtn.onclick = function () {\n      return _this.toggleEvolvingMode();\n    };\n    this.createTabsUI();\n    this.setupInteraction();\n  }\n  return _createClass(EvolvingUI, [{\n    key: \"createTabsUI\",\n    value: function createTabsUI() {\n      var _this2 = this;\n      // Create floating tabs interface\n      this.tabsContainer = document.createElement('div');\n      this.tabsContainer.className = 'evolve-tabs-floating';\n      this.tabsContainer.style.display = 'none';\n      var tabs = [{\n        id: 'low',\n        label: 'Low'\n      }, {\n        id: 'mid',\n        label: 'Mid'\n      }, {\n        id: 'high',\n        label: 'High'\n      }, {\n        id: 'rhythmic',\n        label: 'Rhythmic'\n      }];\n      tabs.forEach(function (tab) {\n        var tabButton = document.createElement('button');\n        tabButton.className = 'evolve-tab-button';\n        tabButton.textContent = tab.label;\n        tabButton.dataset.value = tab.id;\n        if (tab.id === _this2.activeTab) tabButton.classList.add('active');\n        tabButton.addEventListener('click', function (e) {\n          e.preventDefault();\n          _this2.switchTab(tab.id);\n        });\n        _this2.tabsContainer.appendChild(tabButton);\n      });\n      document.body.appendChild(this.tabsContainer);\n    }\n  }, {\n    key: \"toggleEvolvingMode\",\n    value: function toggleEvolvingMode() {\n      if (this.isEvolvingMode) {\n        this.exitEvolvingMode();\n      } else {\n        this.enterEvolvingMode();\n      }\n    }\n\n    // Helper: get solids for a specific tab\n  }, {\n    key: \"getSolidsByTab\",\n    value: function getSolidsByTab(tabId) {\n      return this.solidMeshes.filter(function (m) {\n        var _m$userData;\n        var cat = (_m$userData = m.userData) === null || _m$userData === void 0 || (_m$userData = _m$userData.solution) === null || _m$userData === void 0 ? void 0 : _m$userData.actual_category;\n        return typeof cat === 'string' && cat.toLowerCase() === tabId;\n      });\n    }\n\n    // Compute spacing/total depth/camera for a given solids array\n  }, {\n    key: \"computeLayoutMetricsForSolids\",\n    value: function computeLayoutMetricsForSolids(solids) {\n      if (!solids || solids.length === 0) {\n        return {\n          count: 0,\n          spacing: 0,\n          totalDepth: 0,\n          camDist: 70,\n          targetPos: new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(70, 10, 0),\n          targetLook: new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, 0, 0)\n        };\n      }\n      var maxDepth = 1;\n      var box = new three__WEBPACK_IMPORTED_MODULE_1__.Box3();\n      var _iterator = _createForOfIteratorHelper(solids),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var m = _step.value;\n          box.setFromObject(m);\n          var dz = box.getSize(new three__WEBPACK_IMPORTED_MODULE_1__.Vector3()).z;\n          if (dz > maxDepth) maxDepth = dz;\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      var spacing = maxDepth * 1.35;\n      var totalDepth = (solids.length - 1) * spacing;\n      var camDist = Math.max(25, totalDepth * 0.9 + 70);\n      var targetPos = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(camDist, 10, 0);\n      var targetLook = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, 0, 0);\n      return {\n        count: solids.length,\n        spacing: spacing,\n        totalDepth: totalDepth,\n        camDist: camDist,\n        targetPos: targetPos,\n        targetLook: targetLook\n      };\n    }\n\n    // Compute fixed camera based on the tab that has the most solutions\n  }, {\n    key: \"computeFixedCameraFromMaxTab\",\n    value: function computeFixedCameraFromMaxTab() {\n      var tabs = ['low', 'mid', 'high', 'rhythmic'];\n      var best = {\n        tab: null,\n        metrics: null\n      };\n      for (var _i = 0, _tabs = tabs; _i < _tabs.length; _i++) {\n        var tab = _tabs[_i];\n        var solids = this.getSolidsByTab(tab);\n        var metrics = this.computeLayoutMetricsForSolids(solids);\n        if (!best.metrics) {\n          best = {\n            tab: tab,\n            metrics: metrics\n          };\n        } else {\n          // Prefer higher count; tiebreaker by larger totalDepth\n          if (metrics.count > best.metrics.count || metrics.count === best.metrics.count && metrics.totalDepth > best.metrics.totalDepth) {\n            best = {\n              tab: tab,\n              metrics: metrics\n            };\n          }\n        }\n      }\n\n      // Fallback if no tab has solids\n      if (!best.metrics) {\n        best.metrics = this.computeLayoutMetricsForSolids([]);\n        best.tab = 'low';\n      }\n      this.fixedCameraTargetPos = best.metrics.targetPos.clone();\n      this.fixedCameraTargetLook = best.metrics.targetLook.clone();\n      console.log('[Evolve] Fixed camera chosen from tab:', best.tab, 'metrics:', {\n        count: best.metrics.count,\n        spacing: best.metrics.spacing,\n        totalDepth: best.metrics.totalDepth,\n        targetPos: {\n          x: this.fixedCameraTargetPos.x,\n          y: this.fixedCameraTargetPos.y,\n          z: this.fixedCameraTargetPos.z\n        },\n        targetLook: {\n          x: this.fixedCameraTargetLook.x,\n          y: this.fixedCameraTargetLook.y,\n          z: this.fixedCameraTargetLook.z\n        }\n      });\n    }\n\n    // Compute a single baseline center-Y from all solids (average of their centers)\n  }, {\n    key: \"computeGlobalBaselineCenterY\",\n    value: function computeGlobalBaselineCenterY() {\n      if (!this.solidMeshes || this.solidMeshes.length === 0) return 0;\n      var box = new three__WEBPACK_IMPORTED_MODULE_1__.Box3();\n      var sum = 0,\n        n = 0;\n      var _iterator2 = _createForOfIteratorHelper(this.solidMeshes),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var m = _step2.value;\n          box.setFromObject(m);\n          var c = box.getCenter(new three__WEBPACK_IMPORTED_MODULE_1__.Vector3());\n          if (Number.isFinite(c.y)) {\n            sum += c.y;\n            n++;\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      return n ? sum / n : 0;\n    }\n\n    // Optional helper to set a fixed baseline at runtime\n  }, {\n    key: \"setInitialBaselineY\",\n    value: function setInitialBaselineY(y) {\n      this.baselineMode = 'fixed';\n      this.fixedBaselineCenterY = y;\n      if (this.isEvolvingMode) {\n        this.globalBaselineCenterY = y;\n        console.log('[Evolve] Baseline switched to fixed:', y);\n        this.transitionToEvolvingLayout(); // re-align current tab\n      }\n    }\n  }, {\n    key: \"enterEvolvingMode\",\n    value: function enterEvolvingMode() {\n      var _this3 = this;\n      // Guard clause\n      if (!this.particleSystem.peaks || this.particleSystem.peaks.length === 0) {\n        console.warn('‚ö†Ô∏è Cannot enter evolving mode - no peaks initialized');\n        return;\n      }\n      console.log('üéÆ Entering evolving mode');\n      this.isEvolvingMode = true;\n      this.storeOriginalPositions();\n\n      // NEW: Change button text and set selected state\n      this.evolveBtn.changeText('EXIT EVOLVE');\n      setTimeout(function () {\n        _this3.evolveBtn.setSelected(true);\n      }, 500);\n\n      // Stop main soundscape and fade out\n      try {\n        var _this$particleSystem;\n        (_this$particleSystem = this.particleSystem) === null || _this$particleSystem === void 0 || (_this$particleSystem = _this$particleSystem.surroundController) === null || _this$particleSystem === void 0 || _this$particleSystem.startMode(500);\n      } catch (_unused) {}\n      if (this.controls) this.controls.enabled = false;\n      if (this.tabsContainer) this.tabsContainer.style.display = 'flex';\n      this.solidMeshes = this.particleSystem.getSolids ? this.particleSystem.getSolids() : this.solidMeshes;\n      this.savedYByTab.clear();\n      this.visitedTabs.clear();\n      this.solidMeshes.forEach(function (m) {\n        delete m.userData.hasUserDragged;\n      });\n      if (this.baselineMode === 'fixed') {\n        this.globalBaselineCenterY = this.fixedBaselineCenterY;\n        console.log('[Evolve] Global baseline center-Y set (fixed) to', this.globalBaselineCenterY);\n      } else {\n        this.globalBaselineCenterY = this.computeGlobalBaselineCenterY();\n        console.log('[Evolve] Global baseline center-Y set (auto-average) to', this.globalBaselineCenterY);\n      }\n      this.computeFixedCameraFromMaxTab();\n      this.loadSolutionsFromParticleSystem();\n      this.alignAllSolidsToBaselineOrSaved();\n      this.transitionToEvolvingLayout();\n      this.solidMeshes.forEach(function (m) {\n        if (m.visible) m.userData.evolvingManualY = true;\n      });\n      this.createSubmitButton();\n    }\n\n    // NEW: Align the vertical center of ALL solids to saved Y (per-tab) or baseline\n  }, {\n    key: \"alignAllSolidsToBaselineOrSaved\",\n    value: function alignAllSolidsToBaselineOrSaved() {\n      var _this$solidMeshes,\n        _this4 = this;\n      if (!((_this$solidMeshes = this.solidMeshes) !== null && _this$solidMeshes !== void 0 && _this$solidMeshes.length)) return;\n      var baselineY = typeof this.globalBaselineCenterY === 'number' ? this.globalBaselineCenterY : 0;\n      var getTabId = function getTabId(mesh) {\n        var _mesh$userData;\n        var cat = (_mesh$userData = mesh.userData) === null || _mesh$userData === void 0 || (_mesh$userData = _mesh$userData.solution) === null || _mesh$userData === void 0 ? void 0 : _mesh$userData.actual_category;\n        return typeof cat === 'string' ? cat.toLowerCase() : null;\n      };\n      var getSavedYForTab = function getSavedYForTab(tabId, mesh) {\n        return _this4.savedYByTab.get(\"\".concat(tabId, \"_\").concat(mesh.uuid));\n      };\n      var _iterator3 = _createForOfIteratorHelper(this.solidMeshes),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var m = _step3.value;\n          var tabId = getTabId(m);\n          if (!tabId || !['low', 'mid', 'high', 'rhythmic'].includes(tabId)) continue;\n          var savedCenterY = getSavedYForTab(tabId, m);\n          var finalCenterY = typeof savedCenterY === 'number' ? savedCenterY : baselineY;\n          m.updateMatrixWorld(true);\n          var b0 = new three__WEBPACK_IMPORTED_MODULE_1__.Box3().setFromObject(m);\n          var c0 = b0.getCenter(new three__WEBPACK_IMPORTED_MODULE_1__.Vector3());\n\n          // Move so center == finalCenterY\n          var dy = finalCenterY - c0.y;\n          if (Math.abs(dy) > 0) {\n            m.position.y += dy;\n            m.updateMatrixWorld(true);\n\n            // snap-correct residue\n            var b1 = new three__WEBPACK_IMPORTED_MODULE_1__.Box3().setFromObject(m);\n            var c1 = b1.getCenter(new three__WEBPACK_IMPORTED_MODULE_1__.Vector3());\n            var err = finalCenterY - c1.y;\n            if (Math.abs(err) > 1e-3) {\n              m.position.y += err;\n              m.updateMatrixWorld(true);\n            }\n\n            // Cache offsets for grain ‚Äútop‚Äù and clamp baseline\n            var sizeAfter = b1.getSize(new three__WEBPACK_IMPORTED_MODULE_1__.Vector3());\n            m.userData.centerOffsetY = c1.y - m.position.y;\n            m.userData.grainClearance = sizeAfter.y * 0.5 + 4.0;\n            m.userData.evolvingBaseY = baselineY;\n\n            // Keep peak Y unchanged; just update manualHeight mapping\n            var peakIndex = this.particleSystem.peakSolids.indexOf(m);\n            if (peakIndex !== -1) {\n              var peak = this.particleSystem.peaks[peakIndex];\n              if (peak) {\n                // DON'T unlock - keep evolvingLock = true\n                // peak.evolvingLock = false;  // <-- REMOVE THIS LINE\n                peak.manualHeight = this.calculateSmoothedHeightFromY(finalCenterY);\n              }\n            }\n          } else {\n            // Even if already aligned, ensure clamp is set\n            m.userData.evolvingBaseY = baselineY;\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    }\n  }, {\n    key: \"exitEvolvingMode\",\n    value: function exitEvolvingMode() {\n      var _this5 = this,\n        _this$particleSystem3,\n        _this$particleSystem4;\n      if (!this.isEvolvingMode) return;\n      console.log('üö™ Exiting evolving mode');\n      this.isEvolvingMode = false;\n\n      // CRITICAL: Stop ALL audio FIRST\n      try {\n        var _this$particleSystem2;\n        (_this$particleSystem2 = this.particleSystem) === null || _this$particleSystem2 === void 0 || (_this$particleSystem2 = _this$particleSystem2.surroundController) === null || _this$particleSystem2 === void 0 || _this$particleSystem2.stopAllManualPlayback();\n      } catch (e) {\n        console.error('Failed to stop audio on evolve exit:', e);\n      }\n\n      // NEW: Change button text back and remove selected state\n      this.evolveBtn.setSelected(false);\n      setTimeout(function () {\n        _this5.evolveBtn.changeText('EVOLVE');\n      }, 300);\n      if (this.controls) this.controls.enabled = true;\n      if (this.tabsContainer) this.tabsContainer.style.display = 'none';\n      if ((_this$particleSystem3 = this.particleSystem) !== null && _this$particleSystem3 !== void 0 && _this$particleSystem3.stopEvolvingAlignment) this.particleSystem.stopEvolvingAlignment();\n      if ((_this$particleSystem4 = this.particleSystem) !== null && _this$particleSystem4 !== void 0 && _this$particleSystem4.clearCategoryVisibility) this.particleSystem.clearCategoryVisibility();\n      this.restoreOriginalLayout();\n      this.solidMeshes.forEach(function (m) {\n        delete m.userData.evolvingManualY;\n      });\n      if (this.submitButton) {\n        this.submitButton.remove();\n        this.submitButton = null;\n      }\n      this.hideNoSolutionsMessage();\n    }\n  }, {\n    key: \"storeOriginalPositions\",\n    value: function storeOriginalPositions() {\n      var _this6 = this;\n      // Store original camera position\n      this.originalCameraPosition.copy(this.mainCamera.position);\n      if (this.controls && this.controls.target) {\n        this.originalCameraTarget.copy(this.controls.target);\n      }\n\n      // Store original solid positions\n      this.originalSolidPositions.clear();\n      this.solidMeshes.forEach(function (m) {\n        _this6.originalSolidPositions.set(m.uuid, {\n          position: m.position.clone(),\n          rotation: m.rotation.clone(),\n          scale: m.scale.clone()\n        });\n      });\n    }\n\n    // Robust center getter\n  }, {\n    key: \"getMeshCenterY\",\n    value: function getMeshCenterY(mesh) {\n      mesh.updateMatrixWorld(true);\n      var b = new three__WEBPACK_IMPORTED_MODULE_1__.Box3().setFromObject(mesh);\n      var c = b.getCenter(new three__WEBPACK_IMPORTED_MODULE_1__.Vector3());\n      return c.y;\n    }\n\n    // Align along Z and vertically align to baseline or saved per-tab Y\n  }, {\n    key: \"transitionToEvolvingLayout\",\n    value: function transitionToEvolvingLayout() {\n      var _this$fixedCameraTarg3,\n        _this$fixedCameraTarg4,\n        _this7 = this,\n        _this$particleSystem5;\n      var filtered = this.getSolidsByTab(this.activeTab);\n\n      // Only show solids in the active tab\n      this.solidMeshes.forEach(function (m) {\n        m.visible = filtered.includes(m);\n      });\n      if (this.particleSystem && typeof this.particleSystem.applyCategoryVisibilityBySolids === 'function') {\n        this.particleSystem.applyCategoryVisibilityBySolids(filtered, 300);\n      }\n\n      // NEW: Handle empty tabs\n      if (filtered.length === 0) {\n        var _this$fixedCameraTarg, _this$fixedCameraTarg2;\n        // Still animate camera to the fixed position\n        var _targetPos = (_this$fixedCameraTarg = this.fixedCameraTargetPos) !== null && _this$fixedCameraTarg !== void 0 ? _this$fixedCameraTarg : new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(70, 10, 0);\n        var _targetLook = (_this$fixedCameraTarg2 = this.fixedCameraTargetLook) !== null && _this$fixedCameraTarg2 !== void 0 ? _this$fixedCameraTarg2 : new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, 0, 0);\n        console.log(\"[Evolve] Tab=\".concat(this.activeTab, \" is empty, moving camera to fixed position\"));\n        this.animateCamera(_targetPos, _targetLook, 800);\n\n        // Show \"no solutions\" message\n        this.showNoSolutionsMessage(this.activeTab);\n        return;\n      }\n\n      // Hide message if there are solutions\n      this.hideNoSolutionsMessage();\n\n      // Camera: fixed for this session\n      var layout = this.computeLayoutMetricsForSolids(filtered);\n      var targetPos = (_this$fixedCameraTarg3 = this.fixedCameraTargetPos) !== null && _this$fixedCameraTarg3 !== void 0 ? _this$fixedCameraTarg3 : layout.targetPos;\n      var targetLook = (_this$fixedCameraTarg4 = this.fixedCameraTargetLook) !== null && _this$fixedCameraTarg4 !== void 0 ? _this$fixedCameraTarg4 : layout.targetLook;\n      console.log(\"[Evolve] Tab=\".concat(this.activeTab, \" camera targetPos=\"), {\n        x: targetPos.x,\n        y: targetPos.y,\n        z: targetPos.z\n      }, 'targetLook=', {\n        x: targetLook.x,\n        y: targetLook.y,\n        z: targetLook.z\n      });\n      this.animateCamera(targetPos, targetLook, 800, function () {\n        console.log(\"[Evolve] Tab=\".concat(_this7.activeTab, \" camera final=\"), {\n          pos: {\n            x: _this7.mainCamera.position.x,\n            y: _this7.mainCamera.position.y,\n            z: _this7.mainCamera.position.z\n          },\n          look: _this7.controls && _this7.controls.target ? {\n            x: _this7.controls.target.x,\n            y: _this7.controls.target.y,\n            z: _this7.controls.target.z\n          } : null\n        });\n      });\n      var baselineY = typeof this.globalBaselineCenterY === 'number' ? this.globalBaselineCenterY : 0;\n      var keyFor = function keyFor(mesh) {\n        return \"\".concat(_this7.activeTab, \"_\").concat(mesh.uuid);\n      };\n      var getSavedY = function getSavedY(mesh) {\n        return _this7.savedYByTab.get(keyFor(mesh));\n      };\n\n      // Vertical align pass with snap-correction\n      filtered.forEach(function (m) {\n        // desired center-Y: saved (if dragged in this tab), else baseline\n        var savedCenterY = getSavedY(m);\n        var finalCenterY = typeof savedCenterY === 'number' ? savedCenterY : baselineY;\n\n        // compute current center\n        m.updateMatrixWorld(true);\n        var b0 = new three__WEBPACK_IMPORTED_MODULE_1__.Box3().setFromObject(m);\n        var c0 = b0.getCenter(new three__WEBPACK_IMPORTED_MODULE_1__.Vector3());\n\n        // move so center == finalCenterY\n        var dy = finalCenterY - c0.y;\n        m.position.y += dy;\n        m.updateMatrixWorld(true);\n\n        // snap-correct any tiny residue due to parenting/rounding\n        var b1 = new three__WEBPACK_IMPORTED_MODULE_1__.Box3().setFromObject(m);\n        var c1 = b1.getCenter(new three__WEBPACK_IMPORTED_MODULE_1__.Vector3());\n        var err = finalCenterY - c1.y;\n        if (Math.abs(err) > 1e-3) {\n          m.position.y += err;\n          m.updateMatrixWorld(true);\n        }\n\n        // Clamp baseline for dragging\n        m.userData.evolvingBaseY = baselineY;\n\n        // Cache offsets so ParticleSystem can compute \"topY\" under the solid (no overlap)\n        var sizeAfter = b1.getSize(new three__WEBPACK_IMPORTED_MODULE_1__.Vector3());\n        m.userData.centerOffsetY = c1.y - m.position.y; // centerY = pos.y + centerOffsetY\n        m.userData.grainClearance = sizeAfter.y * 0.5 + 4.0; // half-height + margin\n\n        // Peak: keep Y unchanged; grains use manualHeight mapping only\n        var peakIndex = _this7.particleSystem.peakSolids.indexOf(m);\n        if (peakIndex !== -1) {\n          var peak = _this7.particleSystem.peaks[peakIndex];\n          if (peak) {\n            peak.evolvingLock = false;\n            peak.manualHeight = _this7.calculateSmoothedHeightFromY(finalCenterY);\n          }\n        }\n      });\n\n      // Arrange peaks along Z only (keep existing Y)\n      var targets = [];\n      filtered.forEach(function (mesh, i) {\n        var targetZ = filtered.length === 1 ? 0 : -layout.totalDepth / 2 + i * layout.spacing;\n        mesh.userData.evolvingIndex = i;\n        var peakIndex = _this7.particleSystem.peakSolids.indexOf(mesh);\n        if (peakIndex !== -1) {\n          var _this7$particleSystem, _this7$particleSystem2;\n          var keepY = (_this7$particleSystem = (_this7$particleSystem2 = _this7.particleSystem.peaks[peakIndex]) === null || _this7$particleSystem2 === void 0 ? void 0 : _this7$particleSystem2.currentPyramidCenter.y) !== null && _this7$particleSystem !== void 0 ? _this7$particleSystem : 0;\n          var targetCenter = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, keepY, targetZ);\n          targets.push({\n            solid: mesh,\n            target: targetCenter\n          });\n          var peak = _this7.particleSystem.peaks[peakIndex];\n          if (peak) delete peak.evolvingLock;\n        }\n      });\n      if (targets.length && (_this$particleSystem5 = this.particleSystem) !== null && _this$particleSystem5 !== void 0 && _this$particleSystem5.startEvolvingAlignmentInstant) {\n        this.particleSystem.startEvolvingAlignmentInstant(targets);\n      }\n\n      // mark this tab as aligned/visited\n      this.visitedTabs.add(this.activeTab);\n    }\n\n    // Animate camera \n  }, {\n    key: \"animateCamera\",\n    value: function animateCamera(targetPos, targetLook) {\n      var _this8 = this;\n      var duration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 800;\n      var onComplete = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n      var startPos = this.mainCamera.position.clone();\n      var startLook = this.controls && this.controls.target ? this.controls.target.clone() : new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();\n      var start = performance.now();\n      var _step4 = function step(now) {\n        var t = Math.min(1, (now - start) / duration);\n        var e = t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;\n        _this8.mainCamera.position.lerpVectors(startPos, targetPos, e);\n        if (_this8.controls && _this8.controls.target) {\n          _this8.controls.target.lerpVectors(startLook, targetLook, e);\n          _this8.controls.update();\n        } else {\n          _this8.mainCamera.lookAt(targetLook);\n        }\n        if (t < 1) {\n          requestAnimationFrame(_step4);\n        } else if (typeof onComplete === 'function') {\n          onComplete();\n        }\n      };\n      requestAnimationFrame(_step4);\n    }\n  }, {\n    key: \"setupInteraction\",\n    value: function setupInteraction() {\n      var _this9 = this;\n      if (this._interactionSetupDone) return;\n      this._interactionSetupDone = true;\n      var canvas = this.mainRenderer.domElement;\n      var raycaster = new three__WEBPACK_IMPORTED_MODULE_1__.Raycaster();\n      var pointer = new three__WEBPACK_IMPORTED_MODULE_1__.Vector2();\n      var pickTopLevelMesh = function pickTopLevelMesh(event) {\n        var rect = canvas.getBoundingClientRect();\n        pointer.x = (event.clientX - rect.left) / rect.width * 2 - 1;\n        pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;\n        raycaster.setFromCamera(pointer, _this9.mainCamera);\n        var visible = _this9.solidMeshes.filter(function (m) {\n          return m.visible;\n        });\n        var hits = raycaster.intersectObjects(visible, true);\n        if (!hits.length) return null;\n        var obj = hits[0].object;\n        while (obj && !_this9.solidMeshes.includes(obj) && obj.parent) obj = obj.parent;\n        return _this9.solidMeshes.includes(obj) ? obj : null;\n      };\n      var onPointerDown = function onPointerDown(e) {\n        var _mesh$userData$soluti, _mesh$userData2;\n        if (!_this9.isEvolvingMode) return;\n        e.preventDefault();\n        e.stopPropagation();\n\n        // Stop anything that might still be playing (mirrors SaveMode)\n        try {\n          var _this9$particleSystem;\n          (_this9$particleSystem = _this9.particleSystem) === null || _this9$particleSystem === void 0 || (_this9$particleSystem = _this9$particleSystem.surroundController) === null || _this9$particleSystem === void 0 || _this9$particleSystem.stopAllManualPlayback();\n        } catch (err) {\n          console.error('Failed to stop audio before drag start:', err);\n        }\n        var mesh = pickTopLevelMesh(e);\n        if (!mesh || mesh.userData.evolvingIndex === undefined) return;\n        _this9.drag.active = true;\n        _this9.drag.mesh = mesh;\n        _this9.drag.startPointerY = e.clientY;\n        _this9.drag.startY = mesh.position.y;\n        var box = new three__WEBPACK_IMPORTED_MODULE_1__.Box3().setFromObject(mesh);\n        mesh.userData.dragStartCenterY = box.getCenter(new three__WEBPACK_IMPORTED_MODULE_1__.Vector3()).y;\n        if (mesh.userData.evolvingBaseY === undefined) {\n          mesh.userData.evolvingBaseY = _this9.globalBaselineCenterY;\n        }\n        _this9.drag.peakIndex = _this9.particleSystem.peakSolids.indexOf(mesh);\n        var id = (_mesh$userData$soluti = mesh === null || mesh === void 0 || (_mesh$userData2 = mesh.userData) === null || _mesh$userData2 === void 0 || (_mesh$userData2 = _mesh$userData2.solution) === null || _mesh$userData2 === void 0 ? void 0 : _mesh$userData2.id) !== null && _mesh$userData$soluti !== void 0 ? _mesh$userData$soluti : null;\n        _this9.drag.playingId = id;\n        if (id != null) {\n          try {\n            var _this9$particleSystem2;\n            (_this9$particleSystem2 = _this9.particleSystem) === null || _this9$particleSystem2 === void 0 || (_this9$particleSystem2 = _this9$particleSystem2.surroundController) === null || _this9$particleSystem2 === void 0 || _this9$particleSystem2.playLoopForMesh(id, mesh);\n          } catch (err) {\n            console.error('Failed to start loop during drag:', err);\n          }\n        }\n        canvas.style.cursor = 'grabbing';\n      };\n      var onPointerMove = function onPointerMove(e) {\n        var _this9$drag$mesh$user;\n        if (!_this9.drag.active || !_this9.drag.mesh) return;\n        var deltaPixels = _this9.drag.startPointerY - e.clientY;\n        var newY = _this9.drag.startY + deltaPixels * _this9.dragYScale;\n\n        // Clamp: cannot go below global baseline (only upwards)\n        var b = new three__WEBPACK_IMPORTED_MODULE_1__.Box3().setFromObject(_this9.drag.mesh);\n        var currentCenter = b.getCenter(new three__WEBPACK_IMPORTED_MODULE_1__.Vector3());\n        var centerOffset = currentCenter.y - _this9.drag.mesh.position.y;\n        var minCenterY = _this9.drag.mesh.userData.evolvingBaseY;\n        var maxCenterY = _this9.scoreArea.maxY;\n        var minPosY = minCenterY - centerOffset;\n        var maxPosY = maxCenterY - centerOffset;\n        newY = Math.max(minPosY, Math.min(maxPosY, newY));\n\n        // Move solid\n        _this9.drag.mesh.position.y = newY;\n        _this9.drag.mesh.userData.evolvingManualY = true;\n\n        // New center after move\n        var b2 = new three__WEBPACK_IMPORTED_MODULE_1__.Box3().setFromObject(_this9.drag.mesh);\n        var newCenter = b2.getCenter(new three__WEBPACK_IMPORTED_MODULE_1__.Vector3());\n        _this9.setSavedYForActiveTab(_this9.drag.mesh, newCenter.y);\n        var moved = Math.abs(((_this9$drag$mesh$user = _this9.drag.mesh.userData.dragStartCenterY) !== null && _this9$drag$mesh$user !== void 0 ? _this9$drag$mesh$user : newCenter.y) - newCenter.y) > 0.05;\n        if (moved) _this9.drag.mesh.userData.hasUserDragged = true;\n\n        // Update grains distribution mapping only (keep peak XZ locked)\n        if (Number.isInteger(_this9.drag.peakIndex) && _this9.drag.peakIndex >= 0) {\n          var peak = _this9.particleSystem.peaks[_this9.drag.peakIndex];\n          if (peak) {\n            // DON'T unlock the peak - keep evolvingLock = true\n            // peak.evolvingLock = false;  // <-- REMOVE THIS LINE\n            peak.manualHeight = _this9.smoothedHeightFromY(newCenter.y);\n          }\n        }\n        var idx = _this9.drag.mesh.userData.evolvingIndex;\n        var scoreKey = \"\".concat(_this9.activeTab, \"_\").concat(idx);\n        var score = _this9.calculateScoreFromY(newCenter.y);\n        _this9.allTabScores.set(scoreKey, score);\n        _this9.updateSubmitButton();\n        e.preventDefault();\n      };\n      var endDrag = function endDrag(e) {\n        if (!_this9.drag.active) return;\n        e && e.preventDefault();\n        if (_this9.drag.mesh) {\n          var _this9$drag$mesh$user2;\n          var box = new three__WEBPACK_IMPORTED_MODULE_1__.Box3().setFromObject(_this9.drag.mesh);\n          var currentCenterY = box.getCenter(new three__WEBPACK_IMPORTED_MODULE_1__.Vector3()).y;\n          var moved = Math.abs(((_this9$drag$mesh$user2 = _this9.drag.mesh.userData.dragStartCenterY) !== null && _this9$drag$mesh$user2 !== void 0 ? _this9$drag$mesh$user2 : currentCenterY) - currentCenterY) > 0.05;\n          if (moved) _this9.drag.mesh.userData.hasUserDragged = true;\n          delete _this9.drag.mesh.userData.dragStartCenterY;\n\n          // REMOVED: Stop audio on drag end - let it continue playing\n          // try {\n          //     this.particleSystem?.surroundController?.stopAllManualPlayback();\n          // } catch (err) {\n          //     console.error('Failed to stop audio after drag:', err);\n          // }\n        }\n        _this9.drag.active = false;\n        // Keep reference to playing mesh so we can highlight it\n        // this.drag.mesh = null;  // DON'T clear the mesh yet\n        _this9.drag.peakIndex = undefined;\n        canvas.style.cursor = '';\n      };\n      canvas.addEventListener('pointerdown', onPointerDown);\n      window.addEventListener('pointermove', onPointerMove);\n      window.addEventListener('pointerup', endDrag);\n      window.addEventListener('pointerleave', endDrag);\n    }\n\n    // Persist per-tab center Y for a mesh\n  }, {\n    key: \"setSavedYForActiveTab\",\n    value: function setSavedYForActiveTab(mesh, centerY) {\n      var key = \"\".concat(this.activeTab, \"_\").concat(mesh.uuid);\n      this.savedYByTab.set(key, centerY);\n    }\n  }, {\n    key: \"getSavedYForActiveTab\",\n    value: function getSavedYForActiveTab(mesh) {\n      return this.savedYByTab.get(\"\".concat(this.activeTab, \"_\").concat(mesh.uuid));\n    }\n  }, {\n    key: \"updateSubmitButton\",\n    value: function updateSubmitButton() {\n      if (!this.submitButton) return;\n      var total = this.allTabScores.size;\n      if (total > 0) {\n        this.submitButton.classList.add('enabled');\n        this.submitButton.textContent = 'Submit Scores'; // REMOVED: (${total})\n      } else {\n        this.submitButton.classList.remove('enabled');\n        this.submitButton.textContent = 'Submit Scores';\n      }\n    }\n  }, {\n    key: \"createSubmitButton\",\n    value: function createSubmitButton() {\n      var _this10 = this;\n      if (this.submitButton) return; // Prevent duplicates\n      var submitButton = document.createElement('button');\n      submitButton.textContent = 'Submit Scores'; // REMOVED: solution count\n      submitButton.className = 'evolving-submit-button';\n      submitButton.addEventListener('click', function () {\n        _this10.submitScores();\n      });\n      document.body.appendChild(submitButton);\n      this.submitButton = submitButton;\n      this.updateSubmitButton();\n    }\n    // Low-sensitivity score from Y:\n    // - baseline (globalBaselineCenterY) maps to 0\n    // - scoreArea.maxY maps to 1\n    // - uses sine easing for gentler mid-range slope\n    // - quantized to 0.05 steps to avoid jitter\n  }, {\n    key: \"calculateScoreFromY\",\n    value: function calculateScoreFromY(y) {\n      var minY = typeof this.globalBaselineCenterY === 'number' ? this.globalBaselineCenterY : this.scoreArea.minY;\n      var maxY = this.scoreArea.maxY;\n      var range = Math.max(1e-6, maxY - minY);\n      var n = Math.max(0, Math.min(1, (y - minY) / range));\n      var eased = 0.5 - 0.5 * Math.cos(Math.PI * n);\n\n      // Quantize to reduce sensitivity\n      var step = 0.05;\n      var quantized = Math.round(eased / step) * step;\n\n      // Final clamp \n      var score = Math.max(0, Math.min(1, this.scoreArea.minScore + quantized * (this.scoreArea.maxScore - this.scoreArea.minScore)));\n      return score;\n    }\n\n    // Build scores for a specific tab using current mesh center Y\n  }, {\n    key: \"collectScoresForTab\",\n    value: function collectScoresForTab(tabId) {\n      var _this11 = this;\n      var solids = this.getSolidsByTab(tabId);\n      return solids.map(function (m) {\n        var _m$userData$solution$, _m$userData2;\n        var y = _this11.getMeshCenterY(m);\n        var score = _this11.calculateScoreFromY(y);\n        var id = (_m$userData$solution$ = (_m$userData2 = m.userData) === null || _m$userData2 === void 0 || (_m$userData2 = _m$userData2.solution) === null || _m$userData2 === void 0 ? void 0 : _m$userData2.id) !== null && _m$userData$solution$ !== void 0 ? _m$userData$solution$ : m.uuid;\n        return {\n          id: id,\n          category: tabId,\n          score: score\n        };\n      });\n    }\n\n    // Gather scores for all tabs\n  }, {\n    key: \"collectAllTabScores\",\n    value: function collectAllTabScores() {\n      var _this12 = this;\n      var tabs = ['low', 'mid', 'high', 'rhythmic'];\n      var all = [];\n      tabs.forEach(function (tab) {\n        all = all.concat(_this12.collectScoresForTab(tab));\n      });\n      return all;\n    }\n\n    // Replace getGlobalIndexForMesh with a string-id version\n  }, {\n    key: \"getGlobalIndexForMesh\",\n    value: function getGlobalIndexForMesh(mesh) {\n      var _mesh$userData3;\n      var rawId = mesh === null || mesh === void 0 || (_mesh$userData3 = mesh.userData) === null || _mesh$userData3 === void 0 || (_mesh$userData3 = _mesh$userData3.solution) === null || _mesh$userData3 === void 0 ? void 0 : _mesh$userData3.id;\n      var id = rawId != null ? String(rawId) : null;\n      if (id && this.idToGlobalIndex.has(id)) return this.idToGlobalIndex.get(id);\n\n      // Fallback: search categorized lists that carry globalIndex\n      for (var _i2 = 0, _Object$keys = Object.keys(this.categoryMeshes); _i2 < _Object$keys.length; _i2++) {\n        var cat = _Object$keys[_i2];\n        var entry = this.categoryMeshes[cat].find(function (e) {\n          var _e$solution;\n          return String((_e$solution = e.solution) === null || _e$solution === void 0 ? void 0 : _e$solution.id) === id;\n        });\n        if (entry && Number.isInteger(entry.globalIndex)) return entry.globalIndex;\n      }\n      // Last resort: find in allSolutions by id\n      if (id) {\n        var idx = this.allSolutions.findIndex(function (s) {\n          return String(s === null || s === void 0 ? void 0 : s.id) === id;\n        });\n        if (idx >= 0) return idx;\n      }\n      return -1;\n    }\n\n    // Build feedback array (unopened tabs treated as baseline/unscored)\n    // Replace buildFeedbackArray() so only real drags count as scored\n  }, {\n    key: \"buildFeedbackArray\",\n    value: function buildFeedbackArray() {\n      var _this13 = this;\n      var tabs = ['low', 'mid', 'high', 'rhythmic'];\n      var feedback = [];\n      var baseline = typeof this.globalBaselineCenterY === 'number' ? this.globalBaselineCenterY : this.scoreArea.minY;\n      tabs.forEach(function (tabId) {\n        var solids = _this13.getSolidsByTab(tabId);\n        solids.forEach(function (mesh, localIndex) {\n          var _mesh$userData$soluti2, _mesh$userData4;\n          var solutionId = (_mesh$userData$soluti2 = (_mesh$userData4 = mesh.userData) === null || _mesh$userData4 === void 0 || (_mesh$userData4 = _mesh$userData4.solution) === null || _mesh$userData4 === void 0 ? void 0 : _mesh$userData4.id) !== null && _mesh$userData$soluti2 !== void 0 ? _mesh$userData$soluti2 : mesh.uuid;\n          var globalIndex = _this13.getGlobalIndexForMesh(mesh);\n          var key = \"\".concat(tabId, \"_\").concat(mesh.uuid);\n          var hasSaved = _this13.savedYByTab.has(key);\n          var yNow = _this13.getMeshCenterY(mesh);\n          var yForScore = hasSaved ? _this13.savedYByTab.get(key) : yNow;\n\n          // Only count as scored if the user actually dragged this item\n          var was_scored = mesh.userData.hasUserDragged === true;\n\n          // If scored, compute a gentle score from Y; otherwise 0\n          var user_score = was_scored ? _this13.calculateScoreFromY(yForScore) : 0.0;\n          feedback.push({\n            global_index: globalIndex,\n            local_index: localIndex,\n            solution_id: solutionId,\n            category: tabId,\n            was_scored: was_scored,\n            user_score: Number(user_score.toFixed(3))\n          });\n        });\n      });\n      return feedback;\n    }\n  }, {\n    key: \"submitScores\",\n    value: function submitScores() {\n      var _this$pythonCommunica, _this$pythonCommunica2, _this$pythonCommunica3, _this$allSolutions;\n      if (!((_this$pythonCommunica = this.pythonCommunication) !== null && _this$pythonCommunica !== void 0 && _this$pythonCommunica.sendUserFeedback)) return;\n      var generation = (_this$pythonCommunica2 = (_this$pythonCommunica3 = this.pythonCommunication).getCurrentGeneration) === null || _this$pythonCommunica2 === void 0 ? void 0 : _this$pythonCommunica2.call(_this$pythonCommunica3);\n      if (generation !== undefined) {\n        this.currentGeneration = generation;\n      }\n      if (this.submissionLocked && this.currentGeneration === this.lastSubmittedGeneration) {\n        this.showSubmissionMessage('Scores of this generation already submitted', true);\n        return;\n      }\n\n      // CRITICAL: Set transition flag to block ALL keyboard events during submission\n      window.__modeTransitioning = true;\n      var payload = {\n        action: 'user_feedback',\n        type: 'user_scoring',\n        current_tab: this.activeTab,\n        total_solutions: ((_this$allSolutions = this.allSolutions) === null || _this$allSolutions === void 0 ? void 0 : _this$allSolutions.length) || 0,\n        actually_scored_solutions: _toConsumableArray(this.allTabScores.values()).filter(Boolean).length,\n        all_solutions_included: true,\n        feedback: this.buildFeedbackArray()\n      };\n      var ok = this.pythonCommunication.sendUserFeedback(payload);\n\n      // Clear transition flag after short delay\n      setTimeout(function () {\n        window.__modeTransitioning = false;\n      }, 500);\n      if (ok === false) {\n        this.showSubmissionMessage('Could not submit scores', true);\n        return;\n      }\n      this.submissionLocked = true;\n      this.lastSubmittedGeneration = this.currentGeneration;\n      this.showSubmissionMessage('Scores submitted successfully!');\n      this.updateSubmitButton();\n    }\n  }, {\n    key: \"calculateSmoothedHeightFromY\",\n    value: function calculateSmoothedHeightFromY(y) {\n      var n = Math.max(0, Math.min(1, (y - this.scoreArea.minY) / (this.scoreArea.maxY - this.scoreArea.minY)));\n      return 2 + n * 10;\n    }\n  }, {\n    key: \"smoothedHeightFromY\",\n    value: function smoothedHeightFromY(screenY, screenH) {\n      var ndc = 1.0 - screenY / screenH * 2.0;\n      var t = (ndc + 1.0) / 2.0;\n      var smoothT = t * t * (3.0 - 2.0 * t);\n      return smoothT * (this.evolveLayoutTop - this.evolveLayoutBottom) + this.evolveLayoutBottom;\n    }\n  }, {\n    key: \"switchTab\",\n    value: function switchTab(tabId) {\n      if (this.activeTab === tabId) return;\n      console.log(\"\\uD83D\\uDD04 Switching tab from \".concat(this.activeTab, \" to \").concat(tabId));\n\n      // CRITICAL: Stop ALL audio (not just drag state)\n      try {\n        var _this$particleSystem6;\n        (_this$particleSystem6 = this.particleSystem) === null || _this$particleSystem6 === void 0 || (_this$particleSystem6 = _this$particleSystem6.surroundController) === null || _this$particleSystem6 === void 0 || _this$particleSystem6.stopAllManualPlayback();\n      } catch (e) {\n        console.error('Failed to stop audio on tab switch:', e);\n      }\n\n      // Clear drag state\n      if (this.drag) {\n        this.drag.playingId = null;\n        this.drag.active = false;\n        this.drag.mesh = null;\n      }\n      this.activeTab = tabId;\n      var tabButtons = this.tabsContainer.querySelectorAll('.evolve-tab-button');\n      tabButtons.forEach(function (btn) {\n        btn.classList.toggle('active', btn.dataset.value === tabId);\n      });\n      if (this.isEvolvingMode) {\n        this.solidMeshes.forEach(function (m) {\n          if (m.userData.animationId) {\n            cancelAnimationFrame(m.userData.animationId);\n            m.userData.animationId = null;\n          }\n        });\n        this.transitionToEvolvingLayout();\n      }\n    }\n  }, {\n    key: \"loadSolutionsFromParticleSystem\",\n    value: function loadSolutionsFromParticleSystem() {\n      var _this14 = this;\n      console.log('Loading solutions from particle system...');\n      if (this.pythonCommunication && this.pythonCommunication.getCurrentSolutions) {\n        this.allSolutions = this.pythonCommunication.getCurrentSolutions();\n      } else {\n        this.allSolutions = this.particleSystem.currentSolutions || [];\n      }\n      this.solidMeshes = this.particleSystem.getSolids ? this.particleSystem.getSolids() : [];\n      this.numSolids = this.solidMeshes.length;\n      if (this.allSolutions.length === 0) {\n        console.warn('No solutions available from particle system');\n        return;\n      }\n\n      // Build id -> global index map\n      this.idToGlobalIndex.clear();\n      this.allSolutions.forEach(function (sol, idx) {\n        if ((sol === null || sol === void 0 ? void 0 : sol.id) != null) _this14.idToGlobalIndex.set(sol.id, idx);\n      });\n\n      // Clear existing category storage\n      Object.keys(this.categoryMeshes).forEach(function (category) {\n        _this14.categoryMeshes[category] = [];\n      });\n\n      // Categorize solutions\n      this.allSolutions.forEach(function (solution, globalIndex) {\n        var category = solution.actual_category;\n        if (typeof category === 'string') category = category.toLowerCase();\n        if (['low', 'mid', 'high', 'rhythmic'].includes(category)) {\n          _this14.categoryMeshes[category].push({\n            solution: solution,\n            globalIndex: globalIndex\n          });\n        }\n      });\n      console.log('Solutions categorized:', this.categoryMeshes);\n    }\n  }, {\n    key: \"restoreOriginalLayout\",\n    value: function restoreOriginalLayout() {\n      var _this15 = this;\n      this.animateCamera(this.originalCameraPosition.clone(), this.originalCameraTarget.clone(), 800);\n      this.solidMeshes.forEach(function (m) {\n        if (m.userData.animationId) {\n          cancelAnimationFrame(m.userData.animationId);\n          m.userData.animationId = null;\n        }\n        var orig = _this15.originalSolidPositions.get(m.uuid);\n        if (orig) {\n          m.position.copy(orig.position);\n          m.rotation.copy(orig.rotation);\n          m.scale.copy(orig.scale);\n        }\n        m.visible = true;\n        delete m.userData.evolvingIndex;\n        m.userData.isEvolvingFrozen = false;\n        delete m.userData.evolvingTargetPosition;\n        delete m.userData.evolvingAnimation;\n        delete m.userData.evolvingManualY;\n        delete m.userData.evolvingBaseY;\n      });\n    }\n  }, {\n    key: \"showNoSolutionsMessage\",\n    value: function showNoSolutionsMessage(category) {\n      // Remove existing message if any\n      this.hideNoSolutionsMessage();\n\n      // Create message overlay\n      this.noSolutionsMessage = document.createElement('div');\n      this.noSolutionsMessage.className = 'no-solutions-message';\n      this.noSolutionsMessage.innerHTML = \"\\n        <div class=\\\"no-solutions-content\\\">\\n            <p>No solutions in this category</p>\\n        </div>\\n    \";\n      document.body.appendChild(this.noSolutionsMessage);\n      console.log(\"[Evolve] Showing no solutions message for category: \".concat(category));\n    }\n  }, {\n    key: \"hideNoSolutionsMessage\",\n    value: function hideNoSolutionsMessage() {\n      if (this.noSolutionsMessage) {\n        this.noSolutionsMessage.remove();\n        this.noSolutionsMessage = null;\n      }\n    }\n\n    // In EvolvingUI.js, update handleEvolveCategoryClick (around line 250)\n  }, {\n    key: \"handleEvolveCategoryClick\",\n    value: function handleEvolveCategoryClick(categoryName, e) {\n      var _e$target;\n      e === null || e === void 0 || e.stopPropagation();\n      console.log(\"\\uD83E\\uDDEC User requested evolution for category: \".concat(categoryName));\n\n      // Visual feedback on button (optional)\n      var btn = e === null || e === void 0 || (_e$target = e.target) === null || _e$target === void 0 ? void 0 : _e$target.closest('.evolve-category-btn');\n      if (btn) {\n        btn.classList.add('evolving');\n        btn.textContent = 'Evolving...';\n        btn.disabled = true; // Prevent multiple clicks\n      }\n\n      // Request evolution (will trigger onEvolutionStart callback in main.js)\n      var success = this.pythonComm.requestEvolution(categoryName);\n      if (success) {\n        console.log(\"\\u2705 Evolution request sent for \".concat(categoryName));\n      } else {\n        console.error('‚ùå Failed to send evolution request');\n\n        // Reset button if request failed\n        if (btn) {\n          btn.classList.remove('evolving');\n          btn.textContent = \"Evolve \".concat(categoryName);\n          btn.disabled = false;\n        }\n      }\n\n      // Note: Button will be reset when new generation data arrives\n      // (EvolvingUI.transitionToEvolvingLayout will recreate the UI)\n    }\n  }]);\n}();\n\n//# sourceURL=webpack://sound-particle-visualization/./src/components/EvolvingUI.js?");

/***/ }),

/***/ "./src/components/GeometricSolid.js":
/*!******************************************!*\
  !*** ./src/components/GeometricSolid.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createGeometricSolid: () => (/* binding */ createGeometricSolid)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\nfunction _createForOfIteratorHelper(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\n\nfunction createGeometricSolid(solution, renderer, onMaterialReady) {\n  var audioParams = solution.parameters;\n  var descriptors = solution.descriptors;\n  console.log(\"\\uD83C\\uDFA8 Creating solid for solution \".concat(solution.id, \" with real parameters:\"), audioParams);\n  var baseRadius = three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.mapLinear(audioParams.room_size, 0.01, 0.4, 1.5, 4);\n  var geometry = new three__WEBPACK_IMPORTED_MODULE_0__.IcosahedronGeometry(2.5, 2);\n\n  // --- Vertex welding with CORRECTED descriptor reference ---\n  var pos = geometry.attributes.position;\n  var vertexMap = new Map();\n  for (var i = 0; i < pos.count; i++) {\n    var key = \"\".concat(pos.getX(i).toFixed(5), \",\").concat(pos.getY(i).toFixed(5), \",\").concat(pos.getZ(i).toFixed(5));\n    if (!vertexMap.has(key)) vertexMap.set(key, []);\n    vertexMap.get(key).push(i);\n  }\n  vertexMap.forEach(function (indices) {\n    var i = indices[0];\n    var x = pos.getX(i);\n    var y = pos.getY(i);\n    var z = pos.getZ(i);\n    var len = Math.sqrt(x * x + y * y + z * z);\n    var nx = x / len;\n    var ny = y / len;\n    var nz = z / len;\n    var pitchVarianceNormalized = (audioParams.pitch_variance + 0.05) / 0.1; // 0-1 range\n    var spectralFluxNormalized = Math.min(descriptors.spectral_flux / 1700, 1); // 0-1 range\n\n    var deform = (Math.random() - 0.5) * pitchVarianceNormalized * 1.4 // Reduced impact\n    + (Math.random() - 0.5) * spectralFluxNormalized * 1.4; // Much smaller impact\n    var _iterator = _createForOfIteratorHelper(indices),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var idx = _step.value;\n        pos.setXYZ(idx, x + nx * deform, y + ny * deform, z + nz * deform);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  });\n  geometry.computeVertexNormals();\n\n  // --- Color calculation with actual parameter ranges ---\n  // wet_level: 0.05 to 0.3\n  // overlap: 0.58 to 10.0  \n  // grain_duration: 0.1 to 1.0\n\n  var wetLevelNormalized = (audioParams.wet_level - 0.05) / 0.25; // 0-1 range\n  var overlapNormalized = Math.min((audioParams.overlap - 0.5) / 9.5, 1); // 0-1 range\n  var grainDurationNormalized = (audioParams.grain_duration - 0.1) / 0.9; // 0-1 range\n\n  var baseHue = 0.65 + 0.1 * (1 - wetLevelNormalized); //  hue shift (0.62-0.68)\n  var baseSaturation = 0.4 + 0.1 * overlapNormalized; // saturation (0.4-0.5)\n  var baseLightness = 0.4 + 0.05 * wetLevelNormalized; //  lightness (0.4-0.45)\n\n  var wireframeColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color().setHSL(baseHue, baseSaturation, baseLightness);\n  var material = new three__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial({\n    color: wireframeColor,\n    wireframe: true,\n    transparent: false,\n    opacity: 0.7 + 0.1 * grainDurationNormalized,\n    //  opacity variation (0.7-0.8)\n    emissive: wireframeColor.clone().multiplyScalar(0.05),\n    emissiveIntensity: 0.5 + grainDurationNormalized * 0.05,\n    // (0.5-0.55)\n    metalness: 0.6,\n    roughness: 0.3,\n    flatShading: false,\n    fog: true,\n    side: three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide\n  });\n\n  // Stabilize color updates\n  var stableColor = wireframeColor.clone();\n  material.color = stableColor;\n\n  // Create mesh\n  var mesh = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(geometry, material);\n\n  // **Scale adjustment based on actual grain_duration range (0.1 to 1.0)**\n  mesh.scale.y = 1.0 + grainDurationNormalized * 1.2; // Much more subtle (1.0-1.5)\n  mesh.layers.enable(1);\n\n  // **Store solution data with the mesh**\n  mesh.userData.solution = solution;\n  mesh.userData.solutionId = solution.id;\n  mesh.userData.audioParams = audioParams;\n  mesh.userData.descriptors = descriptors;\n  mesh.userData.fitness = solution.fitness;\n  mesh.userData.category = solution.assigned_category;\n\n  // --- Orbiting clones based on actual num_voices range (2.0 to 8.0) ---\n  if (audioParams.num_voices > 1) {\n    var group = new three__WEBPACK_IMPORTED_MODULE_0__.Group();\n    group.add(mesh);\n\n    // **Store solution data with group as well**\n    group.userData.solution = solution;\n    group.userData.solutionId = solution.id;\n    group.userData.audioParams = audioParams;\n    group.userData.descriptors = descriptors;\n    group.userData.fitness = solution.fitness;\n    group.userData.category = solution.assigned_category;\n    group.userData.orbitClones = [];\n    group.userData.orbitBaseRadius = baseRadius * 2.5;\n    group.userData.orbitSpeed = 0.15 + Math.random() * 0.15;\n\n    // **Normalize num_voices (2-8 range)**\n    var numVoicesNormalized = (audioParams.num_voices - 2) / 6; // 0-1 range\n    var maxClones = Math.min(Math.floor(audioParams.num_voices), 8);\n    for (var _i = 1; _i < maxClones; _i++) {\n      var clone = mesh.clone();\n      clone.position.y = Math.random() * 0.8;\n\n      // **Overlap range: 0.58 to 10.0**\n      var overlapForScale = Math.min((audioParams.overlap - 0.5) / 9.5, 1); // 0-1 range\n      var cloneScale = 0.15 + overlapForScale * 0.05; //  (0.15-0.2)\n      clone.scale.set(cloneScale, cloneScale, cloneScale);\n      clone.userData.orbitAngle = _i / maxClones * Math.PI * 2;\n      clone.userData.mass = cloneScale * cloneScale;\n      clone.userData.orbitalVelocity = 0.1 + (1 - cloneScale) * 0.1;\n      clone.userData.verticalOscillation = cloneScale * 0.3;\n\n      // Clone material and apply same envMap\n      clone.material = material.clone();\n      clone.material.envMap = material.envMap; // Share the same envMap\n\n      var hueShift = _i / maxClones * 0.01;\n      clone.material.color.setHSL(baseHue + hueShift, baseSaturation * 0.95, baseLightness + 0.02);\n      clone.material.emissive = clone.material.color.clone().multiplyScalar(0.03);\n\n      // Enable bloom for clones\n      clone.layers.enable(1);\n      clone.material.emissiveIntensity = 0.15 + grainDurationNormalized * 0.05;\n      group.add(clone);\n      group.userData.orbitClones.push(clone);\n    }\n    group.userData.update = function (elapsed) {\n      mesh.rotation.y = elapsed * 0.2;\n      for (var _i2 = 0; _i2 < group.userData.orbitClones.length; _i2++) {\n        var _clone = group.userData.orbitClones[_i2];\n        var baseAngle = _clone.userData.orbitAngle + elapsed * group.userData.orbitSpeed;\n        var mass = _clone.userData.mass;\n        var orbitalVel = _clone.userData.orbitalVelocity;\n        var verticalOsc = _clone.userData.verticalOscillation;\n        var angle = baseAngle + Math.sin(elapsed * orbitalVel) * (1 - mass) * 0.3;\n        var radius = group.userData.orbitBaseRadius * (0.8 + mass * 0.4);\n        _clone.position.x = Math.cos(angle) * radius;\n        _clone.position.z = Math.sin(angle) * radius;\n        _clone.position.y = Math.sin(elapsed * 1.5 + _i2) * verticalOsc * 0.5;\n        _clone.rotation.z = -angle * (2 - mass);\n        _clone.rotation.y = elapsed * 0.3 * (2 - mass);\n      }\n    };\n    return group;\n  }\n  mesh.userData.update = function (elapsed) {\n    mesh.rotation.z = elapsed * 0.2;\n  };\n  return mesh;\n}\n\n//# sourceURL=webpack://sound-particle-visualization/./src/components/GeometricSolid.js?");

/***/ }),

/***/ "./src/components/Library.js":
/*!***********************************!*\
  !*** ./src/components/Library.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Library: () => (/* binding */ Library)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n/* harmony import */ var _Button_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Button.js */ \"./src/components/Button.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _createForOfIteratorHelper(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = \"function\" == typeof Symbol ? Symbol : {}, a = i.iterator || \"@@iterator\", c = i.asyncIterator || \"@@asyncIterator\", u = i.toStringTag || \"@@toStringTag\"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, \"\"); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, \"_invoke\", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: \"normal\", arg: t.call(e, r) }; } catch (t) { return { type: \"throw\", arg: t }; } } e.wrap = wrap; var h = \"suspendedStart\", l = \"suspendedYield\", f = \"executing\", s = \"completed\", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { [\"next\", \"throw\", \"return\"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if (\"throw\" !== c.type) { var u = c.arg, h = u.value; return h && \"object\" == _typeof(h) && n.call(h, \"__await\") ? e.resolve(h.__await).then(function (t) { invoke(\"next\", t, i, a); }, function (t) { invoke(\"throw\", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke(\"throw\", t, i, a); }); } a(c.arg); } var r; o(this, \"_invoke\", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error(\"Generator is already running\"); if (o === s) { if (\"throw\" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if (\"next\" === n.method) n.sent = n._sent = n.arg;else if (\"throw\" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else \"return\" === n.method && n.abrupt(\"return\", n.arg); o = f; var p = tryCatch(e, r, n); if (\"normal\" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } \"throw\" === p.type && (o = s, n.method = \"throw\", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, \"throw\" === n && e.iterator[\"return\"] && (r.method = \"return\", r.arg = t, maybeInvokeDelegate(e, r), \"throw\" === r.method) || \"return\" !== n && (r.method = \"throw\", r.arg = new TypeError(\"The iterator does not provide a '\" + n + \"' method\")), y; var i = tryCatch(o, e.iterator, r.arg); if (\"throw\" === i.type) return r.method = \"throw\", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, \"return\" !== r.method && (r.method = \"next\", r.arg = t), r.delegate = null, y) : a : (r.method = \"throw\", r.arg = new TypeError(\"iterator result is not an object\"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = \"normal\", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: \"root\" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || \"\" === e) { var r = e[a]; if (r) return r.call(e); if (\"function\" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + \" is not iterable\"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, \"GeneratorFunction\"), e.isGeneratorFunction = function (t) { var e = \"function\" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || \"GeneratorFunction\" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, \"GeneratorFunction\")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, \"Generator\"), define(g, a, function () { return this; }), define(g, \"toString\", function () { return \"[object Generator]\"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) \"t\" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if (\"throw\" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = \"throw\", a.arg = e, r.next = n, o && (r.method = \"next\", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if (\"root\" === i.tryLoc) return handle(\"end\"); if (i.tryLoc <= this.prev) { var c = n.call(i, \"catchLoc\"), u = n.call(i, \"finallyLoc\"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error(\"try statement without catch or finally\"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, \"finallyLoc\") && this.prev < o.finallyLoc) { var i = o; break; } } i && (\"break\" === t || \"continue\" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = \"next\", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if (\"throw\" === t.type) throw t.arg; return \"break\" === t.type || \"continue\" === t.type ? this.next = t.arg : \"return\" === t.type ? (this.rval = this.arg = t.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, \"catch\": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if (\"throw\" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, \"next\" === this.method && (this.arg = t), y; } }, e; }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }\nfunction _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"next\", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"throw\", n); } _next(void 0); }); }; }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\nvar Library = /*#__PURE__*/function () {\n  function Library(particleSystem, scene, camera, renderer, controls) {\n    var _this = this,\n      _particleSystem$grain,\n      _particleSystem$baseR,\n      _particleSystem$grain2,\n      _particleSystem$defau;\n    _classCallCheck(this, Library);\n    this.particleSystem = particleSystem;\n    this.scene = scene;\n    this.camera = camera;\n    this.renderer = renderer;\n    this.controls = controls;\n\n    // Saved items here: { id, type: 'solution'|'combination', name, description, category, items?, meshSnapshot:Object3D }\n    this.libraryData = [];\n\n    // Space mode state\n    this.inSpace = false;\n    this.group = new three__WEBPACK_IMPORTED_MODULE_1__.Group();\n    this.group.name = 'LibraryGroup';\n    this.cols = 6; // default columns for grid\n    this.spacingX = 20; // horizontal spacing\n    this.spacingZ = 22; // depth spacing\n    this.baseY = 0; // center Y for all items\n    this.snapScale = 1.0; // global snapshot scale factor\n    this._camRestore = null;\n\n    // Picking\n    this._raycaster = new three__WEBPACK_IMPORTED_MODULE_1__.Raycaster();\n    this._pointer = new three__WEBPACK_IMPORTED_MODULE_1__.Vector2();\n    this._onPointerDown = this._handlePointerDown.bind(this);\n    this._onPointerMove = this._handlePointerMove.bind(this);\n    this._onPointerLeave = this._handlePointerLeave.bind(this);\n\n    // Info panel near selected mesh\n    this._panel = this._createInfoPanel();\n    this._lastPanelMesh = null;\n    this.selectedItem = null;\n\n    // Hover/selection state\n    this._hoveredContainer = null;\n    this._selectedContainer = null;\n    this._isEditingName = false;\n    this._isEditingDesc = false;\n\n    // UI entry point\n    this.createLibraryButton();\n    window.addEventListener('resize', function () {\n      if (_this.inSpace) _this._positionInfoPanel();\n    });\n\n    // Library swarms (grains) runtime\n    this._libItems = []; // [{ container, solid, grains:[], params:{ baseRadius, baseY, topY } }]\n    this.libraryGrainsPerSolid = (_particleSystem$grain = particleSystem === null || particleSystem === void 0 ? void 0 : particleSystem.grainsPerVisiblePeak) !== null && _particleSystem$grain !== void 0 ? _particleSystem$grain : 300;\n    this.libraryBaseRadius = (_particleSystem$baseR = particleSystem === null || particleSystem === void 0 ? void 0 : particleSystem.baseRadius) !== null && _particleSystem$baseR !== void 0 ? _particleSystem$baseR : 2;\n    this.libraryGrainColumnHeight = (_particleSystem$grain2 = particleSystem === null || particleSystem === void 0 ? void 0 : particleSystem.grainColumnHeight) !== null && _particleSystem$grain2 !== void 0 ? _particleSystem$grain2 : 6.0;\n    this.libraryGrainClearance = (_particleSystem$defau = particleSystem === null || particleSystem === void 0 ? void 0 : particleSystem.defaultGrainClearance) !== null && _particleSystem$defau !== void 0 ? _particleSystem$defau : 1.0;\n\n    // Track hidden main-scene objects while in space\n    this._hiddenMainGrains = [];\n    this._hiddenMainSolids = [];\n    this._pointerOverPanel = false;\n    this._panelEditDepth = 0;\n    this.nameMaxLength = 60;\n    this.descriptionMaxLength = 200;\n    this.nameVerticalThreshold = 18; // NEW\n  }\n\n  // Public: toggle\n  return _createClass(Library, [{\n    key: \"toggleLibrarySpace\",\n    value: function toggleLibrarySpace() {\n      if (this.inSpace) this.exitSpace();else this.enterSpace();\n    }\n  }, {\n    key: \"enterSpace\",\n    value: function enterSpace() {\n      var _this2 = this;\n      if (this.inSpace || !this.scene || !this.camera || !this.renderer) return;\n      this.inSpace = true;\n\n      // NEW: Change button text and set selected state\n      this.libraryBtn.changeText('EXIT LIBRARY');\n      setTimeout(function () {\n        _this2.libraryBtn.setSelected(true);\n      }, 500);\n\n      // Fade out main scene sounds and stop sequencing\n      try {\n        var _this$particleSystem;\n        (_this$particleSystem = this.particleSystem) === null || _this$particleSystem === void 0 || (_this$particleSystem = _this$particleSystem.surroundController) === null || _this$particleSystem === void 0 || _this$particleSystem.startMode(500);\n      } catch (_unused) {}\n      try {\n        var solids = this.particleSystem.getSolids ? this.particleSystem.getSolids() : [];\n        solids.forEach(function (m) {\n          _this2._hiddenMainSolids.push({\n            mesh: m,\n            prev: m.visible\n          });\n          m.visible = false;\n        });\n      } catch (e) {}\n      try {\n        var _this$particleSystem2;\n        if ((_this$particleSystem2 = this.particleSystem) !== null && _this$particleSystem2 !== void 0 && _this$particleSystem2.peaks) {\n          this.particleSystem.peaks.forEach(function (peak) {\n            if (!(peak !== null && peak !== void 0 && peak.grains)) return;\n            peak.grains.forEach(function (g) {\n              if (!g) return;\n              _this2._hiddenMainGrains.push({\n                grain: g,\n                prev: g.visible\n              });\n              g.visible = false;\n            });\n          });\n        }\n      } catch (e) {}\n\n      // Build grid content\n      if (!this.group.parent) this.scene.add(this.group);\n      this._buildGridFromLibraryData();\n      this._camRestore = {\n        pos: this.camera.position.clone(),\n        target: this.controls ? this.controls.target.clone() : new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, 0, 0)\n      };\n      this._animateCameraTopDown();\n\n      // Enable picking + hover\n      this.renderer.domElement.addEventListener('pointerdown', this._onPointerDown);\n      this.renderer.domElement.addEventListener('pointermove', this._onPointerMove);\n      this.renderer.domElement.addEventListener('mouseleave', this._onPointerLeave);\n\n      // Hide any existing panel until user picks\n      this._hideInfoPanel();\n      this._lastPanelMesh = null;\n      this.selectedItem = null;\n    }\n  }, {\n    key: \"exitSpace\",\n    value: function exitSpace() {\n      var _this3 = this;\n      if (!this.inSpace) return;\n      this.inSpace = false;\n\n      // NEW: Change button text back and remove selected state\n      this.libraryBtn.setSelected(false);\n      setTimeout(function () {\n        _this3.libraryBtn.changeText('LIBRARY');\n      }, 300);\n\n      // Resume main scene sequential soundscape\n      try {\n        var _this$particleSystem3;\n        (_this$particleSystem3 = this.particleSystem) === null || _this$particleSystem3 === void 0 || (_this$particleSystem3 = _this$particleSystem3.surroundController) === null || _this$particleSystem3 === void 0 || _this$particleSystem3.resumeMainMode(5);\n      } catch (_unused2) {}\n\n      // Remove library group\n      if (this.group.parent) this.scene.remove(this.group);\n\n      // Restore main solids visibility\n      try {\n        this._hiddenMainSolids.forEach(function (_ref) {\n          var mesh = _ref.mesh,\n            prev = _ref.prev;\n          if (mesh) mesh.visible = prev;\n        });\n        this._hiddenMainSolids = [];\n      } catch (e) {}\n\n      // Restore grains visibility\n      try {\n        this._hiddenMainGrains.forEach(function (_ref2) {\n          var grain = _ref2.grain,\n            prev = _ref2.prev;\n          if (grain) grain.visible = prev;\n        });\n        this._hiddenMainGrains = [];\n      } catch (e) {}\n\n      // Restore camera\n      if (this._camRestore) {\n        this._animateCameraTo(this._camRestore.pos, this._camRestore.target, 800);\n        this._camRestore = null;\n      }\n\n      // Disable picking/hover and panel\n      this.renderer.domElement.removeEventListener('pointerdown', this._onPointerDown);\n      this.renderer.domElement.removeEventListener('pointermove', this._onPointerMove);\n      this.renderer.domElement.removeEventListener('mouseleave', this._onPointerLeave);\n      this._clearHoverOutline();\n      this._clearSelectionOutline();\n      this._hideInfoPanel();\n      this._lastPanelMesh = null;\n      this.selectedItem = null;\n    }\n\n    // Call from your main animate loop\n  }, {\n    key: \"update\",\n    value: function update() {\n      if (!this.inSpace) return;\n      this._updateLibrarySolidsAnimation();\n      this._updateLibraryGrains();\n    }\n  }, {\n    key: \"addItem\",\n    value: function addItem(item) {\n      // Normalize the solution ID for consistent comparison\n      var normalizedSolutionId = null;\n      if (item.type === 'solution') {\n        var _item$solutionData;\n        // Try multiple sources for the ID\n        normalizedSolutionId = ((_item$solutionData = item.solutionData) === null || _item$solutionData === void 0 ? void 0 : _item$solutionData.id) || item.solutionId || item.id || (item.solid ? item.solid.uuid : null); // Fallback to mesh UUID\n      }\n\n      // **FIX: Extract category from multiple sources with priority**\n      var categoryValue = '';\n      if (item.type === 'solution') {\n        var _item$solid, _item$solutionData2, _item$audioParams;\n        // Priority: explicit category > solid.userData > solutionData\n        categoryValue = item.category || ((_item$solid = item.solid) === null || _item$solid === void 0 || (_item$solid = _item$solid.userData) === null || _item$solid === void 0 ? void 0 : _item$solid.category) || ((_item$solutionData2 = item.solutionData) === null || _item$solutionData2 === void 0 ? void 0 : _item$solutionData2.actual_category) || ((_item$audioParams = item.audioParams) === null || _item$audioParams === void 0 ? void 0 : _item$audioParams.category) || '';\n      } else if (item.type === 'combination') {\n        // For combinations, keep items array intact (don't extract category here)\n        categoryValue = item.category || '';\n      }\n      var record = {\n        id: item.id || Date.now(),\n        type: item.type || 'solution',\n        name: item.name || '(unnamed)',\n        description: item.description || '',\n        category: categoryValue ? String(categoryValue).toLowerCase() : '',\n        // **FIX: Use extracted category**\n        items: Array.isArray(item.items) ? item.items : undefined,\n        // **IMPORTANT: Keep items array for combinations**\n        meshSnapshot: null,\n        // Store BOTH fields for consistent lookup\n        solutionId: normalizedSolutionId,\n        solutionData: item.solutionData || null\n      };\n      var sourceMesh = null;\n      if (record.type === 'solution') {\n        sourceMesh = item.solid || null;\n      } else if (record.type === 'combination' && Array.isArray(item.items) && item.items.length) {\n        var pick = item.items[Math.floor(Math.random() * item.items.length)];\n        sourceMesh = (pick === null || pick === void 0 ? void 0 : pick.solid) || item.solid || null;\n      }\n      if (sourceMesh) {\n        var materialsSnapshot = item.materialsSnapshot || this._captureMaterialsFromSolid(sourceMesh);\n        record.meshSnapshot = this._cloneSolid(sourceMesh, materialsSnapshot);\n      }\n      this.libraryData.push(record);\n\n      // Live update grid if in space\n      if (this.inSpace) this._buildGridFromLibraryData();\n    }\n\n    // ============== grid building ==============\n  }, {\n    key: \"_buildGridFromLibraryData\",\n    value: function _buildGridFromLibraryData() {\n      var _this4 = this;\n      // Clear current group\n      while (this.group.children.length) this.group.remove(this.group.children[0]);\n      this._libItems = [];\n      var items = this.libraryData;\n      if (!items.length) return;\n      var cols = Math.max(2, Math.min(this.cols, Math.ceil(Math.sqrt(items.length))));\n      var spacingX = this.spacingX;\n      var spacingZ = this.spacingZ;\n      items.forEach(function (item, idx) {\n        var snap = item.meshSnapshot ? item.meshSnapshot.clone(true) : null;\n        if (!snap) return;\n        snap.traverse(function (ch) {\n          if (ch.isMesh) ch.matrixAutoUpdate = true;\n        });\n        snap.updateMatrixWorld(true);\n        var primary = _this4._findPrimaryMesh(snap) || snap;\n        primary.updateMatrixWorld(true);\n        var pBox = new three__WEBPACK_IMPORTED_MODULE_1__.Box3().setFromObject(primary);\n        var pSize = pBox.getSize(new three__WEBPACK_IMPORTED_MODULE_1__.Vector3());\n        var pCenter = pBox.getCenter(new three__WEBPACK_IMPORTED_MODULE_1__.Vector3());\n        var pBottom = pCenter.y - pSize.y * 0.5;\n\n        // Wrap into a container; center horizontally using PRIMARY center\n        var container = new three__WEBPACK_IMPORTED_MODULE_1__.Group();\n        container.name = \"LibraryItem_\".concat(item.id);\n        snap.position.x -= pCenter.x;\n        snap.position.z -= pCenter.z;\n\n        // Desired bottom of primary above grains\n        var baseY = _this4.baseY;\n        var topY = baseY + _this4.libraryGrainColumnHeight;\n        var desiredBottom = topY + _this4.libraryGrainClearance;\n        var deltaY = desiredBottom - pBottom;\n        snap.position.y += deltaY;\n\n        // Place container on the grid\n        var r = Math.floor(idx / cols);\n        var c = idx % cols;\n        container.position.set((c - (cols - 1) / 2) * spacingX, 0, r * spacingZ);\n\n        // Tag and add\n        container.userData.__libraryItem = item;\n        container.userData.__libraryIsSnapshot = true;\n        container.userData.__solidRoot = snap;\n        container.add(snap);\n        _this4.group.add(container);\n\n        // Build runtime for grains and animation\n        var runtime = {\n          container: container,\n          solid: snap,\n          primary: _this4._findPrimaryMesh(snap),\n          orbitClones: [],\n          grains: [],\n          params: {\n            baseY: baseY,\n            topY: topY,\n            baseRadius: _this4.libraryBaseRadius\n          }\n        };\n        if (runtime.primary) {\n          var primaryPos = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();\n          runtime.primary.getWorldPosition(primaryPos);\n          snap.traverse(function (n) {\n            if (n.isMesh && n !== runtime.primary && n.userData && n.userData.orbitAngle !== undefined) {\n              var clonePos = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();\n              n.getWorldPosition(clonePos);\n              var radius = Math.hypot(clonePos.x - primaryPos.x, clonePos.z - primaryPos.z);\n              n.userData._libOrbitRadius = radius;\n              n.userData._libHeightOffset = n.position.y - runtime.primary.position.y;\n              runtime.orbitClones.push(n);\n            }\n          });\n        }\n\n        // Rebind/update animation functions for this clone tree\n        _this4._retargetUpdateFunctionsForClone(runtime);\n\n        // Create grains centered exactly under container\n        _this4._createLibraryGrainsForItem(runtime);\n        _this4._libItems.push(runtime);\n      });\n      this.group.position.set(0, 0, -20);\n    }\n  }, {\n    key: \"_createLibraryGrainsForItem\",\n    value: function _createLibraryGrainsForItem(runtime) {\n      var container = runtime.container,\n        params = runtime.params;\n      var count = this.libraryGrainsPerSolid;\n      var minRadius = 0.8 * params.baseRadius;\n      var maxRadius = params.baseRadius * 2.5;\n      var sharedGeom = new three__WEBPACK_IMPORTED_MODULE_1__.SphereGeometry(0.09, 8, 8);\n      var makeMaterial = function makeMaterial() {\n        return new three__WEBPACK_IMPORTED_MODULE_1__.MeshStandardMaterial({\n          color: 0xe0dbc1,\n          emissive: 0xe0dbc1,\n          emissiveIntensity: 0.3,\n          transparent: true,\n          opacity: 0.8\n        });\n      };\n      for (var j = 0; j < count; j++) {\n        var mat = makeMaterial();\n        var grain = new three__WEBPACK_IMPORTED_MODULE_1__.Mesh(sharedGeom, mat);\n        grain.layers.enable(1);\n        var heightFactor = Math.random();\n        var angle = Math.random() * Math.PI * 2;\n        var randomization = [];\n        for (var r = 0; r < 4; r++) randomization.push(0.3 + 0.4 * Math.random());\n        var baseAccel = 0.08 + 0.10 * Math.random();\n        var baseSpeed = 0.025 + 0.050 * Math.random();\n        var maxSpeed = 0.05 + 0.18 * Math.random();\n        var baseRad = minRadius + (1 - heightFactor) * (maxRadius - minRadius);\n        var cx = container.position.x;\n        var cz = container.position.z;\n        grain.userData = {\n          heightFactor: heightFactor,\n          angle: angle,\n          randomization: randomization,\n          transitionSeed: Math.random() * 100,\n          baseAccel: baseAccel,\n          baseSpeed: baseSpeed,\n          maxSpeed: maxSpeed,\n          velocity: new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(),\n          acceleration: new three__WEBPACK_IMPORTED_MODULE_1__.Vector3()\n        };\n\n        // Initial placement within the column range\n        var initialY = params.baseY + heightFactor * (params.topY - params.baseY);\n        grain.position.set(cx + baseRad * Math.cos(angle), Math.max(0.1, initialY), cz + baseRad * Math.sin(angle));\n        this.group.add(grain);\n        runtime.grains.push(grain);\n      }\n    }\n  }, {\n    key: \"_updateLibraryGrains\",\n    value: function _updateLibraryGrains() {\n      var t = performance.now() * 0.001;\n      for (var k = 0; k < this._libItems.length; k++) {\n        var runtime = this._libItems[k];\n        var container = runtime.container,\n          solid = runtime.solid,\n          grains = runtime.grains,\n          params = runtime.params;\n        if (!container || !solid || !grains || !grains.length) continue;\n\n        // Recompute topY from solid‚Äôs current transform to stay precise\n        var _this$_computeSolidGr = this._computeSolidGrainTopY(solid, params.baseY),\n          topY = _this$_computeSolidGr.topY;\n        params.topY = topY;\n        var cx = container.position.x;\n        var cz = container.position.z;\n        for (var j = 0; j < grains.length; j++) {\n          var grain = grains[j];\n          if (!grain || !grain.userData) continue;\n          var _grain$userData = grain.userData,\n            heightFactor = _grain$userData.heightFactor,\n            angle = _grain$userData.angle,\n            randomization = _grain$userData.randomization;\n          var minRadius = 0.8 * params.baseRadius;\n          var maxRadius = params.baseRadius * 2.5;\n          var baseRadius = minRadius + (1 - heightFactor) * (maxRadius - minRadius);\n          var wanderAngle = angle + Math.sin(t * (0.15 + 0.4 * randomization[0]) + j) * 2.5 + Math.cos(t * (0.2 + 0.3 * randomization[1]) + j * 0.5) * 1.8;\n          var wanderRadius = baseRadius + Math.sin(t * (0.12 + 0.2 * randomization[2]) + j * 0.3) * 0.4 + Math.cos(t * (0.1 + 0.25 * randomization[3]) + j * 0.25) * 0.5;\n          var range = Math.max(0.1, params.topY - params.baseY);\n          var noise = (Math.sin(t * (0.18 + 0.25 * randomization[1]) + j * 0.2) * 0.12 + Math.cos(t * (0.22 + 0.15 * randomization[2]) + j * 0.15) * 0.08) * range * 0.2;\n          var wanderHeight = params.baseY + heightFactor * range + noise;\n          if (wanderHeight > params.topY) wanderHeight = params.topY - 0.02;\n          if (wanderHeight < params.baseY) wanderHeight = params.baseY + 0.02;\n          var vagueTarget = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(cx + wanderRadius * Math.cos(wanderAngle), Math.max(0.1, wanderHeight), cz + wanderRadius * Math.sin(wanderAngle));\n          if (!grain.userData.velocity) grain.userData.velocity = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();\n          if (!grain.userData.acceleration) grain.userData.acceleration = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();\n          var toVague = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3().subVectors(vagueTarget, grain.position);\n          var springStrength = grain.userData.baseAccel * 0.12;\n          grain.userData.acceleration.copy(toVague).multiplyScalar(springStrength);\n          var fromCenter = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(grain.position.x - cx, 0, grain.position.z - cz);\n          var distFromCenter = fromCenter.length();\n          if (distFromCenter > 0.001) {\n            var up = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, 1, 0);\n            var orbitDir = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3().crossVectors(fromCenter, up).normalize();\n            var orbitSpeed = 0.4 + 0.08 * randomization[0];\n            var orbitPhase = t * orbitSpeed + grain.userData.transitionSeed;\n            var orbitAmount = 0.15 + 0.12 * Math.sin(orbitPhase + j * 0.2);\n            if (!grain.userData.orbitDeviation || t - (grain.userData.lastDeviationTime || 0) > 1.5 + Math.random() * 1.5) {\n              grain.userData.orbitDeviation = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3((Math.random() - 0.5) * 0.15, (Math.random() - 0.5) * 0.25, (Math.random() - 0.5) * 0.2);\n              grain.userData.lastDeviationTime = t;\n            }\n            orbitDir.add(grain.userData.orbitDeviation.clone().multiplyScalar(0.3)).normalize();\n            grain.userData.acceleration.add(orbitDir.multiplyScalar(orbitAmount));\n            grain.userData.acceleration.y += Math.sin(orbitPhase + j * 0.3) * 0.03;\n          }\n          grain.userData.velocity.add(grain.userData.acceleration);\n          grain.userData.velocity.multiplyScalar(0.88);\n          var maxSpeed = grain.userData.maxSpeed * 1.8;\n          if (grain.userData.velocity.length() > maxSpeed) {\n            grain.userData.velocity.setLength(maxSpeed);\n          }\n          grain.position.add(grain.userData.velocity);\n        }\n      }\n    }\n  }, {\n    key: \"_computeSolidGrainTopY\",\n    value: function _computeSolidGrainTopY(solid, baseY) {\n      // Use primary mesh bounds (ignore orbiting clones)\n      var primary = this._findPrimaryMesh(solid) || solid;\n      primary.updateMatrixWorld(true);\n      var bb = new three__WEBPACK_IMPORTED_MODULE_1__.Box3().setFromObject(primary);\n      var size = bb.getSize(new three__WEBPACK_IMPORTED_MODULE_1__.Vector3());\n      var center = bb.getCenter(new three__WEBPACK_IMPORTED_MODULE_1__.Vector3());\n      var clearance = size.y * 0.5 + this.libraryGrainClearance;\n\n      // center.y is world center; convert to solid-local: centerY = solid.position.y + offset\n      var centerOffsetY = center.y - solid.position.y;\n      var centerY = solid.position.y + centerOffsetY;\n      var topY = centerY - clearance;\n      return {\n        topY: Math.max(baseY + 0.25, topY)\n      };\n    }\n\n    // ============== Camera animation ==============\n  }, {\n    key: \"_animateCameraTopDown\",\n    value: function _animateCameraTopDown() {\n      var items = this.libraryData;\n      var cols = Math.max(2, Math.min(this.cols, Math.ceil(Math.sqrt(items.length || 1))));\n      var rows = Math.max(1, Math.ceil(items.length / cols));\n      var gridWidth = (cols - 1) * this.spacingX;\n      var gridDepth = Math.max(1, rows - 1) * this.spacingZ;\n\n      // Center of the grid\n      var center = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, 0, (rows - 1) * this.spacingZ * 0.5 - 20);\n      var distance = Math.max(30, Math.max(gridWidth, gridDepth)) * 2.0;\n      var height = distance * 1.2;\n      var xOff = 0;\n      var zOff = distance;\n      var pos = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(center.x + xOff, height, center.z + zOff);\n\n      // Look at the center of the grid\n      this._animateCameraTo(pos, center, 800);\n    }\n  }, {\n    key: \"_animateCameraTo\",\n    value: function _animateCameraTo(pos, lookAt) {\n      var _this5 = this;\n      var duration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 800;\n      var startPos = this.camera.position.clone();\n      var startTarget = this.controls ? this.controls.target.clone() : new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();\n      var start = performance.now();\n      var _tick = function tick(now) {\n        var t = Math.min(1, (now - start) / duration);\n        var ease = 0.5 - 0.5 * Math.cos(Math.PI * t);\n        _this5.camera.position.lerpVectors(startPos, pos, ease);\n        if (_this5.controls) {\n          var tgt = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3().lerpVectors(startTarget, lookAt, ease);\n          _this5.controls.target.copy(tgt);\n          _this5.controls.update();\n        } else {\n          _this5.camera.lookAt(lookAt);\n        }\n        if (t < 1) requestAnimationFrame(_tick);\n      };\n      requestAnimationFrame(_tick);\n    }\n  }, {\n    key: \"_animateCameraToItem\",\n    value: function _animateCameraToItem(container) {\n      if (!container) return;\n\n      // Get the world position and bounds of the selected item\n      var box = new three__WEBPACK_IMPORTED_MODULE_1__.Box3().setFromObject(container);\n      var center = box.getCenter(new three__WEBPACK_IMPORTED_MODULE_1__.Vector3());\n      var size = box.getSize(new three__WEBPACK_IMPORTED_MODULE_1__.Vector3());\n\n      // Calculate camera position to show item on LEFT side of screen\n      var maxDim = Math.max(size.x, size.y, size.z);\n      var distance = maxDim * 3.5;\n\n      // Position camera to show solid on left 40% of screen\n      var cameraPos = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(center.x + distance * 0.7,\n      // Offset right so object appears left\n      center.y + distance * 0.4,\n      // Elevated view\n      center.z + distance * 0.8 // Pull back\n      );\n\n      // Animate camera smoothly\n      this._animateCameraTo(cameraPos, center, 600);\n    }\n\n    // ============== UI ==============\n  }, {\n    key: \"createLibraryButton\",\n    value: function createLibraryButton() {\n      this.libraryBtn = new _Button_js__WEBPACK_IMPORTED_MODULE_0__.Button('LIBRARY', 'hamburger', function () {});\n    }\n\n    // ============== Picking ==============\n  }, {\n    key: \"_handlePointerDown\",\n    value: function _handlePointerDown(e) {\n      if (!this.inSpace) return;\n      if (this._pointerOverPanel) {\n        return; // NEW: ignore clicks while pointer is over panel\n      }\n      var panel = this._panel;\n      if (panel && panel.style.display !== 'none') {\n        var rect = panel.getBoundingClientRect();\n        if (e.clientX >= rect.left && e.clientX <= rect.right && e.clientY >= rect.top && e.clientY <= rect.bottom) {\n          return; // Safety net if pointer flag misses\n        }\n      }\n      var viewport = this.renderer.domElement.getBoundingClientRect();\n      this._pointer.x = (e.clientX - viewport.left) / viewport.width * 2 - 1;\n      this._pointer.y = -((e.clientY - viewport.top) / viewport.height) * 2 + 1;\n      this._raycaster.setFromCamera(this._pointer, this.camera);\n      var hits = this._raycaster.intersectObjects(this.group.children, true);\n      if (!hits.length) {\n        this._clearSelectionOutline();\n        this._hideInfoPanel();\n        this._lastPanelMesh = null;\n        this.selectedItem = null;\n        this._animateCameraTopDown(); // Now safe - only called for canvas clicks\n        return;\n      }\n      var obj = hits[0].object;\n      while (obj && obj.parent && obj.parent !== this.group) obj = obj.parent;\n      if (!obj || !obj.userData || !obj.userData.__libraryItem) return;\n\n      // Toggle selection\n      if (this._selectedContainer === obj) {\n        this._clearSelectionOutline();\n        this._hideInfoPanel();\n        this._lastPanelMesh = null;\n        this.selectedItem = null;\n        this._animateCameraTopDown(); // Return to grid view\n        return;\n      }\n      this._applySelectionOutline(obj);\n      this._openInfoPanelFor(obj, obj.userData.__libraryItem);\n\n      // Animate camera to focus on selected item (left side of screen)\n      this._animateCameraToItem(obj);\n    }\n  }, {\n    key: \"_handlePointerMove\",\n    value: function _handlePointerMove(e) {\n      if (!this.inSpace) return;\n      var rect = this.renderer.domElement.getBoundingClientRect();\n      this._pointer.x = (e.clientX - rect.left) / rect.width * 2 - 1;\n      this._pointer.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;\n      this._raycaster.setFromCamera(this._pointer, this.camera);\n      var hits = this._raycaster.intersectObjects(this.group.children, true);\n      if (!hits.length) {\n        this._clearHoverOutline();\n        return;\n      }\n      var obj = hits[0].object;\n      while (obj && obj.parent && obj.parent !== this.group) obj = obj.parent;\n      if (!obj || !obj.userData || !obj.userData.__libraryItem) {\n        this._clearHoverOutline();\n        return;\n      }\n      if (this._selectedContainer === obj) {\n        this._clearHoverOutline();\n        return;\n      }\n      if (this._hoveredContainer !== obj) {\n        this._applyHoverOutline(obj);\n      }\n    }\n  }, {\n    key: \"_handlePointerLeave\",\n    value: function _handlePointerLeave() {\n      if (!this.inSpace) return;\n      this._clearHoverOutline();\n    }\n\n    // ============== Mesh + materials cloning ==============\n  }, {\n    key: \"_captureMaterialsFromSolid\",\n    value: function _captureMaterialsFromSolid(src) {\n      var map = Object.create(null);\n      src.traverse(function (node) {\n        var _node$userData, _node$userData2, _node$userData3;\n        if (!node.isMesh) return;\n        var base = ((_node$userData = node.userData) === null || _node$userData === void 0 ? void 0 : _node$userData.__saveModeBaseMaterial) || ((_node$userData2 = node.userData) === null || _node$userData2 === void 0 ? void 0 : _node$userData2.__saveModeMaterialOriginal) || ((_node$userData3 = node.userData) === null || _node$userData3 === void 0 ? void 0 : _node$userData3.originalMaterial) || node.material;\n        map[node.uuid] = Array.isArray(base) ? base.slice() : base;\n      });\n      return map;\n    }\n  }, {\n    key: \"_cloneMaterialDeep\",\n    value: function _cloneMaterialDeep(mat) {\n      var _this6 = this;\n      if (Array.isArray(mat)) return mat.map(function (m) {\n        return _this6._cloneMaterialDeep(m);\n      });\n      if (!mat) return mat;\n      if (mat.isShaderMaterial && three__WEBPACK_IMPORTED_MODULE_1__.UniformsUtils) {\n        var cloned = mat.clone();\n        cloned.uniforms = three__WEBPACK_IMPORTED_MODULE_1__.UniformsUtils.clone(mat.uniforms || {});\n        cloned.defines = mat.defines ? _objectSpread({}, mat.defines) : cloned.defines;\n        return cloned;\n      }\n      return mat.clone ? mat.clone() : new three__WEBPACK_IMPORTED_MODULE_1__.MeshStandardMaterial({\n        color: 0xffffff\n      });\n    }\n  }, {\n    key: \"_applyMaterialsToClone\",\n    value: function _applyMaterialsToClone(sourceRoot, cloneRoot, materialsSnapshot) {\n      var srcNodes = [];\n      var cloneNodes = [];\n      sourceRoot.traverse(function (n) {\n        return srcNodes.push(n);\n      });\n      cloneRoot.traverse(function (n) {\n        return cloneNodes.push(n);\n      });\n      for (var i = 0; i < srcNodes.length; i++) {\n        var s = srcNodes[i];\n        var c = cloneNodes[i];\n        if (s !== null && s !== void 0 && s.isMesh && c !== null && c !== void 0 && c.isMesh) {\n          var snap = materialsSnapshot === null || materialsSnapshot === void 0 ? void 0 : materialsSnapshot[s.uuid];\n          if (snap !== undefined) {\n            c.material = this._cloneMaterialDeep(snap);\n          } else {\n            var baseMat = s.userData && s.userData.originalMaterial ? s.userData.originalMaterial : s.material;\n            c.material = this._cloneMaterialDeep(baseMat);\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_cloneSolid\",\n    value: function _cloneSolid(src, materialsSnapshot) {\n      try {\n        var clone = src.clone(true);\n        this._applyMaterialsToClone(src, clone, materialsSnapshot);\n\n        // Keep update hooks; we will rebind later\n        clone.traverse(function (n) {\n          if (n.isMesh) n.matrixAutoUpdate = true;\n        });\n        clone.updateMatrixWorld(true);\n        return clone;\n      } catch (e) {\n        console.warn('Failed to clone solid for library snapshot:', e);\n        return null;\n      }\n    }\n\n    // ============== Info panel ==============\n  }, {\n    key: \"_createInfoPanel\",\n    value: function _createInfoPanel() {\n      var existing = document.querySelector('.library-space-panel');\n      if (existing) {\n        this._attachPanelGuards(existing); // NEW\n        existing.style.display = 'none';\n        return existing;\n      }\n      var el = document.createElement('div');\n      el.className = 'library-space-panel';\n      this._attachPanelGuards(el);\n      document.body.appendChild(el);\n      return el;\n    }\n  }, {\n    key: \"_attachPanelGuards\",\n    value: function _attachPanelGuards(panel) {\n      var _this7 = this;\n      if (panel.__hasLibraryGuards) return;\n      panel.addEventListener('pointerenter', function () {\n        _this7._pointerOverPanel = true;\n      });\n      panel.addEventListener('pointerleave', function () {\n        _this7._pointerOverPanel = false;\n      });\n      panel.__hasLibraryGuards = true;\n    }\n  }, {\n    key: \"_renderPanelContents\",\n    value: function _renderPanelContents(item) {\n      var _this8 = this;\n      var isCombo = item.type === 'combination';\n      var categoryLabel = '';\n      if (isCombo) {\n        var cats = Array.isArray(item.items) ? item.items.map(function (it) {\n          var _it$solid, _it$solutionData, _it$audioParams;\n          return it.category || ((_it$solid = it.solid) === null || _it$solid === void 0 || (_it$solid = _it$solid.userData) === null || _it$solid === void 0 ? void 0 : _it$solid.category) || ((_it$solutionData = it.solutionData) === null || _it$solutionData === void 0 ? void 0 : _it$solutionData.actual_category) || ((_it$audioParams = it.audioParams) === null || _it$audioParams === void 0 ? void 0 : _it$audioParams.category) || '';\n        }).filter(Boolean) : [];\n        var pretty = this._uniqueCapCategories(cats);\n        categoryLabel = pretty.length ? pretty.join(' - ') : 'Combination';\n      } else {\n        var _item$solid2, _item$solutionData3, _item$audioParams2;\n        var cat = item.category || ((_item$solid2 = item.solid) === null || _item$solid2 === void 0 || (_item$solid2 = _item$solid2.userData) === null || _item$solid2 === void 0 ? void 0 : _item$solid2.category) || ((_item$solutionData3 = item.solutionData) === null || _item$solutionData3 === void 0 ? void 0 : _item$solutionData3.actual_category) || ((_item$audioParams2 = item.audioParams) === null || _item$audioParams2 === void 0 ? void 0 : _item$audioParams2.category) || '';\n        categoryLabel = cat ? this._capitalizeFirst(String(cat)) : '';\n      }\n      var name = this._sanitizeName(item.name);\n      var description = this._sanitizeDescription(item.description);\n      var descHTML = description ? \"<div class=\\\"library-description committed\\\" data-editable=\\\"description\\\">\".concat(this._escapeHTML(description), \"</div>\") : \"<div class=\\\"library-description committed library-desc-placeholder\\\" data-editable=\\\"description\\\">Insert description here</div>\";\n      this._panel.innerHTML = \"\\n        <button class=\\\"library-close-btn\\\" type=\\\"button\\\" title=\\\"Close\\\">\\xD7</button>\\n        <h3 class=\\\"library-name\\\" data-editable=\\\"name\\\" title=\\\"Click to edit name\\\">\\n            \".concat(this._escapeHTML(name), \"\\n        </h3>\\n        \").concat(categoryLabel ? \"<div class=\\\"library-category-label\\\">\".concat(this._escapeHTML(categoryLabel), \"</div>\") : '', \"\\n        \").concat(descHTML, \"\\n        <div class=\\\"library-info-actions\\\">\\n            <button class=\\\"library-info-btn-play\\\" type=\\\"button\\\" data-action=\\\"play\\\" title=\\\"Play\\\">\\n                <img src=\\\"/assets/icons/Play.svg\\\" alt=\\\"Play\\\" class=\\\"library-btn-icon-play\\\">\\n                <span>Play Sound</span>\\n            </button>\\n            <button class=\\\"library-info-btn secondary\\\" type=\\\"button\\\" data-action=\\\"export\\\" title=\\\"Export\\\">\\n                <img src=\\\"/assets/icons/Export.svg\\\" alt=\\\"Export\\\" class=\\\"library-btn-icon\\\">\\n                <span>Export Audio</span>\\n            </button>\\n        </div>\\n    \");\n\n      // Wire up interactions\n      var closeBtn = this._panel.querySelector('.library-close-btn');\n      var nameEl = this._panel.querySelector('[data-editable=\"name\"]');\n      var descEls = this._panel.querySelectorAll('[data-editable=\"description\"]');\n      var playBtn = this._panel.querySelector('[data-action=\"play\"]');\n      var exportBtn = this._panel.querySelector('.library-info-btn[data-action=\"export\"]');\n      if (closeBtn) {\n        closeBtn.onclick = function (e) {\n          e.stopPropagation();\n          _this8._clearSelectionOutline();\n          _this8._hideInfoPanel();\n          _this8._lastPanelMesh = null;\n          _this8.selectedItem = null;\n          _this8._animateCameraTopDown();\n        };\n      }\n\n      // NEW: Add stopImmediatePropagation to prevent triggering pointer handler\n      if (nameEl) {\n        nameEl.onclick = function (e) {\n          e.stopPropagation();\n          e.stopImmediatePropagation(); // NEW\n          _this8._inlineEditName(nameEl, item);\n        };\n      }\n      descEls.forEach(function (descEl) {\n        descEl.onclick = function (e) {\n          e.stopPropagation();\n          e.stopImmediatePropagation(); // NEW\n          _this8._inlineEditDescription(descEl, item);\n        };\n      });\n      if (playBtn) playBtn.onclick = function (e) {\n        e.stopPropagation();\n        _this8._handlePlay(item);\n      };\n      if (exportBtn) exportBtn.onclick = function (e) {\n        e.stopPropagation();\n        _this8._handleExport(item);\n      };\n    }\n  }, {\n    key: \"_openInfoPanelFor\",\n    value: function _openInfoPanelFor(mesh, item) {\n      this._lastPanelMesh = mesh;\n      this.selectedItem = item;\n      this._renderPanelContents(item);\n\n      // NEW: Show panel with slide-in animation\n      this._panel.style.display = 'block';\n      // Trigger reflow for animation\n      this._panel.offsetHeight;\n      this._panel.classList.add('visible');\n    }\n  }, {\n    key: \"_hideInfoPanel\",\n    value: function _hideInfoPanel() {\n      var _this9 = this;\n      if (this._panel) {\n        this._panel.classList.remove('visible');\n        this._panelEditDepth = 0; // NEW\n        this._panel.classList.remove('editing-active'); // NEW\n        this._pointerOverPanel = false;\n        setTimeout(function () {\n          if (!_this9._panel.classList.contains('visible')) {\n            _this9._panel.style.display = 'none';\n          }\n        }, 400); // Match CSS transition duration\n      }\n    }\n\n    // ============== UI editing ==============\n  }, {\n    key: \"_escapeHTML\",\n    value: function _escapeHTML(str) {\n      return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');\n    }\n  }, {\n    key: \"_inlineEditName\",\n    value: function _inlineEditName(container, item) {\n      var _this10 = this;\n      if (this._isEditingName) return;\n      this._isEditingName = true;\n      this._beginPanelEdit();\n      var current = this._sanitizeName(item.name);\n      container.textContent = '';\n      container.classList.remove('library-name');\n      var input = document.createElement('input');\n      input.type = 'text';\n      input.value = current;\n      input.className = 'library-name library-name-edit';\n      input.maxLength = this.nameMaxLength;\n      input.addEventListener('input', function () {\n        if (input.value.length > _this10.nameMaxLength) {\n          input.value = input.value.slice(0, _this10.nameMaxLength);\n        }\n      });\n      container.appendChild(input);\n      input.focus();\n      input.select();\n      var closed = false;\n      var finalize = function finalize(commit) {\n        if (closed) return;\n        closed = true;\n        _this10._isEditingName = false;\n        _this10._endPanelEdit();\n        if (!container.isConnected) return;\n        var value = commit ? _this10._sanitizeName(input.value) : current;\n        if (commit) item.name = value;\n        _this10._applyNameLayout(container, value);\n      };\n      input.addEventListener('keydown', function (e) {\n        e.stopPropagation();\n        if (e.key === 'Enter') {\n          finalize(true);\n          input.blur();\n        } else if (e.key === 'Escape') {\n          finalize(false);\n          input.blur();\n        }\n      });\n      input.addEventListener('blur', function () {\n        setTimeout(function () {\n          return finalize(true);\n        }, 50);\n      });\n    }\n  }, {\n    key: \"_inlineEditDescription\",\n    value: function _inlineEditDescription(container, item) {\n      var _this11 = this;\n      if (this._isEditingDesc) return;\n      this._isEditingDesc = true;\n      this._beginPanelEdit();\n      var current = this._sanitizeDescription(item.description);\n      container.textContent = '';\n      var ta = document.createElement('textarea');\n      ta.value = current;\n      ta.className = 'library-description library-description-edit';\n      ta.maxLength = this.descriptionMaxLength;\n      ta.addEventListener('input', function () {\n        if (ta.value.length > _this11.descriptionMaxLength) {\n          var pos = ta.selectionStart;\n          ta.value = ta.value.slice(0, _this11.descriptionMaxLength);\n          ta.selectionStart = ta.selectionEnd = Math.min(pos, _this11.descriptionMaxLength);\n        }\n        autoSize();\n      });\n      container.appendChild(ta);\n      ta.focus();\n      var autoSize = function autoSize() {\n        ta.style.height = 'auto';\n        ta.style.height = \"\".concat(Math.min(window.innerHeight * 0.6, ta.scrollHeight), \"px\");\n      };\n      ta.addEventListener('input', autoSize);\n      autoSize();\n      var closed = false;\n      var finalize = function finalize(commit) {\n        if (closed) return;\n        closed = true;\n        _this11._isEditingDesc = false;\n        _this11._endPanelEdit();\n        if (!container.isConnected) return;\n        var value = commit ? _this11._sanitizeDescription(ta.value) : current;\n        if (commit) item.description = value;\n        if (value) {\n          container.classList.remove('library-desc-placeholder');\n          container.classList.add('library-description', 'committed');\n          container.textContent = value;\n        } else {\n          container.classList.add('library-description', 'committed', 'library-desc-placeholder');\n          container.textContent = 'Insert description here';\n        }\n      };\n      ta.addEventListener('keydown', function (e) {\n        e.stopPropagation();\n        if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'enter') {\n          finalize(true);\n          ta.blur();\n        } else if (e.key === 'Escape') {\n          finalize(false);\n          ta.blur();\n        }\n      });\n      ta.addEventListener('blur', function () {\n        setTimeout(function () {\n          return finalize(true);\n        }, 50);\n      });\n    }\n  }, {\n    key: \"_handlePlay\",\n    value: function _handlePlay(item) {\n      var _this$particleSystem4,\n        _this12 = this;\n      var sc = (_this$particleSystem4 = this.particleSystem) === null || _this$particleSystem4 === void 0 ? void 0 : _this$particleSystem4.surroundController;\n      if (!sc) return;\n      if (item.type === 'combination' && Array.isArray(item.items)) {\n        var ids = item.items.map(function (it) {\n          var _it$solutionData$id, _it$solutionData2;\n          return (_it$solutionData$id = (_it$solutionData2 = it.solutionData) === null || _it$solutionData2 === void 0 ? void 0 : _it$solutionData2.id) !== null && _it$solutionData$id !== void 0 ? _it$solutionData$id : it.id;\n        }).filter(Boolean);\n        ids.forEach(function (id) {\n          var _this12$_selectedCont;\n          sc.playOneShot(id, {\n            highlightMesh: ((_this12$_selectedCont = _this12._selectedContainer) === null || _this12$_selectedCont === void 0 || (_this12$_selectedCont = _this12$_selectedCont.userData) === null || _this12$_selectedCont === void 0 ? void 0 : _this12$_selectedCont.__solidRoot) || _this12._lastPanelMesh,\n            onEnded: function onEnded() {\n              return _this12._clearSelectionOutline();\n            },\n            allowOverlap: true // <-- allow simultaneous playback\n          });\n        });\n      } else {\n        var _ref3, _item$solutionId, _item$solutionData4, _this$_selectedContai;\n        // Single solution: play one sound\n        var id = (_ref3 = (_item$solutionId = item === null || item === void 0 ? void 0 : item.solutionId) !== null && _item$solutionId !== void 0 ? _item$solutionId : item === null || item === void 0 || (_item$solutionData4 = item.solutionData) === null || _item$solutionData4 === void 0 ? void 0 : _item$solutionData4.id) !== null && _ref3 !== void 0 ? _ref3 : item === null || item === void 0 ? void 0 : item.id;\n        if (id == null) return;\n        sc.playOneShot(id, {\n          highlightMesh: ((_this$_selectedContai = this._selectedContainer) === null || _this$_selectedContai === void 0 || (_this$_selectedContai = _this$_selectedContai.userData) === null || _this$_selectedContai === void 0 ? void 0 : _this$_selectedContai.__solidRoot) || this._lastPanelMesh,\n          onEnded: function onEnded() {\n            return _this12._clearSelectionOutline();\n          }\n        });\n      }\n    }\n  }, {\n    key: \"_handleExport\",\n    value: function _handleExport(item) {\n      var _this$particleSystem5,\n        _this13 = this;\n      var sc = (_this$particleSystem5 = this.particleSystem) === null || _this$particleSystem5 === void 0 ? void 0 : _this$particleSystem5.surroundController;\n      if (!sc) return;\n      function getBuffer(_x) {\n        return _getBuffer.apply(this, arguments);\n      } // Combination: merge all sounds into stereo with panning\n      function _getBuffer() {\n        _getBuffer = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(id) {\n          var source, response, arrayBuffer;\n          return _regeneratorRuntime().wrap(function _callee$(_context) {\n            while (1) switch (_context.prev = _context.next) {\n              case 0:\n                source = sc.sources.get(id);\n                if (source) {\n                  _context.next = 3;\n                  break;\n                }\n                return _context.abrupt(\"return\", null);\n              case 3:\n                if (!source.buffer) {\n                  _context.next = 5;\n                  break;\n                }\n                return _context.abrupt(\"return\", source.buffer);\n              case 5:\n                if (!(source.audioElement && source.audioElement.src)) {\n                  _context.next = 20;\n                  break;\n                }\n                _context.prev = 6;\n                _context.next = 9;\n                return fetch(source.audioElement.src);\n              case 9:\n                response = _context.sent;\n                _context.next = 12;\n                return response.arrayBuffer();\n              case 12:\n                arrayBuffer = _context.sent;\n                _context.next = 15;\n                return sc.audioContext.decodeAudioData(arrayBuffer);\n              case 15:\n                return _context.abrupt(\"return\", _context.sent);\n              case 18:\n                _context.prev = 18;\n                _context.t0 = _context[\"catch\"](6);\n              case 20:\n                return _context.abrupt(\"return\", null);\n              case 21:\n              case \"end\":\n                return _context.stop();\n            }\n          }, _callee, null, [[6, 18]]);\n        }));\n        return _getBuffer.apply(this, arguments);\n      }\n      if (item.type === 'combination' && Array.isArray(item.items)) {\n        var ids = item.items.map(function (it) {\n          var _it$solutionData$id2, _it$solutionData3;\n          return (_it$solutionData$id2 = (_it$solutionData3 = it.solutionData) === null || _it$solutionData3 === void 0 ? void 0 : _it$solutionData3.id) !== null && _it$solutionData$id2 !== void 0 ? _it$solutionData$id2 : it.id;\n        }).filter(Boolean);\n        Promise.all(ids.map(getBuffer)).then(function (buffers) {\n          buffers = buffers.filter(Boolean);\n          if (!buffers.length) {\n            alert('No audio found for export.');\n            return;\n          }\n          var sampleRate = buffers[0].sampleRate;\n          var maxLen = Math.max.apply(Math, _toConsumableArray(buffers.map(function (b) {\n            return b.length;\n          })));\n          var ctx = sc.audioContext;\n          var stereo = ctx.createBuffer(2, maxLen, sampleRate);\n\n          // Pan positions: -1 (left) to +1 (right), spread evenly\n          var N = buffers.length;\n          var pans = N === 1 ? [0] : Array.from({\n            length: N\n          }, function (_, i) {\n            return -1 + 2 * i / (N - 1);\n          });\n          for (var i = 0; i < N; i++) {\n            var buf = buffers[i];\n            var pan = pans[i];\n            var left = stereo.getChannelData(0);\n            var right = stereo.getChannelData(1);\n            var src = buf.getChannelData(0); // mono or left\n            for (var j = 0; j < buf.length; j++) {\n              // Simple constant-power pan\n              var angle = (pan + 1) * Math.PI / 4; // -1=left, 0=center, +1=right\n              left[j] += src[j] * Math.cos(angle);\n              right[j] += src[j] * Math.sin(angle);\n            }\n          }\n          // Normalize to avoid clipping\n          for (var ch = 0; ch < 2; ch++) {\n            var data = stereo.getChannelData(ch);\n            var max = 0;\n            for (var _i = 0; _i < data.length; _i++) max = Math.max(max, Math.abs(data[_i]));\n            if (max > 1.0) for (var _i2 = 0; _i2 < data.length; _i2++) data[_i2] /= max;\n          }\n          var wavBlob = _this13.bufferToWavBlob(stereo, sampleRate);\n          _this13.downloadBlob(wavBlob, (item.name || 'combination') + '.wav');\n        });\n      } else {\n        var _ref4, _item$solutionId2, _item$solutionData5;\n        // Mono: export single buffer\n        var id = (_ref4 = (_item$solutionId2 = item.solutionId) !== null && _item$solutionId2 !== void 0 ? _item$solutionId2 : (_item$solutionData5 = item.solutionData) === null || _item$solutionData5 === void 0 ? void 0 : _item$solutionData5.id) !== null && _ref4 !== void 0 ? _ref4 : item.id;\n        getBuffer(id).then(function (buffer) {\n          if (!buffer) {\n            alert('No audio found for export.');\n            return;\n          }\n          // If stereo, downmix to mono\n          var monoBuffer = _this13.toMono(buffer, sc.audioContext);\n          var wavBlob = _this13.bufferToWavBlob(monoBuffer, monoBuffer.sampleRate);\n          _this13.downloadBlob(wavBlob, (item.name || 'sound') + '.wav');\n        });\n      }\n    }\n\n    // Downmix to mono\n  }, {\n    key: \"toMono\",\n    value: function toMono(buffer, ctx) {\n      if (buffer.numberOfChannels === 1) return buffer;\n      var len = buffer.length;\n      var mono = ctx.createBuffer(1, len, buffer.sampleRate);\n      var out = mono.getChannelData(0);\n      for (var i = 0; i < len; i++) {\n        var sum = 0;\n        for (var ch = 0; ch < buffer.numberOfChannels; ch++) {\n          sum += buffer.getChannelData(ch)[i];\n        }\n        out[i] = sum / buffer.numberOfChannels;\n      }\n      return mono;\n    }\n\n    // WAV encoding (same as before)\n  }, {\n    key: \"bufferToWavBlob\",\n    value: function bufferToWavBlob(buffer, sampleRate) {\n      var numChannels = buffer.numberOfChannels;\n      var length = buffer.length * numChannels * 2 + 44;\n      var arrayBuffer = new ArrayBuffer(length);\n      var view = new DataView(arrayBuffer);\n      function writeString(view, offset, string) {\n        for (var i = 0; i < string.length; i++) {\n          view.setUint8(offset + i, string.charCodeAt(i));\n        }\n      }\n      writeString(view, 0, 'RIFF');\n      view.setUint32(4, length - 8, true);\n      writeString(view, 8, 'WAVE');\n      writeString(view, 12, 'fmt ');\n      view.setUint32(16, 16, true);\n      view.setUint16(20, 1, true);\n      view.setUint16(22, numChannels, true);\n      view.setUint32(24, sampleRate, true);\n      view.setUint32(28, sampleRate * numChannels * 2, true);\n      view.setUint16(32, numChannels * 2, true);\n      view.setUint16(34, 16, true);\n      writeString(view, 36, 'data');\n      view.setUint32(40, length - 44, true);\n      var offset = 44;\n      for (var i = 0; i < buffer.length; i++) {\n        for (var ch = 0; ch < numChannels; ch++) {\n          var sample = buffer.getChannelData(ch)[i];\n          sample = Math.max(-1, Math.min(1, sample));\n          view.setInt16(offset, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);\n          offset += 2;\n        }\n      }\n      return new Blob([arrayBuffer], {\n        type: 'audio/wav'\n      });\n    }\n  }, {\n    key: \"downloadBlob\",\n    value: function downloadBlob(blob, filename) {\n      var url = URL.createObjectURL(blob);\n      var a = document.createElement('a');\n      a.style.display = 'none';\n      a.href = url;\n      a.download = filename;\n      document.body.appendChild(a);\n      a.click();\n      setTimeout(function () {\n        document.body.removeChild(a);\n        URL.revokeObjectURL(url);\n      }, 200);\n    }\n\n    // Keep solids' original rotation animation alive in Library view\n  }, {\n    key: \"_updateLibrarySolidsAnimation\",\n    value: function _updateLibrarySolidsAnimation() {\n      var t = performance.now() * 0.001;\n      for (var i = 0; i < this._libItems.length; i++) {\n        var rt = this._libItems[i];\n        if (!rt || !rt.solid) continue;\n        var primary = rt.primary || rt.solid;\n        if (rt.orbitClones && rt.orbitClones.length > 0) {\n          primary.rotation.y = t * 0.2;\n\n          // Animate orbit clones around the primary\n          var pWorld = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();\n          primary.getWorldPosition(pWorld);\n          for (var j = 0; j < rt.orbitClones.length; j++) {\n            var c = rt.orbitClones[j];\n            var baseAngle = c.userData.orbitAngle || 0;\n            var vel = c.userData.orbitalVelocity || 0.15;\n            var mass = c.userData.mass || 1.0;\n            var vOsc = c.userData.verticalOscillation || 0.2;\n            var radius = c.userData._libOrbitRadius || 1.0;\n            var angle = baseAngle + t * (0.15 + vel);\n            var r = radius * (0.8 + mass * 0.4);\n\n            // Position relative to primary in local space of solid root\n            var localY = primary.position.y + Math.sin(t * 1.5 + j) * vOsc * 0.5;\n            c.position.x = Math.cos(angle) * r;\n            c.position.z = Math.sin(angle) * r;\n            c.position.y = localY;\n            c.rotation.z = -angle * (2 - mass);\n            c.rotation.y = t * 0.3 * (2 - mass);\n          }\n        } else {\n          // Single-mesh mode ‚Äì rotate around Z (like main mesh)\n          primary.rotation.z = t * 0.2;\n        }\n      }\n    }\n  }, {\n    key: \"_applyHoverOutline\",\n    value: function _applyHoverOutline(container) {\n      var _this14 = this;\n      if (this._hoveredContainer && this._hoveredContainer !== container) {\n        this._clearHoverOutline();\n      }\n      this._hoveredContainer = container;\n      var solidRoot = container.userData.__solidRoot || container;\n      solidRoot.traverse(function (child) {\n        if (!child.isMesh) return;\n        if (_this14._selectedContainer === container) return;\n        if (!child.userData.__hoverOriginalMaterial) {\n          child.userData.__hoverOriginalMaterial = child.material;\n        }\n        var cloned = _this14._cloneMaterialDeep(child.userData.__hoverOriginalMaterial);\n        _this14._tintMaterial(cloned, 0x004488, 0.9);\n        child.material = cloned;\n      });\n    }\n  }, {\n    key: \"_clearHoverOutline\",\n    value: function _clearHoverOutline() {\n      if (!this._hoveredContainer) return;\n      var container = this._hoveredContainer;\n      this._hoveredContainer = null;\n      var solidRoot = container.userData.__solidRoot || container;\n      solidRoot.traverse(function (child) {\n        if (!child.isMesh) return;\n        if (child.userData.__hoverOriginalMaterial) {\n          child.material = child.userData.__hoverOriginalMaterial;\n          delete child.userData.__hoverOriginalMaterial;\n        }\n      });\n    }\n  }, {\n    key: \"_applySelectionOutline\",\n    value: function _applySelectionOutline(container) {\n      var _this15 = this;\n      if (this._selectedContainer && this._selectedContainer !== container) {\n        this._clearSelectionOutline();\n      }\n      this._clearHoverOutline();\n      this._selectedContainer = container;\n      var solidRoot = container.userData.__solidRoot || container;\n      solidRoot.traverse(function (child) {\n        if (!child.isMesh) return;\n        if (!child.userData.__selectedOriginalMaterial) {\n          child.userData.__selectedOriginalMaterial = child.material;\n        }\n        var cloned = _this15._cloneMaterialDeep(child.userData.__selectedOriginalMaterial);\n        _this15._tintMaterial(cloned, 0x004400, 0.9);\n        child.material = cloned;\n        if (child.userData.__hoverOriginalMaterial) {\n          delete child.userData.__hoverOriginalMaterial;\n        }\n      });\n    }\n  }, {\n    key: \"_clearSelectionOutline\",\n    value: function _clearSelectionOutline() {\n      if (!this._selectedContainer) return;\n      var container = this._selectedContainer;\n      this._selectedContainer = null;\n      var solidRoot = container.userData.__solidRoot || container;\n      solidRoot.traverse(function (child) {\n        if (!child.isMesh) return;\n        if (child.userData.__selectedOriginalMaterial) {\n          child.material = child.userData.__selectedOriginalMaterial;\n          delete child.userData.__selectedOriginalMaterial;\n        }\n        if (child.userData.__hoverOriginalMaterial) {\n          delete child.userData.__hoverOriginalMaterial;\n        }\n      });\n    }\n  }, {\n    key: \"_findPrimaryMesh\",\n    value: function _findPrimaryMesh(root) {\n      var candidates = [];\n      root.traverse(function (n) {\n        if (n.isMesh) {\n          var isOrbitClone = !!(n.userData && n.userData.orbitAngle !== undefined);\n          if (!isOrbitClone) candidates.push(n);\n        }\n      });\n      if (candidates.length === 0) return null;\n      if (candidates.length === 1) return candidates[0];\n      var best = candidates[0],\n        bestVol = -Infinity;\n      var box = new three__WEBPACK_IMPORTED_MODULE_1__.Box3();\n      for (var _i3 = 0, _candidates = candidates; _i3 < _candidates.length; _i3++) {\n        var m = _candidates[_i3];\n        box.setFromObject(m);\n        var s = box.getSize(new three__WEBPACK_IMPORTED_MODULE_1__.Vector3());\n        var vol = s.x * s.y * s.z;\n        if (vol > bestVol) {\n          bestVol = vol;\n          best = m;\n        }\n      }\n      return best;\n    }\n  }, {\n    key: \"_retargetUpdateFunctionsForClone\",\n    value: function _retargetUpdateFunctionsForClone(runtime) {\n      if (!runtime || !runtime.solid) return;\n\n      // This function exists as a stub for future per-clone retargeting if required.\n    }\n\n    // Safe material tint (handles single or array)\n  }, {\n    key: \"_tintMaterial\",\n    value: function _tintMaterial(matOrArray, emissiveHex) {\n      var opacity = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.9;\n      var tintOne = function tintOne(m) {\n        if (!m) return;\n        try {\n          m.transparent = true;\n          m.opacity = opacity;\n          if ('emissive' in m) {\n            m.emissive = new three__WEBPACK_IMPORTED_MODULE_1__.Color(emissiveHex);\n            m.emissiveIntensity = Math.max(m.emissiveIntensity || 0.5, 0.5);\n          } else if ('color' in m) {\n            // fallback: modulate color slightly\n            var c = new three__WEBPACK_IMPORTED_MODULE_1__.Color(emissiveHex);\n            m.color.lerp(c, 0.35);\n          }\n        } catch (_) {}\n      };\n      if (Array.isArray(matOrArray)) {\n        matOrArray.forEach(tintOne);\n      } else {\n        tintOne(matOrArray);\n      }\n    }\n\n    // Helpers for formatting categories in the panel\n  }, {\n    key: \"_capitalizeFirst\",\n    value: function _capitalizeFirst(str) {\n      if (!str) return '';\n      var s = String(str).trim();\n      if (!s) return '';\n      var low = s.toLowerCase();\n      return low.charAt(0).toUpperCase() + low.slice(1);\n    }\n  }, {\n    key: \"_uniqueCapCategories\",\n    value: function _uniqueCapCategories(list) {\n      var seen = new Set();\n      var out = [];\n      var _iterator = _createForOfIteratorHelper(list || []),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var c = _step.value;\n          var key = String(c || '').trim().toLowerCase();\n          if (!key || seen.has(key)) continue;\n          seen.add(key);\n          out.push(this._capitalizeFirst(key));\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return out;\n    }\n\n    /**\r\n     * Check if a solution or combination already exists in the library\r\n     * @param {Object} item - The item to check (must have solutionData or items array)\r\n     * @returns {Object|null} - Returns the existing library item if found, null otherwise\r\n     */\n  }, {\n    key: \"findExistingItem\",\n    value: function findExistingItem(item) {\n      if (item.type === 'solution') {\n        var _item$solutionData6;\n        // Normalize the incoming ID to check all possible sources\n        var incomingId = ((_item$solutionData6 = item.solutionData) === null || _item$solutionData6 === void 0 ? void 0 : _item$solutionData6.id) || item.solutionId || item.id || (item.solid ? item.solid.uuid : null);\n        if (incomingId == null) return null;\n\n        // Check against stored records using normalized comparison\n        return this.libraryData.find(function (libItem) {\n          var _libItem$solutionData;\n          if (libItem.type !== 'solution') return false;\n\n          // Get stored ID from multiple sources\n          var storedId = libItem.solutionId || ((_libItem$solutionData = libItem.solutionData) === null || _libItem$solutionData === void 0 ? void 0 : _libItem$solutionData.id) || libItem.id;\n\n          // Compare normalized IDs\n          return storedId === incomingId;\n        });\n      } else if (item.type === 'combination' && Array.isArray(item.items)) {\n        // For combinations, extract IDs with fallback to mesh UUID\n        var itemIds = item.items.map(function (it) {\n          var _ref5, _ref6, _it$solutionData$id3, _it$solutionData4;\n          return (_ref5 = (_ref6 = (_it$solutionData$id3 = (_it$solutionData4 = it.solutionData) === null || _it$solutionData4 === void 0 ? void 0 : _it$solutionData4.id) !== null && _it$solutionData$id3 !== void 0 ? _it$solutionData$id3 : it.solutionId) !== null && _ref6 !== void 0 ? _ref6 : it.id) !== null && _ref5 !== void 0 ? _ref5 : it.solid ? it.solid.uuid : null;\n        }).filter(Boolean).sort();\n        if (itemIds.length === 0) return null;\n        return this.libraryData.find(function (libItem) {\n          if (libItem.type !== 'combination' || !Array.isArray(libItem.items)) return false;\n          var libIds = libItem.items.map(function (it) {\n            var _ref7, _ref8, _it$solutionData$id4, _it$solutionData5;\n            return (_ref7 = (_ref8 = (_it$solutionData$id4 = (_it$solutionData5 = it.solutionData) === null || _it$solutionData5 === void 0 ? void 0 : _it$solutionData5.id) !== null && _it$solutionData$id4 !== void 0 ? _it$solutionData$id4 : it.solutionId) !== null && _ref8 !== void 0 ? _ref8 : it.id) !== null && _ref7 !== void 0 ? _ref7 : it.solid ? it.solid.uuid : null;\n          }).filter(Boolean).sort();\n\n          // Check if arrays are equal\n          return libIds.length === itemIds.length && libIds.every(function (id, idx) {\n            return id === itemIds[idx];\n          });\n        });\n      }\n      return null;\n    }\n  }, {\n    key: \"_populateLibraryItems\",\n    value: function _populateLibraryItems() {\n      var items = this._loadFromLocalStorage();\n\n      // Guard clause - don't try to populate if no items\n      if (!items || items.length === 0) {\n        this._libraryContainer.innerHTML = '<p style=\"text-align: center; padding: 20px; color: #888;\">No saved items yet</p>';\n        return;\n      }\n\n      // ...existing code to populate items...\n    }\n  }, {\n    key: \"_beginPanelEdit\",\n    value: function _beginPanelEdit() {\n      if (!this._panel) return;\n      if (!this._panelEditDepth) this._panelEditDepth = 0;\n      this._panelEditDepth += 1;\n      this._panel.classList.add('editing-active');\n    }\n  }, {\n    key: \"_endPanelEdit\",\n    value: function _endPanelEdit() {\n      if (!this._panel) return;\n      this._panelEditDepth = Math.max(0, (this._panelEditDepth || 0) - 1);\n      if (this._panelEditDepth === 0) {\n        this._panel.classList.remove('editing-active');\n      }\n    }\n  }, {\n    key: \"_positionInfoPanel\",\n    value: function _positionInfoPanel() {\n      // Panel is fixed to the right; no dynamic positioning needed.\n    }\n  }, {\n    key: \"_applyNameLayout\",\n    value: function _applyNameLayout(container, text) {\n      // NEW helper\n      var value = text || '(unnamed)';\n      container.textContent = value;\n      container.classList.add('library-name');\n    }\n  }, {\n    key: \"_sanitizeDescription\",\n    value: function _sanitizeDescription(desc) {\n      // NEW helper\n      var trimmed = (desc || '').trim();\n      if (!trimmed) return '';\n      var low = trimmed.toLowerCase();\n      if (low.startsWith('category:') || low.startsWith('fitness:') || low.startsWith('fallback data')) {\n        return '';\n      }\n      return trimmed.slice(0, this.descriptionMaxLength);\n    }\n  }, {\n    key: \"_sanitizeName\",\n    value: function _sanitizeName(name) {\n      // NEW helper\n      var trimmed = (name || '').trim();\n      var safe = trimmed || '(unnamed)';\n      return safe.slice(0, this.nameMaxLength);\n    }\n  }]);\n}();\n\n//# sourceURL=webpack://sound-particle-visualization/./src/components/Library.js?");

/***/ }),

/***/ "./src/components/LoadingScreen.js":
/*!*****************************************!*\
  !*** ./src/components/LoadingScreen.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LoadingScreen: () => (/* binding */ LoadingScreen)\n/* harmony export */ });\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar LoadingScreen = /*#__PURE__*/function () {\n  function LoadingScreen() {\n    _classCallCheck(this, LoadingScreen);\n    this.container = null;\n    this.isVisible = false;\n  }\n  return _createClass(LoadingScreen, [{\n    key: \"show\",\n    value: function show() {\n      var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Loading';\n      if (this.isVisible) return;\n\n      // Remove any existing loading screen\n      this.hide();\n\n      // Create loading container\n      this.container = document.createElement('div');\n      this.container.className = 'loading-screen';\n\n      // Create content\n      var content = document.createElement('div');\n      content.className = 'loading-content';\n\n      // Create animated text\n      var text = document.createElement('div');\n      text.className = 'loading-text';\n      text.textContent = message;\n\n      // Create animated dots\n      var dots = document.createElement('span');\n      dots.className = 'loading-dots';\n      text.appendChild(dots);\n      content.appendChild(text);\n      this.container.appendChild(content);\n      document.body.appendChild(this.container);\n      this.isVisible = true;\n\n      // Animate dots\n      this.animateDots();\n      console.log(\"\\uD83D\\uDD04 Loading screen shown: \\\"\".concat(message, \"\\\"\"));\n    }\n  }, {\n    key: \"hide\",\n    value: function hide() {\n      var _this = this;\n      if (this.container) {\n        this.container.classList.add('fade-out');\n        setTimeout(function () {\n          if (_this.container && _this.container.parentElement) {\n            _this.container.remove();\n          }\n          _this.container = null;\n          _this.isVisible = false;\n        }, 500); // Match CSS transition\n        console.log('‚úÖ Loading screen hidden');\n      }\n    }\n  }, {\n    key: \"updateMessage\",\n    value: function updateMessage(message) {\n      if (this.container) {\n        var textEl = this.container.querySelector('.loading-text');\n        if (textEl) {\n          // Preserve dots element\n          var dots = textEl.querySelector('.loading-dots');\n          textEl.textContent = message;\n          if (dots) textEl.appendChild(dots);\n        }\n      }\n    }\n  }, {\n    key: \"animateDots\",\n    value: function animateDots() {\n      var _this2 = this;\n      if (!this.container) return;\n      var dots = this.container.querySelector('.loading-dots');\n      if (!dots) return;\n      var dotCount = 0;\n      var interval = setInterval(function () {\n        if (!_this2.isVisible || !_this2.container) {\n          clearInterval(interval);\n          return;\n        }\n        dotCount = (dotCount + 1) % 4;\n        dots.textContent = '.'.repeat(dotCount);\n      }, 500);\n    }\n  }]);\n}();\n\n//# sourceURL=webpack://sound-particle-visualization/./src/components/LoadingScreen.js?");

/***/ }),

/***/ "./src/components/ParticleSystem.js":
/*!******************************************!*\
  !*** ./src/components/ParticleSystem.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ParticleSystem: () => (/* binding */ ParticleSystem)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n/* harmony import */ var _GeometricSolid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GeometricSolid */ \"./src/components/GeometricSolid.js\");\n/* harmony import */ var _SpatialGrid_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SpatialGrid.js */ \"./src/components/SpatialGrid.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _createForOfIteratorHelper(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n // CHANGED: Named import with curly braces\n\nvar complementary_map = {\n  'low': 'mid',\n  'high': 'mid',\n  'mid': 'rhythmic',\n  'rhythmic': 'mid'\n};\nfunction generateSwarmPeakPositions(numPeaks, time) {\n  var baseRadius = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 50;\n  var spread = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 75;\n  var positions = [];\n  for (var i = 0; i < numPeaks; i++) {\n    var t = time + i * 10;\n    var angle = Math.sin(t * 0.13 + i) * Math.PI + Math.cos(t * 0.17 + i * 0.5) * Math.PI * 0.5;\n    var radius = baseRadius + Math.sin(t * 0.07 + i) * spread * 0.5 + Math.cos(t * 0.11 + i) * spread * 0.3;\n    positions.push(new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(Math.cos(angle) * radius, 0, Math.sin(angle) * radius));\n  }\n  return positions;\n}\nvar ParticleSystem = /*#__PURE__*/function () {\n  function ParticleSystem(scene) {\n    var baseRadius = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n    _classCallCheck(this, ParticleSystem);\n    this.scene = scene;\n    this.baseRadius = baseRadius;\n    this.peaks = [];\n    this.previousHeights = [];\n    this.time = 0;\n    this.updateInterval = 40;\n    this.frameCounter = 0;\n    this.targetLocked = false;\n    this.frozenSwarmPositions = null;\n    this.lightPositions = [];\n    this.lightIntensities = [];\n    this.currentSolutions = [];\n    this.isEvolvingFrozen = false;\n    this.evolvingActive = false;\n    this.grainsPerVisiblePeak = 300;\n    this.categoryFilterActive = false;\n    this.defaultGrainClearance = 1.0;\n    this.grainColumnHeight = 6.0;\n    this.evolveSessionBaseY = null;\n    this.spatialGrid = new _SpatialGrid_js__WEBPACK_IMPORTED_MODULE_1__.SpatialGrid(50);\n    this.initPeaks();\n    this.peakSolids = [];\n    this.motionSystem = {\n      mode: 'lerp',\n      followLerp: 0.05,\n      maxVelocity: 1.5,\n      // NEW: units per frame (tune this!)\n\n      // === GLOBAL BEHAVIOR ===\n      swarmWeight: 0.20,\n      // REDUCED: let pairs dominate over swirl (was 0.35)\n      maxOffset: 5.0,\n      // === REPULSION (personal space) ===\n      minSeparation: 30,\n      repulsionStrength: 0.20,\n      repulsionWeight: 0.4,\n      // === COMPLEMENTARY ATTRACTION (pre-pairing) ===\n      complementaryRange: 35,\n      complementaryPull: 0.008,\n      attractionWeight: 0.2,\n      // === PAIRING (formation & maintenance) ===\n      pairFormRadius: 25,\n      pairKeepRadius: 35,\n      pairMinFrames: 480,\n      pairBreakProb: 0.0003,\n      pairCooldown: 240,\n      // === BOIDS FLOCKING (separation, cohesion, alignment) ===\n      // SEPARATION: maintain distance but stay together\n      pairDesiredSeparation: 25,\n      // INCREASED: wider gap (was 15)\n      pairSeparationStrength: 0.32,\n      // INCREASED: stronger spacing (was 0.26)\n\n      // COHESION: pull toward shared center\n      pairCohesionStrength: 0.5,\n      // INCREASED: stronger pull to center (was 0.5)\n\n      // ALIGNMENT: match headings\n      pairAlignmentStrength: 3.2,\n      // INCREASED: much stronger (was 2.5)\n      pairTravelSpeed: 2.0,\n      // INCREASED: faster (was 1.6)\n      pairHeadingSmoothing: 0.04,\n      // REDUCED: quicker sync (was 0.05)\n      pairHeadingJitter: 1,\n      // REDUCED: minimal jitter (was 2)\n      pairJitterInterval: 280,\n      // INCREASED: jitter very rarely (was 220)\n\n      // === PAIR EASE-IN ===\n      pairEaseFrames: 150,\n      // REDUCED: faster stabilization (was 180)\n\n      // === PAIR BREAK SMOOTHING ===\n      breakGraceFrames: 300,\n      // === EXPLORATION (solo movement) ===\n      wanderStrength: 0.45,\n      wanderInPair: 0.015,\n      // REDUCED: almost no wander when paired (was 0.02)\n      circularBias: 0.18,\n      explorationPairedScale: 0.10,\n      // REDUCED: minimal exploration in pairs (was 0.10)\n      maxRange: 180,\n      // === CENTER AVOIDANCE ===\n      avoidCenterRadius: 50,\n      avoidCenterStrength: 0.8,\n      // === WEIGHT SYSTEM ===\n      pairingWeight: 1.6,\n      // INCREASED: pairs dominate (was 1.2)\n      explorationWeight: 0.4,\n      // NEW: Additional tuning parameters\n      forceDamping: 0.85,\n      // Exponential decay on force offset\n      velocityBlendRate: 0.3,\n      // How quickly velocity adapts to desired\n      swirlPairedScale: 0.55,\n      // Reduce swirl influence when paired\n\n      // Grain behavior\n      grainSpringStrength: 0.12,\n      grainOrbitSpeed: 0.4,\n      grainOrbitAmount: 0.15,\n      grainVelocityDamping: 0.88,\n      grainMaxSpeedMultiplier: 1.8,\n      // Evolving\n      evolvingLerpSpeed: 0.12,\n      // Repulsion\n      pairedRepulsionScale: 0.4,\n      // Reduce repulsion between paired members\n      attractionInnerMargin: 1.2,\n      // Safety margin multiplier\n\n      // Heading\n      headingTangentWeight: 0.85,\n      // INCREASED: prioritize desired direction (was 0.6)\n      headingVelocityWeight: 0.15,\n      // Boundary\n      boundaryPushRate: 0.05\n    };\n    // Simplified state tracking\n    this._pairStates = []; // {partner: -1|index, frames: 0, cooldown: 0}\n    this._lastPositions = []; // for deriving velocities when needed\n    this._pairDirections = []; // Shared directions for pairs\n    this._velocities = []; // NEW: track actual velocities\n\n    this.initPairConnections();\n  }\n  return _createClass(ParticleSystem, [{\n    key: \"initPeaks\",\n    value: function initPeaks() {\n      var numPeaks = 10;\n      var peakSpacing = 30;\n      for (var i = 0; i < numPeaks; i++) {\n        var peak = {\n          grains: [],\n          grainTargets: [],\n          movingToNewPyramid: false,\n          nextPyramidCenter: new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(i * peakSpacing - numPeaks * peakSpacing / 2, 0, 0),\n          currentPyramidCenter: new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(i * peakSpacing - numPeaks * peakSpacing / 2, 0, 0),\n          readyForNextMove: true,\n          categoryVisible: true,\n          exploreSeed: Math.random() * 1000 // NEW seed for exploration\n        };\n        var grainCount = 300;\n        for (var j = 0; j < grainCount; j++) {\n          var grain = new three__WEBPACK_IMPORTED_MODULE_2__.Mesh(new three__WEBPACK_IMPORTED_MODULE_2__.SphereGeometry(0.09, 8, 8), new three__WEBPACK_IMPORTED_MODULE_2__.MeshStandardMaterial({\n            color: 0xe0dbc1,\n            emissive: 0xe0dbc1,\n            emissiveIntensity: 0.3,\n            transparent: true,\n            opacity: 0.8\n          }));\n          grain.layers.enable(1);\n          var heightFactor = Math.random();\n          var minRadius = 0.2 * this.baseRadius;\n          var scaledRadius = minRadius + (1 - heightFactor) * (this.baseRadius - minRadius);\n          var angle = Math.random() * Math.PI * 2;\n          var randomization = [];\n          for (var r = 0; r < 4; r++) randomization.push(0.3 + 0.4 * Math.random());\n          var baseAccel = 0.10 + 0.25 * Math.random();\n          var baseSpeed = 0.025 + 0.050 * Math.random();\n          var maxSpeed = 0.15 + 0.18 * Math.random();\n          grain.userData = {\n            heightFactor: heightFactor,\n            angle: angle,\n            randomization: randomization,\n            transitionSeed: Math.random() * 100,\n            baseAccel: baseAccel,\n            baseSpeed: baseSpeed,\n            maxSpeed: maxSpeed\n          };\n          grain.position.set(peak.currentPyramidCenter.x + scaledRadius * Math.cos(angle), heightFactor * 8 + Math.random() * 0.6 - 0.3, peak.currentPyramidCenter.z + scaledRadius * Math.sin(angle));\n          var theta = Math.random() * 2 * Math.PI;\n          var phi = Math.random() * Math.PI;\n          grain.userData.velocity = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(Math.sin(phi) * Math.cos(theta), Math.cos(phi), Math.sin(phi) * Math.sin(theta)).multiplyScalar(baseSpeed);\n          grain.userData.acceleration = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n          this.scene.add(grain);\n          peak.grains.push(grain);\n          peak.grainTargets.push(grain.position.clone());\n        }\n        this.peaks.push(peak);\n        this.previousHeights.push(8);\n      }\n    }\n  }, {\n    key: \"initPairConnections\",\n    value: function initPairConnections() {\n      this.pairLines = [];\n      var lineMaterial = new three__WEBPACK_IMPORTED_MODULE_2__.LineBasicMaterial({\n        color: 0x88ff88,\n        transparent: true,\n        opacity: 0.6\n      });\n      for (var i = 0; i < 15; i++) {\n        var lineGeometry = new three__WEBPACK_IMPORTED_MODULE_2__.BufferGeometry();\n        var line = new three__WEBPACK_IMPORTED_MODULE_2__.Line(lineGeometry, lineMaterial);\n        line.visible = false;\n        this.scene.add(line);\n        this.pairLines.push(line);\n      }\n    }\n  }, {\n    key: \"regenerateWithSolutions\",\n    value: function regenerateWithSolutions(solutions) {\n      var _this = this;\n      // Guard clause\n      if (!this.peaks || this.peaks.length === 0) {\n        console.warn('‚ö†Ô∏è Cannot regenerate - peaks not initialized. Call initializeWithData() first.');\n        return;\n      }\n      if (!solutions || solutions.length === 0) {\n        console.warn('‚ö†Ô∏è No solutions provided for regeneration');\n        return;\n      }\n      this.currentSolutions = solutions;\n      this.peakSolids.forEach(function (solid) {\n        if (solid && _this.scene) {\n          _this.scene.remove(solid);\n        }\n      });\n      this.peakSolids = [];\n      var targetPeaks = solutions.length;\n      var currentPeaks = this.peaks.length;\n      if (targetPeaks !== currentPeaks) {\n        this.adjustPeakCount(targetPeaks);\n      }\n      this.ensureArraySizes();\n      for (var i = 0; i < Math.min(solutions.length, this.peaks.length); i++) {\n        var solution = solutions[i];\n        var peak = this.peaks[i];\n        if (!peak || !peak.currentPyramidCenter) {\n          console.warn(\"\\u26A0\\uFE0F Invalid peak at index \".concat(i, \", skipping solid creation\"));\n          continue;\n        }\n        try {\n          console.log(\"\\uD83C\\uDFA8 Creating solid \".concat(i, \" for solution \").concat(solution.id, \":\"), solution.parameters);\n          var solid = (0,_GeometricSolid__WEBPACK_IMPORTED_MODULE_0__.createGeometricSolid)(solution);\n          if (solid) {\n            solid.position.copy(peak.currentPyramidCenter);\n            solid.position.y += 6;\n            this.scene.add(solid);\n            this.peakSolids.push(solid);\n          }\n        } catch (error) {\n          console.error(\"\\u274C Error creating solid \".concat(i, \":\"), error);\n        }\n      }\n      console.log('‚úÖ Regeneration complete:', this.peakSolids.length, 'solids created');\n    }\n  }, {\n    key: \"adjustPeakCount\",\n    value: function adjustPeakCount(targetCount) {\n      if (targetCount <= 0) {\n        console.warn('‚ö†Ô∏è Invalid target count for peaks:', targetCount);\n        return;\n      }\n      var currentCount = this.peaks.length;\n      if (targetCount > currentCount) {\n        for (var i = currentCount; i < targetCount; i++) {\n          this.createSinglePeak(i, targetCount);\n        }\n      } else if (targetCount < currentCount) {\n        for (var _i = currentCount - 1; _i >= targetCount; _i--) {\n          this.removeSinglePeak(_i);\n        }\n      }\n      this.repositionPeaks();\n    }\n  }, {\n    key: \"createSinglePeak\",\n    value: function createSinglePeak(index, totalPeaks) {\n      var peakSpacing = 80;\n      var peak = {\n        grains: [],\n        grainTargets: [],\n        movingToNewPyramid: false,\n        nextPyramidCenter: new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(index * peakSpacing - totalPeaks * peakSpacing / 2, 0, 0),\n        currentPyramidCenter: new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(index * peakSpacing - totalPeaks * peakSpacing / 2, 0, 0),\n        readyForNextMove: true,\n        velocity: new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(),\n        acceleration: new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(),\n        categoryVisible: true // <- default visible\n      };\n      var grainCount = 300;\n      for (var j = 0; j < grainCount; j++) {\n        try {\n          var grain = this.createSingleGrain(peak);\n          if (grain) {\n            this.scene.add(grain);\n            peak.grains.push(grain);\n            peak.grainTargets.push(grain.position.clone());\n          }\n        } catch (error) {\n          console.error(\"Error creating grain \".concat(j, \" for peak \").concat(index, \":\"), error);\n        }\n      }\n      this.peaks.push(peak);\n      this.previousHeights.push(8);\n    }\n  }, {\n    key: \"removeSinglePeak\",\n    value: function removeSinglePeak(index) {\n      var _this2 = this;\n      if (index < 0 || index >= this.peaks.length) return;\n      var peak = this.peaks[index];\n      if (peak && peak.grains) {\n        peak.grains.forEach(function (grain) {\n          if (grain && _this2.scene) {\n            _this2.scene.remove(grain);\n          }\n        });\n      }\n      this.peaks.splice(index, 1);\n      if (this.previousHeights.length > index) {\n        this.previousHeights.splice(index, 1);\n      }\n    }\n  }, {\n    key: \"createSingleGrain\",\n    value: function createSingleGrain(peak) {\n      var grain = new three__WEBPACK_IMPORTED_MODULE_2__.Mesh(new three__WEBPACK_IMPORTED_MODULE_2__.SphereGeometry(0.09, 8, 8), new three__WEBPACK_IMPORTED_MODULE_2__.MeshStandardMaterial({\n        color: 0xe0dbc1,\n        emissive: 0xe0dbc1,\n        emissiveIntensity: 0.3,\n        transparent: true,\n        opacity: 0.8\n      }));\n      grain.layers.enable(1);\n      var heightFactor = Math.random();\n      var minRadius = 0.2 * this.baseRadius;\n      var scaledRadius = minRadius + (1 - heightFactor) * (this.baseRadius - minRadius);\n      var angle = Math.random() * Math.PI * 2;\n      var randomization = [];\n      for (var r = 0; r < 4; r++) randomization.push(0.3 + 0.4 * Math.random());\n      var baseAccel = 0.08 + 0.10 * Math.random();\n      var baseSpeed = 0.025 + 0.050 * Math.random();\n      var maxSpeed = 0.05 + 0.18 * Math.random();\n      grain.userData = {\n        heightFactor: heightFactor,\n        angle: angle,\n        randomization: randomization,\n        transitionSeed: Math.random() * 100,\n        baseAccel: baseAccel,\n        baseSpeed: baseSpeed,\n        maxSpeed: maxSpeed,\n        velocity: new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(),\n        acceleration: new three__WEBPACK_IMPORTED_MODULE_2__.Vector3()\n      };\n      grain.position.set(peak.currentPyramidCenter.x + scaledRadius * Math.cos(angle), heightFactor * 8 + Math.random() * 0.6 - 0.3, peak.currentPyramidCenter.z + scaledRadius * Math.sin(angle));\n      var theta = Math.random() * 2 * Math.PI;\n      var phi = Math.random() * Math.PI;\n      grain.userData.velocity = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(Math.sin(phi) * Math.cos(theta), Math.cos(phi), Math.sin(phi) * Math.sin(theta)).multiplyScalar(baseSpeed);\n      return grain;\n    }\n  }, {\n    key: \"repositionPeaks\",\n    value: function repositionPeaks() {\n      var peakSpacing = 30;\n      for (var i = 0; i < this.peaks.length; i++) {\n        var newX = i * peakSpacing - this.peaks.length * peakSpacing / 2;\n        if (this.peaks[i]) {\n          this.peaks[i].currentPyramidCenter.x = newX;\n          this.peaks[i].nextPyramidCenter.x = newX;\n        }\n      }\n    }\n  }, {\n    key: \"ensureArraySizes\",\n    value: function ensureArraySizes() {\n      var peakCount = this.peaks.length;\n      while (this.previousHeights.length < peakCount) {\n        this.previousHeights.push(8);\n      }\n      while (this.previousHeights.length > peakCount) {\n        this.previousHeights.pop();\n      }\n      while (this.peakSolids.length > peakCount) {\n        var solid = this.peakSolids.pop();\n        if (solid && this.scene) {\n          this.scene.remove(solid);\n        }\n      }\n      if (this.frozenSwarmPositions && this.frozenSwarmPositions.length !== peakCount) {\n        if (this.targetLocked) {\n          this.frozenSwarmPositions = generateSwarmPeakPositions(peakCount, this.time);\n        }\n      }\n    }\n  }, {\n    key: \"smoothTransition\",\n    value: function smoothTransition(current, target, speed) {\n      return current + (target - current) * speed;\n    }\n  }, {\n    key: \"setNewGrainTargets\",\n    value: function setNewGrainTargets(peak, smoothedHeight) {\n      for (var j = 0; j < peak.grains.length; j++) {\n        var _peak$grains$j$userDa = peak.grains[j].userData,\n          heightFactor = _peak$grains$j$userDa.heightFactor,\n          angle = _peak$grains$j$userDa.angle;\n        var minRadius = 0.2 * this.baseRadius;\n        var scaledRadius = minRadius + (1 - heightFactor) * (this.baseRadius - minRadius);\n        peak.grainTargets[j] = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(peak.nextPyramidCenter.x + scaledRadius * Math.cos(angle), heightFactor * smoothedHeight, peak.nextPyramidCenter.z + scaledRadius * Math.sin(angle));\n      }\n      peak.movingToNewPyramid = true;\n    }\n  }, {\n    key: \"startEvolvingAlignment\",\n    value: function startEvolvingAlignment(targetList) {\n      var _this3 = this;\n      if (!Array.isArray(targetList) || targetList.length === 0) return;\n      this.evolvingActive = true;\n      targetList.forEach(function (entry) {\n        var solid = entry.solid;\n        var target = entry.target;\n        var peakIndex = _this3.peakSolids.indexOf(solid);\n        if (peakIndex !== -1 && _this3.peaks[peakIndex]) {\n          var peak = _this3.peaks[peakIndex];\n          peak.evolvingTargetCenter = target.clone();\n          peak.evolvingMoveSpeed = 0.12;\n          peak.evolvingLock = false; // allow movement\n        }\n      });\n    }\n  }, {\n    key: \"startEvolvingAlignmentInstant\",\n    value:\n    // NEW: Instant evolving alignment (snaps peaks and grains immediately)\n    function startEvolvingAlignmentInstant(targetList) {\n      var _this4 = this;\n      if (!Array.isArray(targetList) || targetList.length === 0) return;\n      this.evolvingActive = true;\n\n      // Ensure helper arrays exist\n      while (this._lastPositions.length < this.peaks.length) {\n        this._lastPositions.push(new three__WEBPACK_IMPORTED_MODULE_2__.Vector3());\n      }\n      while (this._velocities.length < this.peaks.length) {\n        this._velocities.push(new three__WEBPACK_IMPORTED_MODULE_2__.Vector3());\n      }\n      targetList.forEach(function (entry) {\n        var solid = entry.solid;\n        var target = entry.target;\n        var peakIndex = _this4.peakSolids.indexOf(solid);\n        if (peakIndex === -1) return;\n        var peak = _this4.peaks[peakIndex];\n        if (!peak) return;\n\n        // Calculate delta to move grains relatively\n        var delta = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3().subVectors(target, peak.currentPyramidCenter);\n\n        // INSTANT snap peak center\n        peak.currentPyramidCenter.copy(target);\n\n        // INSTANT move all grains by the same delta\n        if (Array.isArray(peak.grains)) {\n          for (var g = 0; g < peak.grains.length; g++) {\n            var grain = peak.grains[g];\n            if (grain) {\n              grain.position.add(delta);\n              // Zero motion to prevent drift\n              if (grain.userData.velocity) grain.userData.velocity.set(0, 0, 0);\n              if (grain.userData.acceleration) grain.userData.acceleration.set(0, 0, 0);\n            }\n          }\n        }\n\n        // INSTANT snap solid position\n        if (solid) {\n          solid.position.x = peak.currentPyramidCenter.x;\n          solid.position.z = peak.currentPyramidCenter.z;\n        }\n\n        // NEW: Set lock flag to prevent forces from moving peaks\n        peak.evolvingLock = true;\n\n        // Zero motion history to prevent velocity spike\n        if (_this4._lastPositions[peakIndex]) {\n          _this4._lastPositions[peakIndex].copy(peak.currentPyramidCenter);\n        }\n        if (_this4._velocities[peakIndex]) {\n          _this4._velocities[peakIndex].set(0, 0, 0);\n        }\n      });\n    }\n  }, {\n    key: \"stopEvolvingAlignment\",\n    value: function stopEvolvingAlignment() {\n      this.evolvingActive = false;\n      this.peaks.forEach(function (p) {\n        if (!p) return;\n        delete p.evolvingTargetCenter;\n        delete p.evolvingLock;\n        delete p.evolvingMoveSpeed;\n        delete p.manualHeight;\n        delete p.evolveBaseY;\n      });\n      this.evolveSessionBaseY = null;\n    }\n  }, {\n    key: \"update\",\n    value: function update(frequencyData) {\n      var _this5 = this;\n      // Guard clause - don't update if not initialized or no valid data\n      if (!this.peaks || this.peaks.length === 0) {\n        return; // Exit early if no peaks exist yet\n      }\n\n      // Guard clause - handle missing or invalid frequency data\n      if (!frequencyData || frequencyData.length === 0) {\n        // Use zeros/silence if no audio data available\n        frequencyData = new Uint8Array(10);\n      }\n      this.time += 0.016;\n      this.frameCounter++;\n      if (this.frameCounter % Math.floor(this.updateInterval / 16) !== 0) {\n        return;\n      }\n\n      // Initialize state arrays if needed\n      while (this._pairStates.length < this.peaks.length) {\n        this._pairStates.push({\n          partner: -1,\n          frames: 0,\n          cooldown: 0,\n          breakFrames: 0,\n          breakDir: new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(),\n          breakGrace: 0,\n          breakPartner: -1,\n          breakFade: 0,\n          breakHeading: new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(),\n          breakEase: 1.0 // NEW: store ease level at break time\n        });\n      }\n      while (this._lastPositions.length < this.peaks.length) {\n        this._lastPositions.push(new three__WEBPACK_IMPORTED_MODULE_2__.Vector3());\n      }\n      while (this._velocities.length < this.peaks.length) {\n        this._velocities.push(new three__WEBPACK_IMPORTED_MODULE_2__.Vector3());\n      }\n\n      // Swarm targets\n      var swarmPositions;\n      if (this.targetLocked && this.frozenSwarmPositions && this.frozenSwarmPositions.length === this.peaks.length) {\n        swarmPositions = this.frozenSwarmPositions;\n      } else {\n        swarmPositions = generateSwarmPeakPositions(this.peaks.length, this.time);\n      }\n\n      // Find and establish pairs\n      this._findPairs();\n\n      // Get reference to motion config\n      var M = this.motionSystem;\n\n      // Process each peak for movement\n      for (var i = 0; i < this.peaks.length; i++) {\n        var peak = this.peaks[i];\n        if (!peak || !peak.currentPyramidCenter) continue;\n        if (this.categoryFilterActive && peak.categoryVisible === false) continue;\n\n        // NEW: Skip ALL movement if stopAllMovement is true (Save Mode)\n        if (this.stopAllMovement) {\n          continue;\n        }\n\n        // Evolving alignment override - LOCK XZ position completely\n        if (this.evolvingActive && peak.evolvingLock) {\n          // Peak is locked in evolve mode - skip ALL movement logic\n          continue;\n        }\n\n        // Legacy check for smooth alignment (shouldn't happen with instant mode)\n        if (peak.evolvingTargetCenter && !peak.evolvingLock) {\n          var _peak$evolvingMoveSpe;\n          peak.currentPyramidCenter.lerp(peak.evolvingTargetCenter, (_peak$evolvingMoveSpe = peak.evolvingMoveSpeed) !== null && _peak$evolvingMoveSpe !== void 0 ? _peak$evolvingMoveSpe : 0.1);\n          if (peak.currentPyramidCenter.distanceTo(peak.evolvingTargetCenter) < 0.02) {\n            peak.currentPyramidCenter.copy(peak.evolvingTargetCenter);\n            peak.evolvingLock = true;\n          }\n          continue;\n        }\n\n        // Base target from swarm pattern\n        var baseTarget = swarmPositions[i];\n\n        // Accumulate force offset (positional) instead of velocity\n        var forceOffset = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n\n        // NEW: Track if break happens this frame\n        this._pairStates[i].breakThisFrame = false;\n\n        // Apply forces (pairing first so it can flag breaks)\n        this._applyPairingForces(i, forceOffset);\n\n        // Only apply repulsion if no break happened\n        if (!this._pairStates[i].breakThisFrame) {\n          this._applyRepulsionForces(i, forceOffset);\n        }\n        this._applyExplorationForces(i, forceOffset, this.time);\n\n        // Apply exponential decay to force offset (reduces oscillation)\n        var dampingFactor = 0.85;\n        forceOffset.multiplyScalar(dampingFactor);\n\n        // Clamp total force\n        if (forceOffset.length() > M.maxOffset) {\n          forceOffset.setLength(M.maxOffset);\n        }\n\n        // NEW: Track velocity and limit it\n        if (!this._velocities[i]) this._velocities[i] = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n        var velocity = this._velocities[i];\n\n        // Blend swirl target with current position\n        var state = this._pairStates[i];\n        var swirlWeight = state && state.partner !== -1 ? M.swarmWeight * 0.55 : M.swarmWeight;\n        var swirlTarget = peak.currentPyramidCenter.clone().lerp(baseTarget, swirlWeight);\n        var adjustedTarget = swirlTarget.add(forceOffset);\n\n        // Calculate desired velocity from LERP\n        var desiredMove = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3().subVectors(adjustedTarget, peak.currentPyramidCenter);\n        var desiredVel = desiredMove.multiplyScalar(M.followLerp);\n\n        // Smoothly blend velocity (prevents abrupt changes)\n        velocity.lerp(desiredVel, 0.3);\n\n        // LIMIT VELOCITY to maxVelocity\n        if (velocity.length() > M.maxVelocity) {\n          velocity.setLength(M.maxVelocity);\n        }\n\n        // Apply velocity\n        peak.currentPyramidCenter.add(velocity);\n      }\n\n      // Update state tracking\n      for (var _i2 = 0; _i2 < this.peaks.length; _i2++) {\n        if (this.peaks[_i2] && this.peaks[_i2].currentPyramidCenter) {\n          if (!this._lastPositions[_i2]) this._lastPositions[_i2] = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n          this._lastPositions[_i2].copy(this.peaks[_i2].currentPyramidCenter);\n        }\n      }\n\n      // Grain updates\n      this.peaks.forEach(function (peak, index) {\n        if (!peak || !peak.grains) return;\n        if (_this5.categoryFilterActive && peak.categoryVisible === false) return;\n\n        // Default/audio height for main screen\n        var frequencyIndex = index % Math.max(frequencyData.length, 1);\n        var targetHeight = frequencyData.length > 0 ? frequencyData[frequencyIndex] / 256 * 5 : 5;\n        if (typeof _this5.previousHeights[index] !== 'number') _this5.previousHeights[index] = targetHeight;\n        var smoothedHeight = _this5.previousHeights[index] * 0.8 + targetHeight * 0.2;\n        _this5.previousHeights[index] = smoothedHeight;\n        var topY = null;\n        if (_this5.evolvingActive) {\n          var solid = _this5.peakSolids[index];\n          if (solid) {\n            var _solid$userData, _solid$userData2;\n            var clearance = (_solid$userData = solid.userData) === null || _solid$userData === void 0 ? void 0 : _solid$userData.grainClearance;\n            var centerOffsetY = (_solid$userData2 = solid.userData) === null || _solid$userData2 === void 0 ? void 0 : _solid$userData2.centerOffsetY;\n            if (clearance === undefined || centerOffsetY === undefined) {\n              var bb = new three__WEBPACK_IMPORTED_MODULE_2__.Box3().setFromObject(solid);\n              var size = bb.getSize(new three__WEBPACK_IMPORTED_MODULE_2__.Vector3());\n              var center = bb.getCenter(new three__WEBPACK_IMPORTED_MODULE_2__.Vector3());\n              clearance = size.y * 0.5 + _this5.defaultGrainClearance;\n              centerOffsetY = center.y - solid.position.y;\n              solid.userData.grainClearance = clearance;\n              solid.userData.centerOffsetY = centerOffsetY;\n            }\n            var centerY = solid.position.y + centerOffsetY;\n            topY = centerY - clearance;\n          }\n        }\n        var GRAIN_THRESHOLD = _this5.categoryFilterActive ? _this5.grainsPerVisiblePeak : peak.grains.length;\n        for (var j = 0; j < peak.grains.length; j++) {\n          var grain = peak.grains[j];\n          if (!grain || !grain.userData) continue;\n          if (_this5.categoryFilterActive && grain.visible === false || j >= GRAIN_THRESHOLD) continue;\n          var _grain$userData = grain.userData,\n            heightFactor = _grain$userData.heightFactor,\n            angle = _grain$userData.angle,\n            randomization = _grain$userData.randomization;\n          if (!heightFactor || !angle || !randomization) continue;\n          var t = performance.now() * 0.001;\n          var minRadius = 0.8 * _this5.baseRadius;\n          var maxRadius = _this5.baseRadius * 2.5;\n          var baseRadius = minRadius + (1 - heightFactor) * (maxRadius - minRadius);\n          var wanderAngle = angle + Math.sin(t * (0.15 + 0.4 * randomization[0]) + j) * 2.5 + Math.cos(t * (0.2 + 0.3 * randomization[1]) + j * 0.5) * 1.8;\n          var wanderRadius = baseRadius + Math.sin(t * (0.12 + 0.2 * randomization[2]) + j * 0.3) * 0.4 + Math.cos(t * (0.1 + 0.25 * randomization[3]) + j * 0.25) * 0.5;\n          var wanderHeight = void 0;\n          if (_this5.evolvingActive && topY !== null) {\n            var baseY = typeof peak.evolveBaseY === 'number' ? peak.evolveBaseY : typeof _this5.evolveSessionBaseY === 'number' ? _this5.evolveSessionBaseY : 0;\n            var range = Math.max(0.1, topY - baseY); // ensure positive\n\n            var noise = (Math.sin(t * (0.18 + 0.25 * randomization[1]) + j * 0.2) * 0.12 + Math.cos(t * (0.22 + 0.15 * randomization[2]) + j * 0.15) * 0.08) * range * 0.2;\n            wanderHeight = baseY + heightFactor * range + noise;\n            // Clamp strictly within [baseY, topY]\n            if (wanderHeight > topY) wanderHeight = topY - 0.02;\n            if (wanderHeight < baseY) wanderHeight = baseY + 0.02;\n          } else {\n            // Default main-screen behavior\n            wanderHeight = heightFactor * smoothedHeight + Math.sin(t * (0.18 + 0.25 * randomization[1]) + j * 0.2) * 0.8 * smoothedHeight * 0.3 + Math.cos(t * (0.22 + 0.15 * randomization[2]) + j * 0.15) * 0.6 * smoothedHeight * 0.25;\n          }\n          var vagueTarget = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(peak.currentPyramidCenter.x + wanderRadius * Math.cos(wanderAngle), Math.max(0.1, wanderHeight), peak.currentPyramidCenter.z + wanderRadius * Math.sin(wanderAngle));\n          if (!grain.userData.velocity) grain.userData.velocity = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n          if (!grain.userData.acceleration) grain.userData.acceleration = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n          var toVague = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3().subVectors(vagueTarget, grain.position);\n          var springStrength = grain.userData.baseAccel * 0.12;\n          grain.userData.acceleration.copy(toVague).multiplyScalar(springStrength);\n          var fromCenter = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3().subVectors(grain.position, peak.currentPyramidCenter);\n          var distFromCenter = fromCenter.length();\n          if (distFromCenter > 0.001) {\n            var up = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(0, 1, 0);\n            var orbitDir = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3().crossVectors(fromCenter, up).normalize();\n            var orbitSpeed = 0.4 + 0.08 * randomization[0];\n            var orbitPhase = t * orbitSpeed + grain.userData.transitionSeed;\n            var orbitAmount = 0.15 + 0.12 * Math.sin(orbitPhase + j * 0.2);\n            if (!grain.userData.orbitDeviation || t - (grain.userData.lastDeviationTime || 0) > 1.5 + Math.random() * 1.5) {\n              grain.userData.orbitDeviation = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3((Math.random() - 0.5) * 0.15, (Math.random() - 0.5) * 0.25, (Math.random() - 0.5) * 0.2);\n              grain.userData.lastDeviationTime = t;\n            }\n            orbitDir.add(grain.userData.orbitDeviation.clone().multiplyScalar(0.3)).normalize();\n            grain.userData.acceleration.add(orbitDir.multiplyScalar(orbitAmount));\n            grain.userData.acceleration.y += Math.sin(orbitPhase + j * 0.3) * 0.03;\n          }\n          grain.userData.velocity.add(grain.userData.acceleration);\n          grain.userData.velocity.multiplyScalar(0.88);\n          var maxSpeed = grain.userData.maxSpeed * 1.8;\n          if (grain.userData.velocity.length() > maxSpeed) {\n            grain.userData.velocity.setLength(maxSpeed);\n          }\n          grain.position.add(grain.userData.velocity);\n        }\n      });\n\n      // Update solid positions\n      var minSolidLength = Math.min(this.peaks.length, this.peakSolids.length, this.previousHeights.length);\n      for (var _i3 = 0; _i3 < minSolidLength; _i3++) {\n        var solid = this.peakSolids[_i3];\n        var _peak = this.peaks[_i3];\n        var height = this.previousHeights[_i3];\n        if (!solid || !_peak || !_peak.currentPyramidCenter || typeof height !== 'number') continue;\n        if (this.categoryFilterActive && (_peak.categoryVisible === false || solid.visible === false)) continue;\n        solid.position.x = _peak.currentPyramidCenter.x;\n        solid.position.z = _peak.currentPyramidCenter.z;\n        if (!solid.userData.evolvingManualY) {\n          solid.position.y = height + 10;\n        }\n      }\n\n      // Update solids' custom animations\n      var _iterator = _createForOfIteratorHelper(this.peakSolids),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _solid = _step.value;\n          if (_solid && _solid.userData && _solid.userData.update) {\n            var elapsed = performance.now() * 0.001;\n            _solid.userData.update(elapsed);\n          }\n        }\n\n        // Update grid lighting\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      this.updateGridLighting();\n    }\n  }, {\n    key: \"updateGridLighting\",\n    value: function updateGridLighting() {\n      var lightPositions = [];\n      var lightIntensities = [];\n      for (var i = 0; i < this.peakSolids.length; i++) {\n        var solid = this.peakSolids[i];\n        if (solid && solid.position && (!this.categoryFilterActive || solid.visible !== false)) {\n          // <--- respect flag\n          lightPositions.push(solid.position.x, solid.position.y, solid.position.z);\n          lightIntensities.push(1.5);\n        }\n      }\n      for (var _i4 = 0; _i4 < this.peaks.length; _i4 += 2) {\n        var peak = this.peaks[_i4];\n        if (peak && peak.currentPyramidCenter && lightIntensities.length < 20) {\n          lightPositions.push(peak.currentPyramidCenter.x, peak.currentPyramidCenter.y + this.previousHeights[_i4] * 0.5, peak.currentPyramidCenter.z);\n          lightIntensities.push(0.6);\n        }\n      }\n      while (lightPositions.length < 60) {\n        lightPositions.push(0);\n      }\n      while (lightIntensities.length < 20) {\n        lightIntensities.push(0);\n      }\n      if (this.scene.userData.dynamicGrid) {\n        var material = this.scene.userData.dynamicGrid.material;\n        var posArray = new Float32Array(lightPositions);\n        var intArray = new Float32Array(lightIntensities);\n        material.uniforms.lightPositions.value = posArray;\n        material.uniforms.lightIntensities.value = intArray;\n        material.uniforms.maxLights.value = Math.min(lightIntensities.filter(function (i) {\n          return i > 0;\n        }).length, 20);\n        material.needsUpdate = true;\n      }\n    }\n  }, {\n    key: \"getPeakPositions\",\n    value: function getPeakPositions() {\n      var positions = [];\n      for (var i = 0; i < this.peaks.length; i++) {\n        if (this.peaks[i] && this.peaks[i].currentPyramidCenter) {\n          positions.push({\n            index: i,\n            position: this.peaks[i].currentPyramidCenter.clone()\n          });\n        }\n      }\n      return positions;\n    }\n  }, {\n    key: \"getSolids\",\n    value: function getSolids() {\n      // Guard clause - return empty array if not initialized\n      if (!this.peakSolids || this.peakSolids.length === 0) {\n        return [];\n      }\n      return this.peakSolids;\n    }\n  }, {\n    key: \"updatePeaks\",\n    value: function updatePeaks() {\n      if (this.stopAllMovement) {\n        return;\n      }\n    }\n  }, {\n    key: \"updateSolidPositions\",\n    value: function updateSolidPositions() {\n      if (this.stopAllMovement) {\n        return;\n      }\n    }\n  }, {\n    key: \"applyCategoryVisibilityBySolids\",\n    value: function applyCategoryVisibilityBySolids(visibleSolids) {\n      var grainsPerSolution = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 300;\n      this.categoryFilterActive = true;\n      this.grainsPerVisiblePeak = grainsPerSolution;\n      var visibleSet = new Set(visibleSolids);\n      for (var i = 0; i < this.peaks.length; i++) {\n        var peak = this.peaks[i];\n        var solid = this.peakSolids[i];\n        var isVisible = solid ? visibleSet.has(solid) : false;\n        if (solid) solid.visible = isVisible;\n        if (peak) {\n          peak.categoryVisible = isVisible;\n          if (Array.isArray(peak.grains)) {\n            for (var g = 0; g < peak.grains.length; g++) {\n              var grain = peak.grains[g];\n              if (!grain) continue;\n              grain.visible = isVisible && g < grainsPerSolution;\n            }\n          }\n        }\n      }\n    }\n\n    // Restore everything (deactivate filter)\n  }, {\n    key: \"clearCategoryVisibility\",\n    value: function clearCategoryVisibility() {\n      this.categoryFilterActive = false;\n      for (var i = 0; i < this.peaks.length; i++) {\n        var peak = this.peaks[i];\n        var solid = this.peakSolids[i];\n        if (solid) solid.visible = true;\n        if (peak) {\n          peak.categoryVisible = true;\n          if (Array.isArray(peak.grains)) {\n            for (var g = 0; g < peak.grains.length; g++) {\n              var grain = peak.grains[g];\n              if (grain) grain.visible = true;\n            }\n          }\n        }\n      }\n    }\n\n    // Find and establish pairs\n  }, {\n    key: \"_findPairs\",\n    value: function _findPairs() {\n      var M = this.motionSystem;\n\n      // Clear cooldowns and decay grace\n      for (var i = 0; i < this._pairStates.length; i++) {\n        var state = this._pairStates[i];\n        if (state.cooldown > 0) state.cooldown--;\n        if (state.breakGrace > 0) {\n          state.breakGrace--;\n          if (state.breakGrace === 0) state.breakPartner = -1;\n        }\n      }\n\n      // NEW: Rebuild spatial grid (O(N))\n      this.spatialGrid.clear();\n      for (var _i5 = 0; _i5 < this.peaks.length; _i5++) {\n        var peak = this.peaks[_i5];\n        if (peak !== null && peak !== void 0 && peak.currentPyramidCenter) {\n          this.spatialGrid.insert(_i5, peak.currentPyramidCenter);\n        }\n      }\n\n      // Check existing pairs for distance-based breaks (O(P) where P = number of pairs)\n      for (var _i6 = 0; _i6 < this._pairStates.length; _i6++) {\n        var _this$peaks$_i, _this$peaks$partnerId, _M$pairKeepRadius;\n        var _state = this._pairStates[_i6];\n        var partnerIdx = _state.partner;\n        if (partnerIdx === -1) continue;\n        var partnerState = this._pairStates[partnerIdx];\n        var A = (_this$peaks$_i = this.peaks[_i6]) === null || _this$peaks$_i === void 0 ? void 0 : _this$peaks$_i.currentPyramidCenter;\n        var B = (_this$peaks$partnerId = this.peaks[partnerIdx]) === null || _this$peaks$partnerId === void 0 ? void 0 : _this$peaks$partnerId.currentPyramidCenter;\n        if (!A || !B || !partnerState) continue;\n        var dist = A.distanceTo(B);\n        if (dist > ((_M$pairKeepRadius = M.pairKeepRadius) !== null && _M$pairKeepRadius !== void 0 ? _M$pairKeepRadius : Infinity)) {\n          var grace = M.breakGraceFrames || 0;\n\n          // Set grace on both\n          _state.breakGrace = grace;\n          _state.breakPartner = partnerIdx;\n          partnerState.breakGrace = grace;\n          partnerState.breakPartner = _i6;\n\n          // Symmetric unpair + cooldown\n          _state.partner = -1;\n          _state.frames = 0;\n          _state.cooldown = M.pairCooldown;\n          partnerState.partner = -1;\n          partnerState.frames = 0;\n          partnerState.cooldown = M.pairCooldown;\n        }\n      }\n\n      // Try to form new pairs using spatial grid (O(N * k) where k = avg neighbors per cell)\n      for (var _i7 = 0; _i7 < this.peaks.length; _i7++) {\n        var _solidA$userData;\n        var _state2 = this._pairStates[_i7];\n        if (_state2.partner !== -1 || _state2.cooldown > 0) continue;\n        var peakA = this.peaks[_i7];\n        if (!peakA || !peakA.currentPyramidCenter) continue;\n        var solidA = this.peakSolids[_i7];\n        var catA = solidA === null || solidA === void 0 || (_solidA$userData = solidA.userData) === null || _solidA$userData === void 0 || (_solidA$userData = _solidA$userData.solution) === null || _solidA$userData === void 0 ? void 0 : _solidA$userData.assigned_category;\n        if (!catA) continue;\n        var bestPartner = -1;\n        var bestDist = M.pairFormRadius;\n\n        // NEW: Only check nearby peaks (spatial query)\n        var nearbyIndices = this.spatialGrid.getNearby(peakA.currentPyramidCenter, M.pairFormRadius);\n        var _iterator2 = _createForOfIteratorHelper(nearbyIndices),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var _solidB$userData;\n            var j = _step2.value;\n            if (_i7 === j) continue;\n            var stB = this._pairStates[j];\n            if (stB.partner !== -1 || stB.cooldown > 0) continue;\n            var peakB = this.peaks[j];\n            if (!peakB || !peakB.currentPyramidCenter) continue;\n            var solidB = this.peakSolids[j];\n            var catB = solidB === null || solidB === void 0 || (_solidB$userData = solidB.userData) === null || _solidB$userData === void 0 || (_solidB$userData = _solidB$userData.solution) === null || _solidB$userData === void 0 ? void 0 : _solidB$userData.assigned_category;\n            if (!(catB && (complementary_map[catA] === catB || complementary_map[catB] === catA))) continue;\n            var _dist = peakA.currentPyramidCenter.distanceTo(peakB.currentPyramidCenter);\n            if (_dist <= bestDist) {\n              bestDist = _dist;\n              bestPartner = j;\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n        if (bestPartner !== -1) {\n          _state2.partner = bestPartner;\n          _state2.frames = 0;\n          this._pairStates[bestPartner].partner = _i7;\n          this._pairStates[bestPartner].frames = 0;\n          var pairIndex = Math.min(_i7, bestPartner);\n          if (!this._pairDirections[pairIndex]) {\n            this._pairDirections[pairIndex] = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(Math.random() - 0.5, 0, Math.random() - 0.5).normalize();\n          }\n        }\n      }\n    }\n\n    // Apply repulsion/attraction forces\n  }, {\n    key: \"_applyRepulsionForces\",\n    value: function _applyRepulsionForces(index, forceOffset) {\n      var peak = this.peaks[index];\n      var M = this.motionSystem;\n      var myState = this._pairStates[index];\n      var myPartner = myState === null || myState === void 0 ? void 0 : myState.partner;\n\n      // NEW: Only check nearby peaks (spatial query) - REPLACES the full loop\n      var searchRadius = Math.max(M.minSeparation, M.complementaryRange);\n      var nearbyIndices = this.spatialGrid.getNearby(peak.currentPyramidCenter, searchRadius);\n\n      // CHANGED: Loop only through nearby peaks instead of ALL peaks\n      var _iterator3 = _createForOfIteratorHelper(nearbyIndices),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var j = _step3.value;\n          if (index === j) continue;\n          var other = this.peaks[j];\n          if (!other || !other.currentPyramidCenter) continue;\n          var delta = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3().subVectors(peak.currentPyramidCenter, other.currentPyramidCenter);\n          var dist = delta.length();\n          if (dist < 0.0001) continue;\n\n          // Fade interactions with the most-recent ex-partner after break\n          var graceScale = 1.0;\n          if (myState && myState.breakGrace > 0 && j === myState.breakPartner) {\n            var t = myState.breakGrace / Math.max(1, M.breakGraceFrames);\n            graceScale = 1 - t;\n          }\n\n          // Reduce repulsion between paired members\n          var repulsionScale = 1.0;\n          if (myPartner !== -1 && j === myPartner) {\n            repulsionScale = 0.4;\n          }\n\n          // Repulsion\n          if (dist < M.minSeparation) {\n            var push = (1 - dist / M.minSeparation) * M.repulsionStrength * M.repulsionWeight * graceScale * repulsionScale;\n            forceOffset.addScaledVector(delta.normalize(), push * M.minSeparation);\n          }\n\n          // Complementary attraction\n          var solidA = this.peakSolids[index];\n          var solidB = this.peakSolids[j];\n          if (solidA && solidB) {\n            var _solidA$userData2, _solidB$userData2;\n            var catA = (_solidA$userData2 = solidA.userData) === null || _solidA$userData2 === void 0 || (_solidA$userData2 = _solidA$userData2.solution) === null || _solidA$userData2 === void 0 ? void 0 : _solidA$userData2.assigned_category;\n            var catB = (_solidB$userData2 = solidB.userData) === null || _solidB$userData2 === void 0 || (_solidB$userData2 = _solidB$userData2.solution) === null || _solidB$userData2 === void 0 ? void 0 : _solidB$userData2.assigned_category;\n            if (catA && catB && (complementary_map[catA] === catB || complementary_map[catB] === catA)) {\n              if (myPartner !== -1 && j !== myPartner) continue;\n              var inner = M.minSeparation * 1.2;\n              if (dist < M.complementaryRange && dist > inner) {\n                var _t = (dist - inner) / Math.max(1e-6, M.complementaryRange - inner);\n                _t = Math.min(Math.max(_t, 0), 1);\n                var smooth = (1 - _t) * (1 - _t);\n                var pull = M.complementaryPull * M.attractionWeight * smooth * graceScale;\n                forceOffset.addScaledVector(delta.normalize(), -pull * M.minSeparation);\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    }\n\n    // Apply pairing forces\n  }, {\n    key: \"_applyPairingForces\",\n    value: function _applyPairingForces(index, forceOffset) {\n      var peak = this.peaks[index];\n      var state = this._pairStates[index];\n      var M = this.motionSystem;\n      while (this._pairDirections.length < this.peaks.length) {\n        this._pairDirections.push(new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(Math.random() - 0.5, 0, Math.random() - 0.5).normalize());\n      }\n      if (state.partner !== -1) {\n        state.frames++;\n        var partner = this.peaks[state.partner];\n        if (!(partner !== null && partner !== void 0 && partner.currentPyramidCenter)) return;\n        var toPartner = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3().subVectors(partner.currentPyramidCenter, peak.currentPyramidCenter);\n        var dist = toPartner.length();\n        if (dist < 1e-6) return;\n        var u = toPartner.normalize();\n\n        // === BOIDS FLOCKING: 3 forces ===\n\n        // 1. SEPARATION: maintain desired spacing\n        var separationError = dist - M.pairDesiredSeparation;\n        if (dist < M.pairDesiredSeparation) {\n          // Too close: push apart\n          var proximity = 1 - dist / M.pairDesiredSeparation; // 1 at overlap, 0 at desired\n          var separationForce = proximity * M.pairSeparationStrength * M.pairingWeight;\n          forceOffset.addScaledVector(u, -separationForce); // push away\n        } else if (dist > M.pairDesiredSeparation * 1.5) {\n          // Too far: pull together (cohesion kicks in)\n          var excess = dist - M.pairDesiredSeparation;\n          var _cohesionForce = excess / M.pairDesiredSeparation * M.pairSeparationStrength * 0.5 * M.pairingWeight;\n          forceOffset.addScaledVector(u, _cohesionForce); // pull closer\n        }\n\n        // 2. COHESION: pull toward shared center (explicit flocking behavior)\n        var midpoint = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3().addVectors(peak.currentPyramidCenter, partner.currentPyramidCenter).multiplyScalar(0.5);\n        var toMidpoint = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3().subVectors(midpoint, peak.currentPyramidCenter);\n        var cohesionForce = M.pairCohesionStrength * M.pairingWeight;\n        forceOffset.addScaledVector(toMidpoint.normalize(), cohesionForce);\n\n        // 3. ALIGNMENT: match heading with partner\n        var pairIndex = Math.min(index, state.partner);\n        var heading = this._pairDirections[pairIndex];\n\n        // Update shared heading (only once per pair)\n        if (index === pairIndex) {\n          // Desired heading = tangent to circular motion around origin\n          var center = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3().addVectors(peak.currentPyramidCenter, partner.currentPyramidCenter).multiplyScalar(0.5);\n          var radial = center.clone().setY(0);\n          var tangent = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(1, 0, 0);\n          if (radial.lengthSq() > 1e-6) {\n            tangent.crossVectors(radial, new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(0, 1, 0)).normalize();\n          }\n\n          // Blend LESS with actual velocities (they lag behind desired heading)\n          var myVel = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3().subVectors(peak.currentPyramidCenter, this._lastPositions[index] || peak.currentPyramidCenter);\n          var partnerVel = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3().subVectors(partner.currentPyramidCenter, this._lastPositions[state.partner] || partner.currentPyramidCenter);\n          var avgVel = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3().addVectors(myVel, partnerVel);\n          if (avgVel.lengthSq() > 1e-6) {\n            // CHANGED: 85% tangent, 15% actual velocity (was 60/40)\n            // This prioritizes the desired direction over current momentum\n            tangent.multiplyScalar(M.headingTangentWeight || 0.85).addScaledVector(avgVel.normalize(), M.headingVelocityWeight || 0.15).normalize();\n          }\n\n          // Occasional jitter\n          if (state.frames % M.pairJitterInterval === 0) {\n            var jitterRad = M.pairHeadingJitter * Math.PI / 180 * (Math.random() - 0.5);\n            var cos = Math.cos(jitterRad);\n            var sin = Math.sin(jitterRad);\n            tangent.set(tangent.x * cos - tangent.z * sin, 0, tangent.x * sin + tangent.z * cos).normalize();\n          }\n\n          // Smooth heading update\n          heading.lerp(tangent, M.pairHeadingSmoothing).normalize();\n        }\n\n        // Apply alignment and travel forces\n        var easeProgress = Math.min(1, state.frames / Math.max(1, M.pairEaseFrames));\n        var ease = easeProgress * easeProgress * (3 - 2 * easeProgress);\n\n        // CHANGED: Apply forces separately with different weights\n        var alignForce = ease * M.pairAlignmentStrength * M.pairingWeight;\n        var travelForce = ease * M.pairTravelSpeed * M.pairingWeight;\n\n        // Alignment: steer toward heading\n        forceOffset.addScaledVector(heading, alignForce);\n\n        // Travel: move forward along heading\n        forceOffset.addScaledVector(heading, travelForce);\n\n        // Minimal wander (don't break alignment)\n        forceOffset.x += (Math.random() - 0.5) * M.wanderInPair * 0.5; // REDUCED influence (was 1.0)\n        forceOffset.z += (Math.random() - 0.5) * M.wanderInPair * 0.5;\n\n        // Check for break\n        if (state.frames > M.pairMinFrames && Math.random() < M.pairBreakProb) {\n          this._breakPair(index, state.partner, heading.clone(), ease);\n        }\n      } else {\n        var _state$breakHeading;\n        // Solo: fade out pair forces after break\n        if (state.breakFade > 0 && ((_state$breakHeading = state.breakHeading) === null || _state$breakHeading === void 0 ? void 0 : _state$breakHeading.lengthSq()) > 1e-6) {\n          var fadeProgress = state.breakFade / Math.max(1, M.breakGraceFrames);\n          var storedEase = state.breakEase || 1.0;\n          var _alignForce = fadeProgress * storedEase * M.pairAlignmentStrength * M.pairingWeight;\n          var _travelForce = fadeProgress * storedEase * M.pairTravelSpeed * M.pairingWeight;\n          forceOffset.addScaledVector(state.breakHeading, _alignForce + _travelForce);\n          state.breakFade--;\n        }\n\n        // Exploration: ramp up as pair forces fade\n        var explorationScale = state.breakFade > 0 ? 1 - state.breakFade / Math.max(1, M.breakGraceFrames) : 1.0;\n        forceOffset.x += (Math.random() - 0.5) * M.wanderStrength * explorationScale;\n        forceOffset.z += (Math.random() - 0.5) * M.wanderStrength * explorationScale;\n      }\n    }\n    // Helper method to break a pair cleanly\n  }, {\n    key: \"_breakPair\",\n    value: function _breakPair(indexA, indexB, currentHeading, currentEase) {\n      var M = this.motionSystem;\n      var grace = M.breakGraceFrames || 0;\n\n      // Break member A\n      var stateA = this._pairStates[indexA];\n      stateA.partner = -1;\n      stateA.frames = 0;\n      stateA.cooldown = M.pairCooldown;\n      stateA.breakGrace = grace;\n      stateA.breakPartner = indexB;\n      stateA.breakFade = grace;\n      stateA.breakHeading.copy(currentHeading);\n      stateA.breakEase = currentEase;\n      stateA.breakThisFrame = true;\n\n      // Break member B\n      var stateB = this._pairStates[indexB];\n      if (stateB) {\n        stateB.partner = -1;\n        stateB.frames = 0;\n        stateB.cooldown = M.pairCooldown;\n        stateB.breakGrace = grace;\n        stateB.breakPartner = indexA;\n        stateB.breakFade = grace;\n        stateB.breakHeading.copy(currentHeading);\n        stateB.breakEase = currentEase;\n        stateB.breakThisFrame = true;\n      }\n    }\n    // Apply exploration forces  \n  }, {\n    key: \"_applyExplorationForces\",\n    value: function _applyExplorationForces(index, forceOffset, time) {\n      var peak = this.peaks[index];\n      var M = this.motionSystem;\n      var state = this._pairStates[index];\n      var isPaired = state && state.partner !== -1;\n\n      // 1. REDUCE EXPLORATION WHEN PAIRED (so pair heading dominates)\n      var scale = isPaired ? M.explorationPairedScale : 1.0;\n\n      // 2. CIRCULAR DRIFT (orbit around origin)\n      var seed = peak.exploreSeed || 0;\n      var orbitAngle = time * 0.07 + seed * 0.013;\n      var orbitRadius = 40;\n      var circularDrift = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(Math.cos(orbitAngle) * orbitRadius, 0, Math.sin(orbitAngle) * orbitRadius);\n\n      // Apply as force (not position), scaled by circular bias\n      var circularForce = M.circularBias * M.explorationWeight * scale;\n      forceOffset.addScaledVector(circularDrift.normalize(), circularForce);\n\n      // 3. NOISE WANDER (random walk)\n      var noisePhase = time * 0.12 + seed * 0.3;\n      var noiseX = Math.sin(noisePhase * 1.31 + seed * 0.2);\n      var noiseZ = Math.cos(noisePhase * 1.17 + seed * 0.35);\n      forceOffset.x += noiseX * M.wanderStrength * scale;\n      forceOffset.z += noiseZ * M.wanderStrength * scale;\n\n      // 4. BOUNDARY FORCES\n      var radial = peak.currentPyramidCenter.clone().setY(0);\n      var radialLen = radial.length();\n\n      // Soft outer boundary (push inward when too far)\n      if (radialLen > M.maxRange) {\n        var excess = radialLen - M.maxRange;\n        var pushInward = excess * 0.05;\n        forceOffset.addScaledVector(radial.normalize(), -pushInward);\n      }\n\n      // Center avoidance (push outward when too close to origin)\n      if (radialLen < M.avoidCenterRadius) {\n        var proximity = 1 - radialLen / M.avoidCenterRadius; // 1 at center, 0 at radius\n        var pushOutward = proximity * proximity * M.avoidCenterStrength; // quadratic falloff\n\n        if (radialLen > 1e-4) {\n          forceOffset.addScaledVector(radial.normalize(), pushOutward);\n        } else {\n          // Exactly at center - pick random outward direction\n          var randomDir = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(Math.random() - 0.5, 0, Math.random() - 0.5).normalize();\n          forceOffset.addScaledVector(randomDir, M.avoidCenterStrength);\n        }\n      }\n    }\n  }], [{\n    key: \"create\",\n    value: function create(scene) {\n      var baseRadius = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n      return new ParticleSystem(scene, baseRadius);\n    }\n  }]);\n}();\n\n//# sourceURL=webpack://sound-particle-visualization/./src/components/ParticleSystem.js?");

/***/ }),

/***/ "./src/components/PythonCommunication.js":
/*!***********************************************!*\
  !*** ./src/components/PythonCommunication.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PythonCommunication: () => (/* binding */ PythonCommunication)\n/* harmony export */ });\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar PythonCommunication = /*#__PURE__*/function () {\n  function PythonCommunication(particleSystem) {\n    var _this = this;\n    var onGenerationData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    var onConnectionReady = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    var onRegenerationStart = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    _classCallCheck(this, PythonCommunication);\n    console.log('üêç Initializing Python Communication...');\n    this.particleSystem = particleSystem;\n    this.websocket = null;\n    this.currentGeneration = null;\n    this.currentSolutions = [];\n    this.connectionStatus = 'connecting';\n    this.onGenerationData = onGenerationData;\n    this.onConnectionReady = onConnectionReady;\n    this.onRegenerationStart = onRegenerationStart;\n    this.dataReceived = false;\n    this._lastFeedbackTime = 0; // FIXED: Initialize to 0 instead of null\n\n    this.connectToPython();\n    this.connectionCheckInterval = setInterval(function () {\n      _this.logConnectionStatus();\n    }, 5000);\n  }\n  return _createClass(PythonCommunication, [{\n    key: \"logConnectionStatus\",\n    value: function logConnectionStatus() {\n      console.log('üîç Connection Status Check:');\n      console.log('  - WebSocket exists:', !!this.websocket);\n      console.log('  - WebSocket state:', this.websocket ? this.websocket.readyState : 'N/A');\n      console.log('  - Current status:', this.connectionStatus);\n      console.log('  - Solutions received:', this.currentSolutions.length);\n    }\n  }, {\n    key: \"connectToPython\",\n    value: function connectToPython() {\n      var _this2 = this;\n      try {\n        console.log('üêç Attempting to connect to Python WebSocket server at ws://localhost:8765');\n        this.websocket = new WebSocket('ws://localhost:8765');\n        this.websocket.onopen = function () {\n          console.log('‚úÖ Connected to Python evolution engine');\n          _this2.updateConnectionStatus('connected');\n        };\n        this.websocket.onmessage = function (event) {\n          try {\n            var data = JSON.parse(event.data);\n            console.log('üì® Message received:', data.type, \"Generation \".concat(data.generation));\n            _this2.handlePythonMessage(data);\n          } catch (error) {\n            console.error('‚ùå Failed to parse JSON message:', error);\n          }\n        };\n        this.websocket.onclose = function (event) {\n          console.log('üêç WebSocket connection closed');\n          _this2.updateConnectionStatus('disconnected');\n          setTimeout(function () {\n            return _this2.connectToPython();\n          }, 3000);\n        };\n        this.websocket.onerror = function (error) {\n          console.error('üêç WebSocket error:', error);\n          _this2.updateConnectionStatus('error');\n        };\n      } catch (error) {\n        console.error('üêç Failed to create WebSocket connection:', error);\n        this.updateConnectionStatus('error');\n      }\n    }\n  }, {\n    key: \"handlePythonMessage\",\n    value: function handlePythonMessage(data) {\n      switch (data.type) {\n        case 'generation_data':\n          this.handleGenerationData(data);\n          break;\n        case 'evolution_complete':\n          this.handleEvolutionComplete(data);\n          break;\n        case 'error':\n          console.error('üêç Python error:', data.message);\n          break;\n      }\n    }\n  }, {\n    key: \"handleGenerationData\",\n    value: function handleGenerationData(data) {\n      var _data$solutions;\n      console.log(\"\\uD83E\\uDDEC Processing generation \".concat(data.generation, \" with \").concat(((_data$solutions = data.solutions) === null || _data$solutions === void 0 ? void 0 : _data$solutions.length) || 0, \" solutions\"));\n\n      // Validate data\n      if (!data.solutions || !Array.isArray(data.solutions) || data.solutions.length === 0) {\n        console.error('‚ùå Invalid generation data - no solutions:', data);\n        return;\n      }\n      this.currentGeneration = data;\n      this.currentSolutions = data.solutions;\n      this.dataReceived = true;\n      console.log('‚úÖ Generation data validated:', {\n        generation: data.generation,\n        solutionCount: data.solutions.length,\n        firstSolution: data.solutions[0]\n      });\n\n      // NEW: Notify that regeneration is starting (show loading screen)\n      if (typeof this.onRegenerationStart === 'function') {\n        this.onRegenerationStart(data);\n      }\n\n      // Update visuals\n      this.updateSolidsFromGeneration(data);\n\n      // Notify callback (audio system) - will hide loading screen after audio loads\n      if (typeof this.onGenerationData === 'function') {\n        console.log('üì¢ Calling onGenerationData callback...');\n        this.onGenerationData(data);\n      }\n    }\n  }, {\n    key: \"updateSolidsFromGeneration\",\n    value: function updateSolidsFromGeneration(generationData) {\n      var solutions = generationData.solutions;\n      console.log(\"\\uD83C\\uDFA8 Updating \".concat(solutions.length, \" solids from generation data\"));\n      this.currentSolutions = solutions;\n      this.particleSystem.regenerateWithSolutions(solutions);\n    }\n  }, {\n    key: \"updateConnectionStatus\",\n    value: function updateConnectionStatus(status) {\n      this.connectionStatus = status;\n      console.log(\"\\uD83D\\uDD0C Connection status: \".concat(status));\n    }\n\n    // **UTILITY METHODS (keep existing)**\n  }, {\n    key: \"getCurrentGeneration\",\n    value: function getCurrentGeneration() {\n      return this.currentGeneration;\n    }\n  }, {\n    key: \"getCurrentSolutions\",\n    value: function getCurrentSolutions() {\n      return this.currentSolutions;\n    }\n  }, {\n    key: \"getSolutionById\",\n    value: function getSolutionById(id) {\n      return this.currentSolutions.find(function (solution) {\n        return solution.id === id;\n      });\n    }\n  }, {\n    key: \"getSolutionByIndex\",\n    value: function getSolutionByIndex(index) {\n      return this.currentSolutions[index] || null;\n    }\n  }, {\n    key: \"isConnected\",\n    value: function isConnected() {\n      return this.connectionStatus === 'connected' && this.websocket && this.websocket.readyState === WebSocket.OPEN;\n    }\n  }, {\n    key: \"sendUserFeedback\",\n    value: function sendUserFeedback(feedbackData) {\n      if (!this.isConnected()) {\n        console.warn('‚ö†Ô∏è WS not connected. Skipping sendUserFeedback.');\n        return false;\n      }\n\n      // ENHANCED GUARDS\n      if (window.__modeTransitioning) {\n        console.warn('‚ö†Ô∏è Skipping feedback during mode transition');\n        return false;\n      }\n\n      // Check if this is a duplicate request (within 500ms)\n      var now = Date.now();\n      if (this._lastFeedbackTime && now - this._lastFeedbackTime < 500) {\n        console.warn('‚ö†Ô∏è Skipping duplicate feedback request (last: ' + (now - this._lastFeedbackTime) + 'ms ago)');\n        return false;\n      }\n\n      // Validate feedback data\n      if (!feedbackData || _typeof(feedbackData) !== 'object') {\n        console.error('‚ùå Invalid feedback data:', feedbackData);\n        return false;\n      }\n\n      // CRITICAL: Check if this is actually a feedback action (not a random button click)\n      if (feedbackData.action !== 'user_feedback') {\n        console.warn('‚ö†Ô∏è Invalid action in feedback data:', feedbackData.action);\n        return false;\n      }\n      this._lastFeedbackTime = now;\n      var payload = _objectSpread(_objectSpread({\n        action: 'user_feedback'\n      }, feedbackData), {}, {\n        timestamp: now\n      });\n      try {\n        var json = JSON.stringify(payload);\n        console.log('‚û°Ô∏è WS SEND user_feedback:', payload);\n        this.websocket.send(json);\n        return true;\n      } catch (err) {\n        console.error('‚ùå Failed to serialize feedback payload:', err, feedbackData);\n        return false;\n      }\n    }\n  }, {\n    key: \"requestEvolution\",\n    value: function requestEvolution(category) {\n      var _this$currentGenerati;\n      if (!this.isConnected()) return false;\n      this.websocket.send(JSON.stringify({\n        action: 'evolve_generation',\n        category: category,\n        generation: ((_this$currentGenerati = this.currentGeneration) === null || _this$currentGenerati === void 0 ? void 0 : _this$currentGenerati.generation) || 0,\n        timestamp: Date.now()\n      }));\n      return true;\n    }\n  }]);\n}();\n\n//# sourceURL=webpack://sound-particle-visualization/./src/components/PythonCommunication.js?");

/***/ }),

/***/ "./src/components/SaveMode.js":
/*!************************************!*\
  !*** ./src/components/SaveMode.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SaveMode: () => (/* binding */ SaveMode)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n/* harmony import */ var _Library_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Library.js */ \"./src/components/Library.js\");\n/* harmony import */ var _Button_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Button.js */ \"./src/components/Button.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _createForOfIteratorHelper(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n // Add this line\n\nvar SaveMode = /*#__PURE__*/function () {\n  function SaveMode(mainRenderer, mainCamera, controls, particleSystem) {\n    var library = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n    _classCallCheck(this, SaveMode);\n    this.mainRenderer = mainRenderer;\n    this.mainCamera = mainCamera;\n    this.controls = controls;\n    this.particleSystem = particleSystem;\n    this.solidMeshes = this.particleSystem.getSolids ? this.particleSystem.getSolids() : [];\n    this.isSaveMode = false;\n    this.selectedSolid = null;\n    this.selectedSolidIndex = -1;\n    this.hoveredSolid = null;\n    this.hoveredSolidIndex = -1;\n    this.originalPositions = [];\n    this.saveToLibraryBtn = null;\n    this.saveCombinationBtn = null;\n    this.selectedSolids = [];\n    this.boundingBoxHelpers = []; // Store bounding box helpers\n    this._saveLabelTexture = null;\n    this._hoverCooldown = new WeakMap();\n\n    // NEW: Cache materials IMMEDIATELY on construction (before any modifications)\n    this._globalMaterialCache = new WeakMap(); // mesh -> original material\n    this._cacheAllMaterialsNow();\n\n    // Track currently playing sound in Save mode\n    this._saveModePlayingId = null;\n    if (library) {\n      this.library = library;\n    } else {\n      console.error('No library provided to SaveMode');\n      return;\n    }\n    this.createSaveButton();\n    this.setupInteractions();\n  }\n\n  // NEW: Cache ALL materials immediately on construction\n  return _createClass(SaveMode, [{\n    key: \"_cacheAllMaterialsNow\",\n    value: function _cacheAllMaterialsNow() {\n      var _this$particleSystem,\n        _this = this;\n      if (!((_this$particleSystem = this.particleSystem) !== null && _this$particleSystem !== void 0 && _this$particleSystem.getSolids)) return;\n      var solids = this.particleSystem.getSolids();\n      solids.forEach(function (solid) {\n        solid.traverse(function (child) {\n          if (child.isMesh && !_this._globalMaterialCache.has(child)) {\n            // Store the ORIGINAL material (current state before ANY modifications)\n            _this._globalMaterialCache.set(child, child.material);\n          }\n        });\n      });\n      console.log('‚úÖ Global material cache initialized:', this._globalMaterialCache.size, 'meshes');\n    }\n  }, {\n    key: \"createSaveButton\",\n    value: function createSaveButton() {\n      this.saveBtn = new _Button_js__WEBPACK_IMPORTED_MODULE_1__.Button('SAVE', 'hamburger', function () {});\n    }\n  }, {\n    key: \"toggleSaveMode\",\n    value: function toggleSaveMode() {\n      if (this.isSaveMode) {\n        this.exitSaveMode();\n      } else {\n        this.enterSaveMode();\n      }\n    }\n  }, {\n    key: \"enterSaveMode\",\n    value: function enterSaveMode() {\n      var _this2 = this;\n      // Guard clause\n      if (!this.particleSystem.peaks || this.particleSystem.peaks.length === 0) {\n        console.warn('‚ö†Ô∏è Cannot enter save mode - no peaks initialized');\n        return;\n      }\n      console.log('üíæ Entering save mode');\n      this.isSaveMode = true;\n\n      // Fade out main soundscape and stop sequencing; clear any previous green highlights\n      try {\n        var _this$particleSystem2, _this$particleSystem3;\n        (_this$particleSystem2 = this.particleSystem) === null || _this$particleSystem2 === void 0 || (_this$particleSystem2 = _this$particleSystem2.surroundController) === null || _this$particleSystem2 === void 0 || _this$particleSystem2.startMode(500);\n        (_this$particleSystem3 = this.particleSystem) === null || _this$particleSystem3 === void 0 || (_this$particleSystem3 = _this$particleSystem3.surroundController) === null || _this$particleSystem3 === void 0 || _this$particleSystem3.clearAllGreenOutlines();\n      } catch (_unused) {}\n\n      // Reset Save-mode playing tracker\n      this._saveModePlayingId = null;\n      this.solidMeshes = this.particleSystem.getSolids();\n\n      // Refresh cache in case new solids were added\n      this._cacheAllMaterialsNow();\n      this._hoverCooldown = new WeakMap();\n      this.saveBtn.changeText('EXIT SAVE');\n      this.saveBtn.setSelected(true);\n      this.originalPositions = [];\n      for (var i = 0; i < this.solidMeshes.length; i++) {\n        var solid = this.solidMeshes[i];\n        this.originalPositions.push({\n          position: solid.position.clone(),\n          rotation: solid.rotation.clone()\n        });\n        solid.userData.frozenPosition = solid.position.clone();\n        solid.userData.frozenRotation = solid.rotation.clone();\n      }\n      this.particleSystem.targetLocked = true;\n      this.particleSystem.stopAllMovement = true;\n      this.particleSystem.peaks.forEach(function (peak, index) {\n        peak.lockedCenter = peak.currentPyramidCenter.clone();\n        peak.readyForNextMove = false;\n        peak.lockedHeight = _this2.particleSystem.previousHeights[index] || 5;\n        peak.frozen = true;\n      });\n      this.particleSystem.frozenSwarmPositions = this.particleSystem.peaks.map(function (peak) {\n        return peak.currentPyramidCenter.clone();\n      });\n      this.mainRenderer.domElement.addEventListener('click', this.onMouseClick);\n      this.mainRenderer.domElement.addEventListener('mousemove', this.onMouseMove);\n      console.log('‚úÖ Entered Save Mode - All movement stopped, solids frozen in place');\n    }\n  }, {\n    key: \"exitSaveMode\",\n    value: function exitSaveMode() {\n      if (!this.isSaveMode) return;\n      console.log('üö™ Exiting Save Mode...');\n      this.isSaveMode = false;\n\n      // CRITICAL: Stop ALL audio FIRST\n      try {\n        var _this$particleSystem4;\n        (_this$particleSystem4 = this.particleSystem) === null || _this$particleSystem4 === void 0 || (_this$particleSystem4 = _this$particleSystem4.surroundController) === null || _this$particleSystem4 === void 0 || _this$particleSystem4.stopAllManualPlayback();\n      } catch (e) {\n        console.error('Failed to stop audio on save exit:', e);\n      }\n\n      // STEP 2: Update UI\n      this.saveBtn.setSelected(false);\n      this.saveBtn.changeText('SAVE');\n\n      // STEP 3: Remove event listeners\n      this.mainRenderer.domElement.removeEventListener('click', this.onMouseClick);\n      this.mainRenderer.domElement.removeEventListener('mousemove', this.onMouseMove);\n\n      // STEP 4: Clear hover state\n      this.hoveredSolid = null;\n      this.hoveredSolidIndex = -1;\n      this.mainRenderer.domElement.style.cursor = 'default';\n\n      // STEP 5: ATOMIC material cleanup\n      this._atomicMaterialCleanup();\n\n      // STEP 6: Unfreeze movement\n      this.particleSystem.targetLocked = false;\n      this.particleSystem.stopAllMovement = false;\n      this.particleSystem.peaks.forEach(function (peak) {\n        peak.frozen = false;\n        peak.readyForNextMove = true;\n      });\n\n      // STEP 7: Reset trackers\n      this._hoverCooldown = new WeakMap();\n      this._baseMaterialsCached = false;\n      console.log('‚úÖ Save Mode exited cleanly');\n    }\n\n    // NEW: Single atomic cleanup function that does EVERYTHING\n  }, {\n    key: \"_atomicMaterialCleanup\",\n    value: function _atomicMaterialCleanup() {\n      var _this3 = this;\n      console.log('üßπ Starting atomic material cleanup');\n\n      // Track what we're cleaning\n      var cleanedMeshes = 0;\n      var restoredMaterials = 0;\n      this.solidMeshes.forEach(function (solid) {\n        if (!solid) return;\n\n        // Remove UI elements for this solid\n        if (solid.userData.saveToLibraryBtn) {\n          solid.userData.saveToLibraryBtn.remove();\n          solid.userData.saveToLibraryBtn = null;\n        }\n        if (solid.userData.save3DIcon) {\n          _this3.particleSystem.scene.remove(solid.userData.save3DIcon);\n          solid.userData.save3DIcon = null;\n        }\n        if (solid.userData.saveConnectionLine) {\n          var _solid$userData$saveC, _solid$userData$saveC2;\n          _this3.particleSystem.scene.remove(solid.userData.saveConnectionLine);\n          _this3.particleSystem.scene.remove(solid.userData.saveConnectionLine);\n          (_solid$userData$saveC = solid.userData.saveConnectionLine.geometry) === null || _solid$userData$saveC === void 0 || _solid$userData$saveC.dispose();\n          (_solid$userData$saveC2 = solid.userData.saveConnectionLine.material) === null || _solid$userData$saveC2 === void 0 || _solid$userData$saveC2.dispose();\n          solid.userData.saveConnectionLine = null;\n        }\n        if (solid.userData.saveLabelSprite) {\n          solid.userData.saveLabelSprite = null;\n        }\n\n        // Clear flags\n        delete solid.userData.__saveModeSelected;\n\n        // Restore materials for all child meshes\n        solid.traverse(function (child) {\n          if (!child.isMesh) return;\n          cleanedMeshes++;\n\n          // Get the ORIGINAL cached material\n          var originalMaterial = _this3._globalMaterialCache.get(child);\n          if (originalMaterial) {\n            child.material = originalMaterial;\n            restoredMaterials++;\n          }\n\n          // Clean up CSS classes\n          if (child.element) {\n            child.element.classList.remove('selected-solid', 'hovered-solid', 'hovered-aura');\n          }\n\n          // Delete ALL temporary material references\n          delete child.userData.__saveModeMaterialTint;\n          delete child.userData.__saveModeMaterialOriginal;\n          delete child.userData.__surroundPlayOriginal;\n          delete child.userData.__surroundOriginalMaterial;\n          delete child.userData.__saveModeBaseMaterial;\n          delete child.userData.__saveModeOriginalMaterial;\n        });\n      });\n\n      // Clear selection array\n      this.selectedSolids = [];\n\n      // Remove combination button\n      if (this.saveCombinationBtn) {\n        this.saveCombinationBtn.remove();\n        this.saveCombinationBtn = null;\n      }\n      console.log(\"\\u2705 Cleaned \".concat(cleanedMeshes, \" meshes, restored \").concat(restoredMaterials, \" materials\"));\n    }\n  }, {\n    key: \"forceReset\",\n    value: function forceReset() {\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$restoreMaterials = _ref.restoreMaterials,\n        restoreMaterials = _ref$restoreMaterials === void 0 ? true : _ref$restoreMaterials;\n      this.clearHover();\n      this.clearAllSelections({\n        restoreMaterials: false\n      }); // Don't double-restore\n      if (restoreMaterials) {\n        this._restoreAllFromGlobalCache();\n      }\n      this._hoverCooldown = new WeakMap();\n      this.selectedSolids = [];\n    }\n\n    // NEW: Restore ALL materials from the global cache\n  }, {\n    key: \"createBoundingBoxes\",\n    value:\n    //Helper function to create Bounding boxes\n    function createBoundingBoxes() {\n      // Remove any existing bounding boxes first\n      this.removeBoundingBoxes();\n      for (var i = 0; i < this.solidMeshes.length; i++) {\n        var solid = this.solidMeshes[i];\n\n        // Calculate bounding box\n        var box = new three__WEBPACK_IMPORTED_MODULE_2__.Box3().setFromObject(solid);\n\n        // Create wireframe geometry for the bounding box\n        var size = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n        box.getSize(size);\n        var center = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n        box.getCenter(center);\n\n        // Create box geometry at origin\n        var boxGeometry = new three__WEBPACK_IMPORTED_MODULE_2__.BoxGeometry(size.x, size.y, size.z);\n\n        // Create wireframe material\n        var boxMaterial = new three__WEBPACK_IMPORTED_MODULE_2__.MeshBasicMaterial({\n          color: 0x00ff00,\n          wireframe: true,\n          transparent: true,\n          opacity: 0.5\n        });\n\n        // Create mesh\n        var boxHelper = new three__WEBPACK_IMPORTED_MODULE_2__.Mesh(boxGeometry, boxMaterial);\n\n        // Position the box at the center of the bounding box\n        boxHelper.position.copy(center);\n\n        // Add to scene\n        this.particleSystem.scene.add(boxHelper);\n\n        // Store reference\n        this.boundingBoxHelpers.push(boxHelper);\n        console.log(\"Created bounding box for solid \".concat(i, \":\"), {\n          center: center,\n          size: size\n        });\n      }\n    }\n  }, {\n    key: \"removeBoundingBoxes\",\n    value: function removeBoundingBoxes() {\n      // Remove all bounding box helpers from the scene\n      var _iterator = _createForOfIteratorHelper(this.boundingBoxHelpers),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var helper = _step.value;\n          this.particleSystem.scene.remove(helper);\n          helper.geometry.dispose();\n          helper.material.dispose();\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      this.boundingBoxHelpers = [];\n      this._saveLabelTexture = null;\n      this._hoverCooldown = new WeakMap();\n    }\n  }, {\n    key: \"setupInteractions\",\n    value: function setupInteractions() {\n      this.onMouseClick = this.onMouseClick.bind(this);\n      this.onMouseMove = this.onMouseMove.bind(this);\n      this.raycaster = new three__WEBPACK_IMPORTED_MODULE_2__.Raycaster();\n      this.mouse = new three__WEBPACK_IMPORTED_MODULE_2__.Vector2();\n    }\n  }, {\n    key: \"onMouseMove\",\n    value: function onMouseMove(event) {\n      if (!this.isSaveMode) return;\n      var rect = this.mainRenderer.domElement.getBoundingClientRect();\n      this.mouse.x = (event.clientX - rect.left) / rect.width * 2 - 1;\n      this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;\n      this.raycaster.setFromCamera(this.mouse, this.mainCamera);\n      var intersects = this.raycaster.intersectObjects(this.solidMeshes, true);\n      if (intersects.length > 0) {\n        var rootSolid = intersects[0].object;\n        while (rootSolid.parent && !this.solidMeshes.includes(rootSolid)) {\n          rootSolid = rootSolid.parent;\n        }\n        var solidIndex = this.solidMeshes.indexOf(rootSolid);\n        if (solidIndex !== -1) {\n          var cooldownUntil = this._hoverCooldown.get(rootSolid);\n          if (cooldownUntil && performance.now() < cooldownUntil) return;\n          if (cooldownUntil) this._hoverCooldown[\"delete\"](rootSolid);\n          this.hoverSolid(rootSolid, solidIndex);\n          return;\n        }\n      }\n\n      // Clear hover when pointer is NOT over any solid\n      this.clearHover();\n    }\n  }, {\n    key: \"onMouseClick\",\n    value: function onMouseClick(event) {\n      if (!this.isSaveMode) return;\n\n      // Calculate mouse position in normalized device coordinates\n      var rect = this.mainRenderer.domElement.getBoundingClientRect();\n      this.mouse.x = (event.clientX - rect.left) / rect.width * 2 - 1;\n      this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;\n\n      // Update the raycaster\n      this.raycaster.setFromCamera(this.mouse, this.mainCamera);\n\n      // Find intersections with solids\n      var intersects = this.raycaster.intersectObjects(this.solidMeshes, true);\n      if (intersects.length > 0) {\n        var clickedObject = intersects[0].object;\n\n        // Find the root solid (in case we clicked on a child mesh)\n        var rootSolid = clickedObject;\n        while (rootSolid.parent && !this.solidMeshes.includes(rootSolid)) {\n          rootSolid = rootSolid.parent;\n        }\n\n        // If we found a valid solid, select it\n        var solidIndex = this.solidMeshes.indexOf(rootSolid);\n        if (solidIndex !== -1) {\n          this.selectSolid(rootSolid, solidIndex);\n        }\n      }\n    }\n  }, {\n    key: \"hoverSolid\",\n    value: function hoverSolid(solid, index) {\n      var cooldownUntil = this._hoverCooldown.get(solid);\n      if (cooldownUntil && performance.now() < cooldownUntil) return;\n\n      // Don't re-hover if already hovering this solid\n      if (solid === this.hoveredSolid) return;\n\n      // Clear previous hover\n      if (this.hoveredSolid) {\n        this.clearHover();\n      }\n      this.hoveredSolid = solid;\n      this.hoveredSolidIndex = index;\n      this.addHoverOutline(solid);\n      this.mainRenderer.domElement.style.cursor = 'pointer';\n    }\n  }, {\n    key: \"addHoverOutline\",\n    value: function addHoverOutline(solid) {\n      var _this4 = this;\n      var isSelected = this.selectedSolids.includes(solid);\n      solid.traverse(function (child) {\n        if (!child.isMesh) return;\n        if (!child.userData.__saveModeMaterialOriginal) {\n          child.userData.__saveModeMaterialOriginal = child.material;\n        }\n        _this4._applySolidTint(child, isSelected ? 0.6 : 0.35);\n      });\n    }\n  }, {\n    key: \"clearHover\",\n    value: function clearHover() {\n      var _this5 = this;\n      if (!this.hoveredSolid) return;\n      var isSelected = this.selectedSolids.includes(this.hoveredSolid);\n      if (!isSelected) {\n        // Restore to original material from global cache\n        this.hoveredSolid.traverse(function (child) {\n          if (child.isMesh) {\n            var originalMaterial = _this5._globalMaterialCache.get(child);\n            if (originalMaterial) {\n              child.material = originalMaterial;\n            }\n            if (child.element) {\n              child.element.classList.remove('hovered-solid', 'hovered-aura');\n            }\n          }\n        });\n      } else {\n        // Re-apply selection tint (without hover intensity)\n        this.addSelectionOutline(this.hoveredSolid);\n      }\n      this.hoveredSolid = null;\n      this.hoveredSolidIndex = -1;\n      this.mainRenderer.domElement.style.cursor = 'default';\n    }\n  }, {\n    key: \"addSelectionOutline\",\n    value: function addSelectionOutline(solid) {\n      var _this6 = this;\n      solid.traverse(function (child) {\n        if (!child.isMesh) return;\n        if (!child.userData.__saveModeMaterialOriginal) {\n          child.userData.__saveModeMaterialOriginal = child.material;\n        }\n        _this6._applySolidTint(child, 0.65);\n      });\n    }\n  }, {\n    key: \"selectSolid\",\n    value: function selectSolid(solid, index) {\n      var _solid$userData;\n      // If already selected, deselect (do not retrigger audio)\n      if (solid.userData.__saveModeSelected === true || this.selectedSolids.includes(solid)) {\n        this.deselectSolid(solid, index);\n        return;\n      }\n      solid.userData.__saveModeSelected = true;\n      this.selectedSolids.push(solid);\n\n      // Play only this solid's audio (stop others automatically via allowOverlap: false)\n      var id = solid === null || solid === void 0 || (_solid$userData = solid.userData) === null || _solid$userData === void 0 || (_solid$userData = _solid$userData.solution) === null || _solid$userData === void 0 ? void 0 : _solid$userData.id;\n      if (id != null) {\n        try {\n          var _this$particleSystem5;\n          (_this$particleSystem5 = this.particleSystem) === null || _this$particleSystem5 === void 0 || (_this$particleSystem5 = _this$particleSystem5.surroundController) === null || _this$particleSystem5 === void 0 || _this$particleSystem5.playOneShot(id, {\n            allowOverlap: false // FIXED: Don't allow stacking\n          });\n        } catch (_unused2) {}\n      }\n      this._saveModePlayingId = id !== null && id !== void 0 ? id : null;\n      this.addSelectionOutline(solid);\n      if (!solid.userData.saveIconWorldPosition) {\n        solid.userData.saveIconWorldPosition = this.getCameraFacingFaceCenter(solid);\n      }\n      this.createSaveToLibraryButton(solid, index);\n      this.updateSaveCombinationButton();\n      console.log(\"Selected solid \".concat(index));\n    }\n  }, {\n    key: \"getCameraFacingFaceCenter\",\n    value: function getCameraFacingFaceCenter(solid) {\n      // Get bounding box\n      var box = new three__WEBPACK_IMPORTED_MODULE_2__.Box3().setFromObject(solid);\n      var min = box.min;\n      var max = box.max;\n\n      // Get camera direction relative to the solid\n      var solidWorldPosition = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n      solid.getWorldPosition(solidWorldPosition);\n      var cameraDirection = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n      cameraDirection.subVectors(this.mainCamera.position, solidWorldPosition).normalize();\n\n      // Define the 6 face centers and their normals\n      var faces = [{\n        center: new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(max.x, (min.y + max.y) / 2, (min.z + max.z) / 2),\n        normal: new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(1, 0, 0)\n      },\n      // Right face\n      {\n        center: new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(min.x, (min.y + max.y) / 2, (min.z + max.z) / 2),\n        normal: new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(-1, 0, 0)\n      },\n      // Left face\n      {\n        center: new three__WEBPACK_IMPORTED_MODULE_2__.Vector3((min.x + max.x) / 2, max.y, (min.z + max.z) / 2),\n        normal: new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(0, 1, 0)\n      },\n      // Top face\n      {\n        center: new three__WEBPACK_IMPORTED_MODULE_2__.Vector3((min.x + max.x) / 2, min.y, (min.z + max.z) / 2),\n        normal: new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(0, -1, 0)\n      },\n      // Bottom face\n      {\n        center: new three__WEBPACK_IMPORTED_MODULE_2__.Vector3((min.x + max.x) / 2, (min.y + max.y) / 2, max.z),\n        normal: new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(0, 0, 1)\n      },\n      // Front face\n      {\n        center: new three__WEBPACK_IMPORTED_MODULE_2__.Vector3((min.x + max.x) / 2, (min.y + max.y) / 2, min.z),\n        normal: new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(0, 0, -1)\n      } // Back face\n      ];\n\n      // Find the face that's most aligned with the camera direction\n      var bestFace = faces[0];\n      var bestDot = -Infinity;\n      for (var _i = 0, _faces = faces; _i < _faces.length; _i++) {\n        var face = _faces[_i];\n        // Calculate how much this face normal aligns with camera direction\n        var dot = face.normal.dot(cameraDirection);\n        if (dot > bestDot) {\n          bestDot = dot;\n          bestFace = face;\n        }\n      }\n      console.log(\"Camera-facing face center for solid:\", bestFace.center, \"(normal: \".concat(bestFace.normal.x, \", \").concat(bestFace.normal.y, \", \").concat(bestFace.normal.z, \")\"));\n      return bestFace.center.clone();\n    }\n  }, {\n    key: \"deselectSolid\",\n    value: function deselectSolid(solid, index) {\n      var _solid$userData2;\n      this.selectedSolids = this.selectedSolids.filter(function (s) {\n        return s !== solid;\n      });\n      solid.userData.__saveModeSelected = false;\n\n      // ADDED: Stop audio when deselecting\n      var id = solid === null || solid === void 0 || (_solid$userData2 = solid.userData) === null || _solid$userData2 === void 0 || (_solid$userData2 = _solid$userData2.solution) === null || _solid$userData2 === void 0 ? void 0 : _solid$userData2.id;\n      if (id != null && this._saveModePlayingId === id) {\n        try {\n          var _this$particleSystem6;\n          (_this$particleSystem6 = this.particleSystem) === null || _this$particleSystem6 === void 0 || (_this$particleSystem6 = _this$particleSystem6.surroundController) === null || _this$particleSystem6 === void 0 || _this$particleSystem6.stopAllManualPlayback();\n        } catch (e) {\n          console.error('Failed to stop audio on deselect:', e);\n        }\n        this._saveModePlayingId = null;\n      }\n\n      // ADDED: Block hover for longer time\n      this._hoverCooldown.set(solid, performance.now() + 800);\n      if (this.hoveredSolid === solid) {\n        this.hoveredSolid = null;\n        this.hoveredSolidIndex = -1;\n      }\n      this._restoreSolidMaterial(solid);\n\n      // Remove UI elements\n      if (solid.userData.saveToLibraryBtn) {\n        solid.userData.saveToLibraryBtn.remove();\n        solid.userData.saveToLibraryBtn = null;\n      }\n      if (solid.userData.save3DIcon) {\n        this.particleSystem.scene.remove(solid.userData.save3DIcon);\n        solid.userData.save3DIcon = null;\n      }\n      if (solid.userData.saveConnectionLine) {\n        this.particleSystem.scene.remove(solid.userData.saveConnectionLine);\n        solid.userData.saveConnectionLine.geometry.dispose();\n        solid.userData.saveConnectionLine.material.dispose();\n        solid.userData.saveConnectionLine = null;\n      }\n      if (solid.userData.saveLabelSprite) {\n        solid.userData.saveLabelSprite = null;\n      }\n      this.updateSaveCombinationButton();\n    }\n  }, {\n    key: \"createSaveToLibraryButton\",\n    value: function createSaveToLibraryButton(solid, solidIndex) {\n      // Remove any existing button for this solid\n      if (solid.userData.saveToLibraryBtn) {\n        solid.userData.saveToLibraryBtn.remove();\n        solid.userData.saveToLibraryBtn = null;\n      }\n\n      // Remove any existing 3D icon\n      if (solid.userData.save3DIcon) {\n        this.particleSystem.scene.remove(solid.userData.save3DIcon);\n        solid.userData.save3DIcon = null;\n      }\n      this.create3DSaveIcon(solid, solidIndex);\n      this.createHTMLButton(solid, solidIndex);\n    }\n  }, {\n    key: \"saveToLibrary\",\n    value: function saveToLibrary(solid, solidIndex) {\n      var _this7 = this;\n      console.log(\"\\uD83D\\uDCBE Saving solid \".concat(solidIndex, \" to library\"));\n      var solutionData = solid.userData.solution;\n      var audioParams = solid.userData.audioParams;\n      var descriptors = solid.userData.descriptors;\n      var category = solid.userData.category;\n      if (!solutionData || !audioParams) {\n        console.warn('‚ö†Ô∏è No real solution data found for solid, using fallback');\n        this.saveToLibraryWithFallback(solid, solidIndex);\n        return;\n      }\n\n      // NEW: Check if already exists in library\n      var testItem = {\n        type: 'solution',\n        solutionData: solutionData,\n        id: solutionData === null || solutionData === void 0 ? void 0 : solutionData.id\n      };\n      var existing = this.library.findExistingItem(testItem);\n      if (existing) {\n        this.showAlreadySavedMessage('solution', existing.name);\n        return;\n      }\n      this.showNameInputWidget('solution', function (name) {\n        var libraryItem = {\n          id: (solutionData === null || solutionData === void 0 ? void 0 : solutionData.id) || Date.now(),\n          name: name,\n          type: 'solution',\n          category: category || 'unknown',\n          description: '',\n          solid: solid,\n          solutionData: solutionData,\n          audioParams: audioParams,\n          descriptors: descriptors\n        };\n\n        // Temporarily restore material for snapshot\n        var swaps = [];\n        solid.traverse(function (child) {\n          if (child.isMesh) {\n            var original = _this7._globalMaterialCache.get(child);\n            if (original && child.material !== original) {\n              swaps.push({\n                child: child,\n                temp: child.material\n              });\n              child.material = original;\n            }\n          }\n        });\n        _this7.library.addItem(libraryItem);\n\n        // Restore tinted materials\n        swaps.forEach(function (_ref2) {\n          var child = _ref2.child,\n            temp = _ref2.temp;\n          child.material = temp;\n        });\n        alert(\"Solution \\\"\".concat(name, \"\\\" saved to library!\"));\n        _this7.deselectSolid(solid, solidIndex);\n      });\n    }\n  }, {\n    key: \"saveToLibraryWithFallback\",\n    value:\n    // **NEW: Fallback method for solids without real data**\n    function saveToLibraryWithFallback(solid, solidIndex) {\n      var _this8 = this;\n      console.warn('‚ö†Ô∏è Using fallback dummy data for solid without real solution data');\n\n      // **FIX: Use solid.uuid consistently as the ID**\n      var fallbackId = solid.uuid;\n      var testItem = {\n        type: 'solution',\n        id: fallbackId,\n        solid: solid // **IMPORTANT: Pass the solid reference**\n      };\n      var existing = this.library.findExistingItem(testItem);\n      if (existing) {\n        this.showAlreadySavedMessage('solution', existing.name);\n        return;\n      }\n      this.showNameInputWidget('solution', function (name) {\n        var audioParams = _this8.getFallbackAudioParams();\n        var libraryItem = {\n          id: fallbackId,\n          // **FIX: Use solid.uuid as primary ID**\n          solutionId: fallbackId,\n          // **FIX: Also set solutionId explicitly**\n          name: name,\n          type: 'solution',\n          category: audioParams.category || 'unknown',\n          description: '',\n          solid: solid,\n          solutionData: null,\n          // No real solution data\n          audioParams: audioParams,\n          descriptors: _this8.getFallbackDescriptors()\n        };\n        _this8.library.addItem(libraryItem);\n        alert(\"Solution \\\"\".concat(name, \"\\\" saved to library with fallback data!\"));\n        _this8.deselectSolid(solid, solidIndex);\n      });\n    }\n  }, {\n    key: \"create3DSaveIcon\",\n    value: function create3DSaveIcon(solid, solidIndex) {\n      var _this9 = this;\n      var iconGroup = new three__WEBPACK_IMPORTED_MODULE_2__.Group();\n\n      // INCREASED SIZE: Larger icon\n      var horizontalGeometry = new three__WEBPACK_IMPORTED_MODULE_2__.BoxGeometry(3.0, 0.3, 0.6); // Increased from 2.0, 0.15, 0.5\n      var verticalGeometry = new three__WEBPACK_IMPORTED_MODULE_2__.BoxGeometry(0.3, 3.0, 0.6); // Increased from 0.15, 2.0, 0.5\n\n      // Glowing material\n      var iconMaterial = new three__WEBPACK_IMPORTED_MODULE_2__.MeshStandardMaterial({\n        color: 0x00ffaa,\n        emissive: 0x00ffaa,\n        emissiveIntensity: 1.2,\n        transparent: true,\n        opacity: 1.0,\n        metalness: 0.3,\n        roughness: 0.2\n      });\n      var horizontalBar = new three__WEBPACK_IMPORTED_MODULE_2__.Mesh(horizontalGeometry, iconMaterial);\n      var verticalBar = new three__WEBPACK_IMPORTED_MODULE_2__.Mesh(verticalGeometry, iconMaterial);\n      iconGroup.add(horizontalBar);\n      iconGroup.add(verticalBar);\n\n      // Get solid bounding box to find top center\n      var box = new three__WEBPACK_IMPORTED_MODULE_2__.Box3().setFromObject(solid);\n      var size = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n      box.getSize(size);\n      var center = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n      box.getCenter(center);\n\n      // Position icon ABOVE the solid with extra height\n      var heightAboveSolid = 8; // Height above the solid's top\n      var topY = box.max.y + heightAboveSolid;\n\n      // Use the center X and Z, but position at top\n      var iconPosition = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(center.x, topY, center.z);\n      iconGroup.position.copy(iconPosition);\n\n      // Store for line connection\n      solid.userData.saveIconWorldPosition = iconPosition;\n      solid.userData.solidTopPosition = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(center.x, box.max.y, center.z);\n\n      // Scale based on distance\n      var distance = iconPosition.distanceTo(this.mainCamera.position);\n      var minScale = 1.0;\n      var maxScale = 1.5;\n      var minDist = 10;\n      var maxDist = 80;\n      var scale = Math.max(minScale, Math.min(maxScale, maxScale - (distance - minDist) / (maxDist - minDist) * (maxScale - minScale)));\n      iconGroup.scale.setScalar(scale);\n\n      // Always face camera\n      iconGroup.lookAt(this.mainCamera.position);\n\n      // CREATE VERTICAL LINE from solid top to icon\n      var lineGeometry = new three__WEBPACK_IMPORTED_MODULE_2__.BufferGeometry();\n      var linePositions = new Float32Array([center.x, box.max.y, center.z,\n      // Start at solid top\n      center.x, topY, center.z // End at icon position\n      ]);\n      lineGeometry.setAttribute('position', new three__WEBPACK_IMPORTED_MODULE_2__.BufferAttribute(linePositions, 3));\n      var lineMaterial = new three__WEBPACK_IMPORTED_MODULE_2__.LineBasicMaterial({\n        color: 0x00ffaa,\n        // Same color as icon\n        transparent: true,\n        opacity: 0,\n        linewidth: 1\n      });\n      var connectionLine = new three__WEBPACK_IMPORTED_MODULE_2__.Line(lineGeometry, lineMaterial);\n      connectionLine.layers.enable(1); // Enable bloom\n\n      // Add line to scene\n      /* this.particleSystem.scene.add(connectionLine);*/\n\n      // Store line reference\n      solid.userData.saveConnectionLine = connectionLine;\n\n      // Animation with line update\n      iconGroup.userData.animationOffset = Math.random() * Math.PI * 2;\n      iconGroup.userData.baseY = topY;\n      iconGroup.userData.update = function (time) {\n        // Subtle floating animation\n        var floatOffset = Math.sin(time * 2 + iconGroup.userData.animationOffset) * 0.15;\n        iconGroup.position.y = iconGroup.userData.baseY + floatOffset;\n\n        // Update line end position to follow icon\n        var positions = connectionLine.geometry.attributes.position.array;\n        positions[4] = iconGroup.position.y; // Update Y of second point (end of line)\n        connectionLine.geometry.attributes.position.needsUpdate = true;\n\n        // Gentle rotation\n        iconGroup.rotation.z = Math.sin(time * 1.5 + iconGroup.userData.animationOffset) * 0.1;\n\n        // Always face camera\n        iconGroup.lookAt(_this9.mainCamera.position);\n\n        // Subtle line opacity pulse\n        connectionLine.material.opacity = 0.6 + Math.sin(time * 1.5) * 0.2;\n      };\n\n      // Enable bloom layer\n      iconGroup.layers.enable(1);\n      iconGroup.traverse(function (child) {\n        if (child.isMesh) {\n          child.layers.enable(1);\n        }\n      });\n\n      // Add to scene\n      this.particleSystem.scene.add(iconGroup);\n\n      // Store reference\n      solid.userData.save3DIcon = iconGroup;\n      console.log(\"Created 3D save icon with connection line for solid \".concat(solidIndex));\n      var label = this._createSaveLabelSprite();\n      label.position.set(0, -2.8, 0);\n      label.scale.set(6, 2.2, 1);\n      label.renderOrder = 5;\n      label.material.depthTest = false;\n      iconGroup.add(label);\n    }\n  }, {\n    key: \"createHTMLButton\",\n    value: function createHTMLButton(solid, solidIndex) {\n      var _this10 = this;\n      // Create invisible HTML button for click detection\n      var saveBtn = document.createElement('button');\n      saveBtn.className = 'save-to-library-btn-3d';\n      saveBtn.setAttribute('data-solid-index', solidIndex);\n      saveBtn.style.position = 'absolute';\n      saveBtn.style.background = 'transparent';\n      saveBtn.style.border = 'none';\n      saveBtn.style.cursor = 'pointer';\n      saveBtn.style.zIndex = '2000';\n      saveBtn.style.borderRadius = '50%';\n      var distance = solid.userData.saveIconWorldPosition.distanceTo(this.mainCamera.position);\n      var minScale = 0.5;\n      var maxScale = 1.0;\n      var minDist = 10;\n      var maxDist = 80;\n      var scale = Math.max(minScale, Math.min(maxScale, maxScale - (distance - minDist) / (maxDist - minDist) * (maxScale - minScale)));\n\n      // Base button size scaled by distance\n      var baseSize = 60;\n      var scaledSize = baseSize * scale;\n      saveBtn.style.width = \"\".concat(scaledSize, \"px\");\n      saveBtn.style.height = \"\".concat(scaledSize, \"px\");\n\n      // Position button over the 3D icon\n      this.updateHTMLButtonPosition(saveBtn, solid);\n      document.body.appendChild(saveBtn);\n\n      // Store reference\n      solid.userData.saveToLibraryBtn = saveBtn;\n      saveBtn.onclick = function () {\n        return _this10.saveToLibrary(solid, solidIndex);\n      };\n    }\n  }, {\n    key: \"updateHTMLButtonPosition\",\n    value: function updateHTMLButtonPosition(button, solid) {\n      if (!solid.userData.save3DIcon) return;\n\n      // Project 3D icon position to screen space\n      var iconPosition = solid.userData.save3DIcon.position.clone();\n      var projected = iconPosition.project(this.mainCamera);\n      var x = (projected.x * 0.5 + 0.5) * window.innerWidth;\n      var y = (projected.y * -0.5 + 0.5) * window.innerHeight;\n      var buttonSize = parseFloat(button.style.width) || 60;\n      var halfSize = buttonSize / 2;\n\n      // Center the button on the projected position\n      button.style.left = \"\".concat(x - halfSize, \"px\");\n      button.style.top = \"\".concat(y - halfSize, \"px\");\n    }\n  }, {\n    key: \"update3DIconPositions\",\n    value: function update3DIconPositions() {\n      var _this11 = this;\n      if (!this.isSaveMode) return;\n      var time = performance.now() * 0.001;\n      this.selectedSolids.forEach(function (solid) {\n        // Update 3D icon animation\n        if (solid.userData.save3DIcon && solid.userData.save3DIcon.userData.update) {\n          solid.userData.save3DIcon.userData.update(time);\n        }\n\n        // Update HTML button position\n        if (solid.userData.saveToLibraryBtn) {\n          _this11.updateHTMLButtonPosition(solid.userData.saveToLibraryBtn, solid);\n        }\n      });\n    }\n\n    // (If this duplicate exists later, keep it consistent)\n  }, {\n    key: \"saveCombination\",\n    value: function saveCombination() {\n      var _this12 = this;\n      console.log(\"\\uD83D\\uDCBE Saving combination of \".concat(this.selectedSolids.length, \" solids\"));\n      var items = this.selectedSolids.map(function (solid, index) {\n        var solutionData = solid.userData.solution;\n        var audioParams = solid.userData.audioParams;\n        var descriptors = solid.userData.descriptors;\n        var category = solid.userData.category;\n        return {\n          name: solutionData ? \"\".concat(category || 'Unknown', \" Sound \").concat(index + 1) : \"Sound \".concat(index + 1),\n          solid: solid,\n          solutionData: solutionData,\n          audioParams: audioParams || _this12.getFallbackAudioParams(),\n          descriptors: descriptors || _this12.getFallbackDescriptors(),\n          category: category || 'unknown',\n          fitness: (solutionData === null || solutionData === void 0 ? void 0 : solutionData.fitness) || 0\n        };\n      });\n\n      // NEW: Check if combination already exists\n      var testItem = {\n        type: 'combination',\n        items: items\n      };\n      var existing = this.library.findExistingItem(testItem);\n      if (existing) {\n        this.showAlreadySavedMessage('combination', existing.name);\n        return;\n      }\n      this.showNameInputWidget('combination', function (name) {\n        var categories = items.map(function (i) {\n          return i.category;\n        }).filter(Boolean);\n        var avgFitness = items.reduce(function (s, it) {\n          return s + (it.fitness || 0);\n        }, 0) / Math.max(1, items.length);\n        var uniqueCategories = _toConsumableArray(new Set(categories));\n        var libraryItem = {\n          id: Date.now(),\n          name: name,\n          type: 'combination',\n          description: '',\n          items: items,\n          solid: _this12.selectedSolids[Math.floor(Math.random() * _this12.selectedSolids.length)]\n        };\n        _this12.library.addItem(libraryItem);\n        alert(\"Combination \\\"\".concat(name, \"\\\" saved to library!\"));\n        _this12.clearAllSelections();\n      });\n    }\n  }, {\n    key: \"showNameInputWidget\",\n    value: function showNameInputWidget(type, onSave) {\n      // Create overlay\n      var overlay = document.createElement('div');\n      overlay.className = 'name-input-overlay';\n\n      // Create widget\n      var widget = document.createElement('div');\n      widget.className = 'name-input-widget';\n\n      // Create title\n      var title = document.createElement('h3');\n      title.textContent = \"Name your \".concat(type);\n      widget.appendChild(title);\n\n      // Create input\n      var input = document.createElement('input');\n      input.type = 'text';\n      input.placeholder = \"Enter \".concat(type, \" name...\");\n      input.value = \"My \".concat(type, \" \").concat(Date.now());\n      widget.appendChild(input);\n\n      // Create buttons container\n      var buttonsContainer = document.createElement('div');\n      buttonsContainer.className = 'name-input-buttons';\n\n      // Create save button with icon\n      var saveBtn = document.createElement('button');\n      saveBtn.className = 'name-input-btn save';\n      saveBtn.title = 'Save';\n      saveBtn.innerHTML = '<img src=\"/assets/icons/Confirm.svg\" alt=\"Save\" class=\"name-input-icon\">';\n      saveBtn.onclick = function () {\n        var name = input.value.trim();\n        if (name) {\n          onSave(name);\n          overlay.remove();\n        } else {\n          input.focus();\n          input.style.borderColor = '#dc3545';\n        }\n      };\n\n      // Create cancel button with icon\n      var cancelBtn = document.createElement('button');\n      cancelBtn.className = 'name-input-btn cancel';\n      cancelBtn.title = 'Cancel';\n      cancelBtn.innerHTML = '<img src=\"/assets/icons/Cancel.svg\" alt=\"Cancel\" class=\"name-input-icon\">';\n      cancelBtn.onclick = function () {\n        overlay.remove();\n      };\n      buttonsContainer.appendChild(saveBtn);\n      buttonsContainer.appendChild(cancelBtn);\n      widget.appendChild(buttonsContainer);\n      overlay.appendChild(widget);\n      document.body.appendChild(overlay);\n\n      // Auto-focus input\n      setTimeout(function () {\n        input.focus();\n        input.select();\n      }, 100);\n\n      // NEW: Stop propagation of ALL keyboard events from input\n      input.addEventListener('keydown', function (e) {\n        e.stopPropagation(); // Prevent event from bubbling up\n        e.stopImmediatePropagation(); // Stop other handlers on same element\n\n        if (e.key === 'Enter') {\n          e.preventDefault();\n          saveBtn.click();\n        } else if (e.key === 'Escape') {\n          e.preventDefault();\n          cancelBtn.click();\n        }\n      });\n\n      // NEW: Also stop keyup and keypress events\n      input.addEventListener('keyup', function (e) {\n        e.stopPropagation();\n        e.stopImmediatePropagation();\n      });\n      input.addEventListener('keypress', function (e) {\n        e.stopPropagation();\n        e.stopImmediatePropagation();\n      });\n\n      // Click overlay to close\n      overlay.addEventListener('click', function (e) {\n        if (e.target === overlay) {\n          overlay.remove();\n        }\n      });\n    }\n  }, {\n    key: \"updateSaveCombinationButton\",\n    value: function updateSaveCombinationButton() {\n      var _this13 = this;\n      // Remove if exists\n      if (this.saveCombinationBtn) {\n        this.saveCombinationBtn.remove();\n        this.saveCombinationBtn = null;\n      }\n      if (this.selectedSolids.length > 1) {\n        this.saveCombinationBtn = document.createElement('button');\n        this.saveCombinationBtn.className = 'save-combination-btn';\n        this.saveCombinationBtn.innerText = 'Save Combination';\n        document.body.appendChild(this.saveCombinationBtn);\n        this.saveCombinationBtn.onclick = function () {\n          return _this13.saveCombination();\n        };\n      }\n    }\n  }, {\n    key: \"clearSelection\",\n    value: function clearSelection() {\n      var _this14 = this;\n      this.selectedSolids.forEach(function (solid) {\n        var _solid$userData3;\n        solid.userData.__saveModeSelected = false;\n        // If any selected solid owns the currently playing id, silence it\n        var id = solid === null || solid === void 0 || (_solid$userData3 = solid.userData) === null || _solid$userData3 === void 0 || (_solid$userData3 = _solid$userData3.solution) === null || _solid$userData3 === void 0 ? void 0 : _solid$userData3.id;\n        if (id != null && _this14._saveModePlayingId === id) {\n          try {\n            var _this14$particleSyste;\n            (_this14$particleSyste = _this14.particleSystem) === null || _this14$particleSyste === void 0 || (_this14$particleSyste = _this14$particleSyste.surroundController) === null || _this14$particleSyste === void 0 || _this14$particleSyste.fadeOutAll(120);\n          } catch (_unused3) {}\n          _this14._saveModePlayingId = null;\n        }\n        solid.traverse(function (child) {\n          if (child.isMesh) {\n            // Always restore the true original material\n            if (child.userData.originalMaterial) {\n              child.material = child.userData.originalMaterial;\n              delete child.userData.originalMaterial;\n            }\n            // Remove any leftover hover material reference\n            if (child.userData.originalHoverMaterial) {\n              delete child.userData.originalHoverMaterial;\n            }\n          }\n          if (child.element) {\n            child.element.classList.remove('selected-solid');\n            child.element.classList.remove('hovered-solid');\n            child.element.classList.remove('hovered-aura');\n          }\n        });\n\n        // Remove this solid's HTML button\n        if (solid.userData.saveToLibraryBtn) {\n          solid.userData.saveToLibraryBtn.remove();\n          solid.userData.saveToLibraryBtn = null;\n        }\n\n        // Remove 3D icon\n        if (solid.userData.save3DIcon) {\n          _this14.particleSystem.scene.remove(solid.userData.save3DIcon);\n          solid.userData.save3DIcon = null;\n        }\n\n        // **NEW: Remove connection line**\n        if (solid.userData.saveConnectionLine) {\n          _this14.particleSystem.scene.remove(solid.userData.saveConnectionLine);\n          solid.userData.saveConnectionLine.geometry.dispose();\n          solid.userData.saveConnectionLine.material.dispose();\n          solid.userData.saveConnectionLine = null;\n        }\n      });\n\n      // Ensure nothing continues playing\n      try {\n        var _this$particleSystem7;\n        (_this$particleSystem7 = this.particleSystem) === null || _this$particleSystem7 === void 0 || (_this$particleSystem7 = _this$particleSystem7.surroundController) === null || _this$particleSystem7 === void 0 || _this$particleSystem7.fadeOutAll(120);\n      } catch (_unused4) {}\n      this._saveModePlayingId = null;\n    }\n  }, {\n    key: \"clearAllSelections\",\n    value: function clearAllSelections() {\n      var _this15 = this;\n      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref3$restoreMaterial = _ref3.restoreMaterials,\n        restoreMaterials = _ref3$restoreMaterial === void 0 ? true : _ref3$restoreMaterial;\n      _toConsumableArray(this.selectedSolids).forEach(function (solid) {\n        var index = _this15.solidMeshes.indexOf(solid);\n        _this15.deselectSolid(solid, index);\n      });\n      if (this.saveCombinationBtn) {\n        this.saveCombinationBtn.remove();\n        this.saveCombinationBtn = null;\n      }\n      if (restoreMaterials) {\n        this._forceCleanupAllMaterials(false);\n      }\n    }\n  }, {\n    key: \"showAlreadySavedMessage\",\n    value: function showAlreadySavedMessage(type, existingName) {\n      // Create overlay\n      var overlay = document.createElement('div');\n      overlay.className = 'name-input-overlay';\n\n      // Create widget\n      var widget = document.createElement('div');\n      widget.className = 'name-input-widget';\n\n      // Create title\n      var title = document.createElement('h3');\n      title.textContent = \"\".concat(type.charAt(0).toUpperCase() + type.slice(1), \" Already Saved\");\n      widget.appendChild(title);\n\n      // Create message\n      var message = document.createElement('p');\n      message.innerHTML = \"This \".concat(type, \" is already in your library as:<br><strong>\\\"\").concat(existingName, \"\\\"</strong>\"); // CHANGED: Removed inline styles\n      widget.appendChild(message);\n\n      // Create buttons container\n      var buttonsContainer = document.createElement('div');\n      buttonsContainer.className = 'name-input-buttons';\n\n      // Create OK button\n      var okBtn = document.createElement('button');\n      okBtn.className = 'name-input-btn save';\n      okBtn.textContent = 'OK';\n      okBtn.onclick = function () {\n        overlay.remove();\n      };\n      buttonsContainer.appendChild(okBtn);\n      widget.appendChild(buttonsContainer);\n      overlay.appendChild(widget);\n      document.body.appendChild(overlay);\n\n      // Auto-focus OK button\n      setTimeout(function () {\n        return okBtn.focus();\n      }, 100);\n\n      // Allow ESC and Enter to close\n      var _handleKey = function handleKey(e) {\n        if (e.key === 'Enter' || e.key === 'Escape') {\n          overlay.remove();\n          document.removeEventListener('keydown', _handleKey);\n        }\n      };\n      document.addEventListener('keydown', _handleKey);\n\n      // Click overlay to close\n      overlay.addEventListener('click', function (e) {\n        if (e.target === overlay) {\n          overlay.remove();\n          document.removeEventListener('keydown', _handleKey);\n        }\n      });\n    }\n\n    // CHANGE 1: Fix material caching to NOT clone (use reference instead)\n  }, {\n    key: \"_cacheOriginalMaterials\",\n    value: function _cacheOriginalMaterials() {\n      var _this16 = this;\n      if (this._baseMaterialsCached) return;\n      console.log('üì¶ Caching original materials');\n      this.solidMeshes.forEach(function (solid) {\n        solid.traverse(function (child) {\n          if (!child.isMesh) return;\n\n          // CRITICAL: Cache the CURRENT material as the true original\n          // (This should be the untinted material from main scene)\n          if (!child.userData.__saveModeOriginalMaterial) {\n            child.userData.__saveModeOriginalMaterial = child.material;\n            child.userData.__saveModeBaseMaterial = _this16._cloneMaterial(child.material);\n          }\n        });\n      });\n      this._baseMaterialsCached = true;\n      console.log('‚úÖ Original materials cached');\n    }\n\n    // CHANGE 2: Fix material restoration to use reference, not clone\n  }, {\n    key: \"_restoreSolidMaterial\",\n    value: function _restoreSolidMaterial(solid) {\n      var _this17 = this;\n      if (!solid) return;\n      solid.traverse(function (child) {\n        if (!child.isMesh) return;\n\n        // Always restore from global cache\n        var originalMaterial = _this17._globalMaterialCache.get(child);\n        if (originalMaterial) {\n          child.material = originalMaterial;\n        }\n        if (child.element) {\n          child.element.classList.remove('selected-solid', 'hovered-solid', 'hovered-aura');\n        }\n      });\n    }\n\n    // CHANGE 3: Fix force cleanup to use reference\n  }, {\n    key: \"_forceCleanupAllMaterials\",\n    value: function _forceCleanupAllMaterials() {\n      var removeCache = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      console.log('üßπ Force cleaning all materials');\n      this.solidMeshes.forEach(function (solid) {\n        if (!solid) return;\n        solid.traverse(function (child) {\n          if (!child.isMesh) return;\n\n          // CRITICAL: Always restore to the ORIGINAL material we cached on enter\n          var originalMaterial = child.userData.__saveModeOriginalMaterial;\n          if (originalMaterial) {\n            child.material = originalMaterial;\n          }\n\n          // Clean up CSS classes\n          if (child.element) {\n            child.element.classList.remove('selected-solid', 'hovered-solid', 'hovered-aura');\n          }\n\n          // Delete ALL temporary material references\n          delete child.userData.__saveModeMaterialTint;\n          delete child.userData.__saveModeMaterialOriginal;\n          if (removeCache) {\n            delete child.userData.__saveModeBaseMaterial;\n            delete child.userData.__saveModeOriginalMaterial;\n          }\n        });\n\n        // Clean up solid-level flags\n        delete solid.userData.__saveModeSelected;\n      });\n      console.log('‚úÖ All materials restored to original state');\n    }\n  }, {\n    key: \"_createSaveLabelSprite\",\n    value: function _createSaveLabelSprite() {\n      if (!this._saveLabelTexture) {\n        var canvas = document.createElement('canvas');\n        canvas.width = 256;\n        canvas.height = 128;\n        var ctx = canvas.getContext('2d');\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        ctx.font = '600 58px \"Space Grotesk\", sans-serif';\n        ctx.fillStyle = '#ffffff';\n        ctx.textAlign = 'center';\n        ctx.textBaseline = 'middle';\n        ctx.fillText('SAVE', canvas.width / 2, canvas.height / 2);\n        this._saveLabelTexture = new three__WEBPACK_IMPORTED_MODULE_2__.CanvasTexture(canvas);\n        this._saveLabelTexture.minFilter = three__WEBPACK_IMPORTED_MODULE_2__.LinearFilter;\n        this._saveLabelTexture.magFilter = three__WEBPACK_IMPORTED_MODULE_2__.LinearFilter;\n        this._saveLabelTexture.needsUpdate = true;\n      }\n      return new three__WEBPACK_IMPORTED_MODULE_2__.Sprite(new three__WEBPACK_IMPORTED_MODULE_2__.SpriteMaterial({\n        map: this._saveLabelTexture,\n        transparent: true,\n        depthWrite: false,\n        depthTest: false\n      }));\n    }\n  }, {\n    key: \"_applySolidTint\",\n    value: function _applySolidTint(child) {\n      var intensity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.5;\n      if (!child.isMesh) return;\n      var originalMaterial = this._globalMaterialCache.get(child);\n      if (!originalMaterial) {\n        console.warn('‚ö†Ô∏è No cached material for mesh');\n        return;\n      }\n\n      // Clone the ORIGINAL and tint it\n      var tinted = this._createTintedMaterial(originalMaterial, intensity);\n      child.material = tinted;\n    }\n  }, {\n    key: \"_createTintedMaterial\",\n    value: function _createTintedMaterial(source, intensity) {\n      var _source$opacity;\n      if (!source || typeof source.clone !== 'function') return source;\n      var cloned = source.clone();\n      var aura = new three__WEBPACK_IMPORTED_MODULE_2__.Color(0x53d3c0);\n      if ('emissive' in cloned) {\n        var _cloned$emissiveInten;\n        cloned.emissive = aura.clone();\n        cloned.emissiveIntensity = Math.max(intensity, (_cloned$emissiveInten = cloned.emissiveIntensity) !== null && _cloned$emissiveInten !== void 0 ? _cloned$emissiveInten : 0);\n      }\n      if ('color' in cloned) {\n        cloned.color = cloned.color.clone().lerp(aura, 0.45);\n      }\n      cloned.transparent = true;\n      cloned.opacity = Math.min(0.95, (_source$opacity = source.opacity) !== null && _source$opacity !== void 0 ? _source$opacity : 1);\n      cloned.needsUpdate = true;\n      return cloned;\n    }\n  }, {\n    key: \"_restoreAllFromGlobalCache\",\n    value: function _restoreAllFromGlobalCache() {\n      var _this18 = this;\n      console.log('üîÑ Restoring all materials from global cache');\n      this.solidMeshes.forEach(function (solid) {\n        solid.traverse(function (child) {\n          if (child.isMesh) {\n            var originalMaterial = _this18._globalMaterialCache.get(child);\n            if (originalMaterial) {\n              child.material = originalMaterial;\n            }\n\n            // Clean up ALL temporary userData\n            delete child.userData.__saveModeMaterialTint;\n            delete child.userData.__saveModeMaterialOriginal;\n            delete child.userData.__saveModeBaseMaterial;\n            delete child.userData.__saveModeOriginalMaterial;\n            delete child.userData.__surroundPlayOriginal;\n            delete child.userData.__surroundOriginalMaterial;\n\n            // Clean up CSS classes\n            if (child.element) {\n              child.element.classList.remove('selected-solid', 'hovered-solid', 'hovered-aura');\n            }\n          }\n        });\n        delete solid.userData.__saveModeSelected;\n      });\n    }\n  }]);\n}();\n\n//# sourceURL=webpack://sound-particle-visualization/./src/components/SaveMode.js?");

/***/ }),

/***/ "./src/components/SpatialGrid.js":
/*!***************************************!*\
  !*** ./src/components/SpatialGrid.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SpatialGrid: () => (/* binding */ SpatialGrid),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n// Add this helper class at the top of ParticleSystem.js (before the ParticleSystem class)\n\nvar SpatialGrid = /*#__PURE__*/function () {\n  function SpatialGrid(cellSize) {\n    _classCallCheck(this, SpatialGrid);\n    this.cellSize = cellSize;\n    this.grid = new Map();\n  }\n  return _createClass(SpatialGrid, [{\n    key: \"_hash\",\n    value: function _hash(x, z) {\n      var cx = Math.floor(x / this.cellSize);\n      var cz = Math.floor(z / this.cellSize);\n      return \"\".concat(cx, \",\").concat(cz);\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.grid.clear();\n    }\n  }, {\n    key: \"insert\",\n    value: function insert(index, position) {\n      var key = this._hash(position.x, position.z);\n      if (!this.grid.has(key)) {\n        this.grid.set(key, []);\n      }\n      this.grid.get(key).push(index);\n    }\n  }, {\n    key: \"getNearby\",\n    value: function getNearby(position, radius) {\n      var nearby = [];\n      var cells = Math.ceil(radius / this.cellSize);\n      var cx = Math.floor(position.x / this.cellSize);\n      var cz = Math.floor(position.z / this.cellSize);\n\n      // Check neighboring cells\n      for (var dx = -cells; dx <= cells; dx++) {\n        for (var dz = -cells; dz <= cells; dz++) {\n          var key = \"\".concat(cx + dx, \",\").concat(cz + dz);\n          var cell = this.grid.get(key);\n          if (cell) {\n            nearby.push.apply(nearby, _toConsumableArray(cell));\n          }\n        }\n      }\n      return nearby;\n    }\n  }]);\n}();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SpatialGrid);\n\n//# sourceURL=webpack://sound-particle-visualization/./src/components/SpatialGrid.js?");

/***/ }),

/***/ "./src/components/Tutorial.js":
/*!************************************!*\
  !*** ./src/components/Tutorial.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Tutorial: () => (/* binding */ Tutorial)\n/* harmony export */ });\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar Tutorial = /*#__PURE__*/function () {\n  function Tutorial() {\n    var container = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document.body;\n    _classCallCheck(this, Tutorial);\n    this.container = container;\n    this.messages = [\"Welcome to Shard\", \"The sounds are represented by the crystals you see on the screen\", \"To start playing the various sounds click on the button on the right\", \"On the Save mode you can store the sounds you like or combinations of them and access them on the Library\", \"On the Evolve tab you can score which sounds you like more according to their category\", \"Then click submit to send your scores and generate a new collection of sounds\", \"Have fun!\"];\n    this.currentIndex = 0;\n    this.messageElement = null;\n    this.isShowing = false;\n    this.timeoutId = null;\n  }\n  return _createClass(Tutorial, [{\n    key: \"show\",\n    value: function show() {\n      if (this.isShowing) return;\n      this.isShowing = true;\n      this.currentIndex = 0;\n      this.showCurrentMessage();\n    }\n  }, {\n    key: \"showCurrentMessage\",\n    value: function showCurrentMessage() {\n      var _this$messageElement,\n        _this = this;\n      if ((_this$messageElement = this.messageElement) !== null && _this$messageElement !== void 0 && _this$messageElement.parentElement) {\n        this.messageElement.remove();\n      }\n      this.messageElement = document.createElement('div');\n      this.messageElement.className = 'tutorial-message-overlay';\n      this.messageElement.textContent = this.messages[this.currentIndex];\n      this.container.appendChild(this.messageElement);\n      requestAnimationFrame(function () {\n        _this.messageElement.classList.add('visible');\n      });\n      clearTimeout(this.timeoutId);\n      this.timeoutId = setTimeout(function () {\n        return _this.next();\n      }, 4000);\n      var _clickHandler = function clickHandler() {\n        var _this$messageElement2;\n        clearTimeout(_this.timeoutId);\n        _this.next();\n        (_this$messageElement2 = _this.messageElement) === null || _this$messageElement2 === void 0 || _this$messageElement2.removeEventListener('click', _clickHandler);\n      };\n      this.messageElement.addEventListener('click', _clickHandler);\n    }\n  }, {\n    key: \"next\",\n    value: function next() {\n      var _this2 = this;\n      if (!this.messageElement) return;\n      this.messageElement.classList.remove('visible');\n      setTimeout(function () {\n        if (_this2.currentIndex < _this2.messages.length - 1) {\n          _this2.currentIndex += 1;\n          _this2.showCurrentMessage();\n        } else {\n          _this2.hide();\n        }\n      }, 300);\n    }\n  }, {\n    key: \"hide\",\n    value: function hide() {\n      var _this$messageElement3,\n        _this3 = this;\n      if (!this.isShowing) return;\n      clearTimeout(this.timeoutId);\n      if ((_this$messageElement3 = this.messageElement) !== null && _this$messageElement3 !== void 0 && _this$messageElement3.parentElement) {\n        this.messageElement.classList.remove('visible');\n        setTimeout(function () {\n          var _this3$messageElement;\n          return (_this3$messageElement = _this3.messageElement) === null || _this3$messageElement === void 0 ? void 0 : _this3$messageElement.remove();\n        }, 300);\n      }\n      this.isShowing = false;\n    }\n  }]);\n}();\n\n//# sourceURL=webpack://sound-particle-visualization/./src/components/Tutorial.js?");

/***/ })

}]);